<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>Welcome to Practical Jetpack Compose</title>
	</head>
<body>
<h1>Welcome to Practical Jetpack Compose</h1>

<p>Welcome to Practical Jetpack Compose - this course is aimed to take you through 12 Jetpack Compose projects, aimed to get you building common UI patterns using this new UI framework for Android. By purchasing this course you’ve made a great investment in your leaning journey - be it for professional or hobby purposes, my aim with this course is to get you building things with Jetpack Compose. After all, it’s the future of UI development for Android Apps.</p>

<h2>What this course is</h2>

<p>Throughout the 12 projects in this course you’ll be learning how to build common user interfaces using Jetpack Compose. You’ll be using a range of Compose APIs, managing state and also writing automated tests for the composables that we create. While there is some overlap in the different projects, the range of APIs and approaches covered will give you enough knowledge to be able to replicate common UI requirements in the apps that you build. </p>

<p>When it comes to the compose APIs, we’ll be covering the follow topics across the 12 projects:</p>

<ul>
	<li><strong>UI Composition</strong>: So that you can utilise composables, you&#39;ll need to learn the foundations of composing UI. Throughout the projects we&#39;ll introduce you to and guide you through UI composition, so you&#39;ll be confident in building your on compose apps from start to finish!</li>
	<li><strong>Laying out Compose UI</strong>: When it comes to laying our our composables, there are many different pieces of the layout APIs that provide support for this. Throughout the projects we build, we&#39;ll be covering all of the different parts of the layout APIs, so that you can learn how these can be used in to build Android layouts.</li>
	<li><strong> Material Design</strong>: Material Design plays a crucial part in the look and feel of Android Apps. We&#39;ll be using the Compose Material Components package throughout the projects, thoroughly using most of the components that it has to offer!</li>
	<li><strong>Architecture</strong>: The way in which we build apps is largely affected by the use of Jetpack Compose, and there are ways which can make working with Jetpack Compose much smoother! Throughout the projects we&#39;ll pay close attention to how we are architecting each features to learn how Jetpack Compose fits into Android projects.</li>
	<li><strong>Accessibility</strong>: So that you can sure your UI is accessible for your users, throughout the projects we will cover the different approaches we take to apply accessibility concepts to our composables</li>
	<li><strong>Theming</strong>: Theming allows you to declare a foundation set of properties that be applied to composabes throughout your project. We&#39;ll show you how you can do this within Jetpack Compose.</li>
	<li><strong>Animations</strong>: Animations can help to engage and delight your users. You&#39;ll learn how to create animations using Jetpack Compose during the project development!</li>
	<li><strong> Dependency Injection</strong>: Using Dependency Injection is a common use case in many projects, and things can look a little different with compose. We&#39;ll cover how you can use Hilt with Jetpack Compose and View Models.</li>
	<li><strong>Navigation</strong>: Within your apps you&#39;ll likely want to navigate between different composables. This can be done using the Compose navigation component, which you&#39;ll learn how to use thoroughly within the book!</li>
	<li><strong>Canvas Drawing</strong>: While Compose offers a lot of UI components, there are going to be times where we want to have complete control over the things we are drawing. For this we can create custom drawing and components using the canvas, which we&#39;ll learn all about throughout various projects!</li>
	<li><strong>Gestures</strong>: In all applications, user will be performing gestures against our UI. This works a little differently when it comes to Jetpack Compose but fear not, we cover all different types of gesture interactions in the projects.</li>
	<li><strong>Interoperability</strong>: Using Composables alongside the Android UI Toolkit (and vice versa) is going to be required in a range of scenarios. In the projects we will cover several scenarios on how to approach this and learn how to fully support interoperability in Compose projects.</li>
</ul>

<hr />

<h2>What this course is not</h2>

<p>This course is aimed to be the missing guide between the introduction of Jetpack Compose, to shipping features to users. There are plenty of informative guides for the foundations and intervals of Jetpack Compose, so this course does not try to replicate those. While we do touch on introductory level topics both in this chapter and throughout the projects, it would be worthwhile checking out the <a href="https://developer.android.com/jetpack/compose/mental-model">official getting started guides</a> for Jetpack Compose if you are looking to cover more of the foundational topics.</p>

<p>This course is also not a deep dive into Jetpack Compose. As mentioned above, the aim is to get you using Jetpack Compose to build UI, giving you the confidence and knowledge to continue exploring the APIs for your own projects. If you are looking to learn more about deeper compose topics and how things are working under the hood, I would highly recommended checking out <a href="https://jorgecastillo.dev/book/">Jetpack Compose Internals</a> by <a href="https://twitter.com/jorgecastillopr">Jorge Castillo</a>.</p>

<p>Throughout the book we touch on various Android Development and Kotlin concepts. If you are following this course then it is recommended that you have some knowledge of both of these topics. We will not be covering any introductory concepts for these things, so it’s possible you will face some hurdles during the projects without any experience here.</p>

<hr />

<h2>Frequently Asked Questions</h2>

<h3>Will the course and project be kept up-to-date?</h3>

<p>The project will be updated for this version of the course if there are any breaking issues or bugs that occur, but the release of this version of the course is only valid for Jetpack Compose v1.1. The project will not be updated to version Jetpack Compose 1.2.0 until there is a version 2 of this course released.</p>

<h3>I purchased the beta release, when can I expect the finished release?</h3>

<p>There is currently no set date for the finalised version, but you can expect it in early 2022. The remaining chapters will be released as and when they are finished - which will likely be every 3-4 weeks. I work on this course as a side-project and with life commitments, hard dates aren’t easy to lay out.</p>

<h3>Not happy with your purchase?</h3>

<p>If you purchase this course and it’s not quite what you had expected, you can get a full refund within 72 hours of your purchase date. No questions asked!</p>

<h3>Can I use the code from this course in my own projects?</h3>

<p>Both the code from the projects and the code samples in this book comes with the Apache License 2.0. Please be sure to read these licenses if you are going to be taking the code into some of your own projects.</p>

<h3>Any more questions?</h3>

<p>If you have any further questions on this course, please check the <a href="http://practicaljetpackcompose.com/">Practical Jetpack Compose</a> website to see if they’ve already been answered. Otherwise, please feel free to reach out at contact@compose.academy</p>

<h1>Approaching the Projects in this Book</h1>

<p>With this coursebook you have also been given access to the corresponding Android Studio project, this contains the different projects that you’ll be working on throughout this course. While the code for these projects is complete within the provided source code, you’ll get the best learning experience by following the guide in the course book, using the provided source code as a reference where required.</p>

<p>The demo project contains the 12 different projects that are outlined throughout this course book. Each of these projects can be found within a corresponding module which will be clearly outlined within each chapter of this course. You will be able to select the module that you wish to run from the Android Studio Run menu, allowing you to individually launch a project.</p>

<figure><img src="Screenshot%202021-12-13%20at%2023.53.46.png"/></figure>

<hr />

<h2>Do I need to start from the first project?</h2>

<p>Well, this depends! If you haven’t built too many things with Jetpack Compose, then you’ll get the best learning experience by starting from the first project in the book. The projects are ordered by complexity in terms of the APIs that are used, the UI that is built and the state being managed - this means that if you are new to Jetpack Compose, you’ll be able to gain knowledge and experience in an iterative fashion. Starting too late in the projects will also likely result in a loss of information, which could cause some friction when trying to approach some of the later projects.</p>

<p>If you are already comfortable with compose, it might be the case that you want to build specific projects from the course to learn more about certain APIs. Each project has been documented with enough content and foundational content - so it is completely possible to start at whatever project you wish!</p>

<hr />

<h2>Should I build all of my apps like these projects?</h2>

<p>When it comes to building software, there are many different ways of approaching the different concepts that come with it (such as architecture, layering, APIs etc). The approaches used in this book are not a one-size fits-all solution, so it’s important to remember that if you are trying to transfer these approaches to your own projects. If you are looking at building onto the projects that exist in this course, then it might also be the case that the current solutions might not scale to these new requirements - which also serves as a good exercise for adjusting the current implementations.</p>

<p>Just like applying any other concept to your software projects; as a general guideline, use the current approaches in the context of the given projects, analysing the requirements of external projects before directly applying the learnings from this course.</p>

<hr />

<h2>A note on opinionated approaches</h2>

<p>This project uses a collection of approaches that, as outlined above, are not a one-size fits-all. There are some things which will help to bring benefits to the development of applications, whereas there are other things which are used because they are standard Android APIs from Google - this helps us to cater for common experiences within the Android Development community.</p>

<p>For example, the use of a <strong>Single Source of Truth</strong> and <strong>Unidirectional Data Flow</strong> are things that bring many benefits to not only the developer experience of your project, but also the user experience from the finished product. While these could still be seen as a guideline, these could be classified under recommended practices to follow when building applications with Jetpack Compose.</p>

<p>On the other hand, using the <strong>View Model</strong> component or <strong>Hilt</strong> for dependency injection are not necessarily things that need to be used when it comes to building apps with Jetpack Compose. They have been used in these projects because they are standard Android libraries (therefore a common solution that developers will either be familiar with, or commonly encounter during their development experiences). Being official Android libraries means that these also come with good Jetpack Compose support out-of-the-box, allowing us to focus on building great UI rather than trying to get tools to work well together. As mentioned above though, these are not a necessity when it comes to building apps with Jetpack Compose.</p>

<hr />

<h2>Unit Testing</h2>

<p>Throughout the projects we create a number of classes that can be unit tested, but we won’t be writing unit tests. The projects focus on the UI that is being built with Jetpack Compose - so while we’ll be writing automated tests for these composables, writing unit tests for other classes (such as ViewModels) won’t be covered so that we are able to focus on the composables that we are creating. When it comes to your own projects that are using these classes, I would highly recommend exploring unit testing here.</p>

<hr />

<h2>Previewing Composables</h2>

<p>Throughout the projects we’ll be creating composable functions, each of which can be previewed directly within android studio using the <strong>@Preview</strong> annotation. Within the content of this coursebook we won’t be including the code for writing previews - each of the chapters is already quite large, so this is to keep the level of content down a bit. If you’re looking to create previews then you can use the provided source code as a reference, or create your own preview functions using the @Preview annotation.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Preview
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Preview_EmailInbox_Success</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">EmailInbox</span>(inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
            status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">SUCCESS</span>
        ), handleEvent <span class="syntax-all syntax-keyword">=</span> { })
    }
}</code></pre>

<hr />

<h2>Versioning</h2>

<p>In the project level <code>build.gradle</code> file you’ll find two version declarations - one for Kotlin and the other for compose. These are defined here so that they can be reused across the different modules within the project. If you are adding any additional related dependencies, be sure to use these version declarations to ease the updating of any versions in future.</p>

<pre><code class="code-highlighted code-kt">ext {
    kotlin_version <span class="syntax-all syntax-keyword">=</span> &#39;<span class="syntax-all syntax-constant">1.6</span>.<span class="syntax-all syntax-constant">0</span>&#39;
    compose_version <span class="syntax-all syntax-keyword">=</span> &#39;<span class="syntax-all syntax-constant">1.1</span>.<span class="syntax-all syntax-constant">0</span><span class="syntax-all syntax-keyword">-</span>beta04&#39;
}</code></pre>

<hr />

<h2>Creating new project modules</h2>

<p>When creating the modules for each project within this course, you can use the Android Studio wizard to help you do so - using this approach will configure most of the required compose dependencies for you. You can start this flow by right clicking on the base module of the project, selecting <strong>New</strong> followed by <strong>Module</strong>.</p>

<figure><img src="Screenshot%202021-12-15%20at%2009.27.09.png"/></figure>

<p>You’ll then be presented with the <strong>New Module</strong> wizard. From here you’ll want to keep the Phone &amp; Tablet option selected (this should be selected by default already). At this point you can give the module a corresponding name, clicking <strong>Next</strong> once you are done.</p>

<figure><img src="Screenshot%202021-12-15%20at%2009.28.13.png"/></figure>

<p>On the next step of the wizard you’ll want to select the <strong>Empty Compose Activity</strong> option, as this will configure the project for use with Jetpack Compose.</p>

<figure><img src="Screenshot%202021-12-15%20at%2009.28.29.png"/></figure>

<p>Finally, the last step will give you the opportunity to name the activity being created. Before wrapping up this step you’ll want to select <strong>Launcher Activity</strong> option so that the activity composing the UI is launched by default when you run the module.</p>

<figure><img src="Screenshot%202021-12-15%20at%2009.28.47.png"/></figure>

<hr />

<h2>Any other questions?</h2>

<p>If you have any further questions on the projects from this course, please check the FAQ section on the <a href="http://practicaljetpackcompose.com/">Practical Jetpack Compose</a> website to see if they’ve already been answered. Otherwise, please feel free to reach out at contact@compose.academy</p>

<h1>Getting Started with Jetpack Compose</h1>

<p>Throughout the projects in this book we’ll be exploring the use of the approaches in more depth, but before we get started it’ll be worthwhile for us to cover some introductory concepts for Jetpack Compose at a high level. While we do also touch on introductory level topics both in this chapter and throughout the projects, it would be worthwhile checking out the <a href="https://developer.android.com/jetpack/compose/mental-model">official getting started guides</a> for Jetpack Compose if you are looking to cover these in more depth.</p>

<hr />

<h2>Building UI with Jetpack Compose</h2>

<p>Jetpack Compose is a declarative UI framework. Previously the focus for android UI components has been done via the concept of the view system - this involves us manually manipulating the different view components by traversing the tree of widgets, allowing us to manipulate the internal state that these widgets are holding. While this has been the way to build Android UI for some time, it has always presented a range of complications. Needing to manually manipulate these widgets in such a way opens up room for many errors - not only from the developers side (such as forgetting to trigger a view update from one of many places), but also invalid states being created from asynchronous tasks triggering multiple updates on the same view reference.</p>

<p>Jetpack Compose allows us to define our UI via the use of what are known as Composable Functions. These functions take data that is used to represent the UI, followed by emitting the UI elements that are declared inside within the function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MyComposable</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
	handleButtonClick<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Button</span>(
		onClick <span class="syntax-all syntax-keyword">=</span> handleButtonClick
	) {
		<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> text)
	}
}</code></pre>

<p>Using the <strong>@Composable</strong> annotation declares this function as a composable annotation, stating that it will be used for the composition of our UI. We can see here that this function does not return anything, instead the body of the function is used to emit the UI for composition. In the case of this function, the <code>Button</code> and containing <code>Text</code> composables are being emitted into our UI. Using a range of the available compose APIs, UI components can be emitted to build the screens for our applications. Composable functions can contain a range of UI components, nesting composables as required to create different pieces of UI.</p>

<figure><img src="comp.png"/></figure>

<p>When defining composables, the composition of these can be manipulated via the use of <strong>Modifiers</strong>. These modifiers are used to apply constraints and styling to the composed content - many modifiers exist (we can also create our own!), we’ll be exploring many that are available throughout the different projects.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MyComposable</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
	handleButtonClick<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
		text <span class="syntax-all syntax-keyword">=</span> text
	)
}</code></pre>

<p>To keep our composables reusable, it’s good practice to allow modifiers to be passed into a composable function - this allows the calling point to have control over the composition within the current context. For example, we may wish to apply <code>8.dp</code> padding in one scenario and <code>16.dp</code> in another. We can then chain on any additional modifiers that are applicable to be defined inside of the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MyComposable</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
	handleButtonClick<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier.clickable {
			handleButtonClick()
		},
		text <span class="syntax-all syntax-keyword">=</span> text
	)
}</code></pre>

<hr />

<h2>Recomposing UI Components</h2>

<p>In the example above we can see that there are two arguments being provided to the <code>MyComposable</code> function, both of which are being used for the composition of the contained UI. At some point within our code we are going to be calling this <code>MyComposable</code> function, which will emit the contained UI - it’s also likely at some point that this same calling point may be triggered again, but with a different value for the <code>text</code> value. When this happens, the <code>MyComposable</code> composable will be <strong>recomposed</strong> to reflect this change of data. Recomposition means that this changed piece of UI will be re-emitted to reflect this new information that the component is being composed with. This is made possible by us allowing the <code>text</code> argument to be provided to our <code>MyComposable</code> function, as we are passing data into the composable function that is being used to depict <strong>how</strong> that composable UI is being emitted. This is why it is good practice to pass state into our composable functions, allowing them to be kept reusable and dynamic for any changes to provided data.</p>

<p>When composables are composed for the first time, the initial composition will emit the UI components with the provided data. When this data changes and we reach this point of recomposition, the composable function is re-executed and the composables that have changed data will be re-emitted - this means that if there are composables that do not have changed information then they will <strong>not</strong> be executed again. The concept of recomposition is the only way to update the data being emitted for a composable, making this a very different approach to that of the Android View System.</p>

<figure><img src="comp-1.png"/></figure>

<hr />

<h2>Managing state</h2>

<p>When it comes to the state that is represented within composables, this state needs to be able to trigger the automatic recomposition as and when it occurs. For recomposition to be triggered, state needs to be stored as composable state - if we want our composables to be recomposed when any information changes, we can’t simply rely on primitive variables to manage the values that are provided to our composable functions. This is because the composable needs to be explicitly told that it needs to be recomposed. For examples sake, let’s look at a composable that uses a variable for its composition - with this variable being updated when a <code>Button</code> is clicked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MyComposable</span>() {
	<span class="syntax-all syntax-keyword">var</span> myTextValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Jetpack&quot;</span>
	<span class="syntax-all syntax-entity">Column</span> {
    	<span class="syntax-all syntax-entity">Text</span>(
        	text <span class="syntax-all syntax-keyword">=</span> myTextValue
    	)
      	<span class="syntax-all syntax-entity">Button</span>(
           	onClick <span class="syntax-all syntax-keyword">=</span> {
				myTextValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Compose&quot;</span>
			}
       	) {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Click me!&quot;</span>)
		}
   }
}</code></pre>

<p>While the initial composition will compose the value that we have assigned to the <code>myTextValue</code> variable, when this value is updated we will not see any recomposition occur - this is because we are not using composable state.</p>

<p>To be able to define state that will trigger recompositions, we need to utilise the expected <code>State&lt;T&gt;</code> type. While we can convert specific data streams to composable state (such livedata, flow, rxjava2), we can also build our own composable state to hold references to the various types of data that we want to manipulate. This can be done using <code>MutableState&lt;T&gt;</code> - this allows us to define a piece of composable state that can be observed by composables, triggering recompositions whenever the value of this state changes. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">var</span> myTextValue <span class="syntax-all syntax-keyword">=</span> mutableStateOf(<span class="syntax-all syntax-string">&quot;Jetpack&quot;</span>)</code></pre>

<p>While this defines a piece of composable state, we also need this to be stored into memory so that the values within these state objects are remembered across recompositions. To solve this we can utilise the <code>remember</code> composable, this wraps the content that we want to be stored during recompositions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">var</span> myTextValue by remember { mutableStateOf(<span class="syntax-all syntax-string">&quot;Jetpack&quot;</span>) }</code></pre>

<p>With this in place we can now slot this into our composable function, allowing our composable to trigger recompositions when its internal state changes.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MyComposable</span>() {
	<span class="syntax-all syntax-keyword">var</span> myTextValue by remember { mutableStateOf(<span class="syntax-all syntax-string">&quot;Jetpack&quot;</span>) }
	<span class="syntax-all syntax-entity">Column</span> {
    	<span class="syntax-all syntax-entity">Text</span>(
        	text <span class="syntax-all syntax-keyword">=</span> myTextValue
    	)
      	<span class="syntax-all syntax-entity">Button</span>(
           	onClick <span class="syntax-all syntax-keyword">=</span> {
				myTextValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Compose&quot;</span>
			}
       	) {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Click me!&quot;</span>)
		}
   }
}</code></pre>

<p>What we’ve created here is a <strong>stateful</strong> composable - meaning that it holds state internally. While this is fine to do in applicable cases, it is also appropriate to create <strong>stateless</strong> composables - this is when state is passed into the composable function as opposed to the composable function holding any internal state. This approach allows us to create composables that are not only more reusable, but also lean into a <strong>Single Source of Truth</strong> (which we’ll come onto in the next section of this chapter).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MyComposable</span>(<span class="syntax-all syntax-parameter">myTextValue</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) {
	<span class="syntax-all syntax-entity">Column</span> {
    	<span class="syntax-all syntax-entity">Text</span>(
        	text <span class="syntax-all syntax-keyword">=</span> myTextValue
    	)
      	<span class="syntax-all syntax-entity">Button</span>(
           	onClick <span class="syntax-all syntax-keyword">=</span> {
				...
			}
       	) {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Click me!&quot;</span>)
		}
   }
}</code></pre>

<p>As well as state, composable functions may also need to handle some kind of event - in the example above we can see that we now have nothing handling the <code>onClick</code> lambda of the <code>Button</code> composable. In this situation, as well as passing state into our composable we’re going to want to pass a lambda function that allows us to pass up events outside of our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MyComposable</span>(
	<span class="syntax-all syntax-parameter">myTextValue</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">handleClick</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Column</span> {
    	<span class="syntax-all syntax-entity">Text</span>(
        	text <span class="syntax-all syntax-keyword">=</span> myTextValue
    	)
      	<span class="syntax-all syntax-entity">Button</span>(
           	onClick <span class="syntax-all syntax-keyword">=</span> {
				handleClick()
			}
       	) {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Click me!&quot;</span>)
		}
   }
}</code></pre>

<p>Here, the <code>handleClick</code> lambda will be triggered which will be handled outside of our composable function. In this case it’s likely that the implementation of that lambda will be used to update the state for the <code>myTextValue</code> reference, which would then trigger the recomposition of our <code>MyComposable</code> composable. This is also known as <strong>State Hoisting</strong>, which allows us to move the state management to the caller of the composable function, as opposed to within the composable itself - keeping our composable <strong>stateless</strong>.</p>

<hr />

<h1>Application State</h1>

<p>Throughout the different projects in this course we’re going to be working with what is known as State. Because this is a central topic to the development of these projects, it’s important that we understand exactly what state is.</p>

<hr />

<h2>What is State?</h2>

<p>State is a key concept when it comes to building applications. While this is not something that is specific to Jetpack Compose, it’s going to be the concept that drives how our UI is presented to the user. But what exactly is state? The term itself is a pretty broad concept, but we can see this as any value that can be manipulated within the lifecycle of the app. The value of this state will then be used to render the content within each of the UI components for our app.</p>

<figure><img src="state.png"/></figure>

<p>So for example, we could have various pieces of state that represent the content for the different UI components within a screen. These could be details such as:</p>

<ul>
	<li>The email address that has been input into a text field</li>
	<li>Whether or not a button is currently enabled</li>
	<li>The list of emails being displayed within an email inbox</li>
	<li>The on/off status of a switch component</li>
</ul>

<p>From these small examples, we can start to see how the different pieces of state can be used to manipulate the content of the UI components. When it comes to Jetpack Compose, this state is used for the composition of our UI - so as state changes, our UI will be recomposed to reflect the change of data.</p>

<p>In a lot of cases, you’re likely to have multiple pieces of information that represent the state of a screen. With that in mind, it’s important for us to think about how we can model this to allow our screens to be rendered from a source that represents this current state.</p>

<hr />

<h2>Single Source of Truth</h2>

<p>When manipulating a User Interface via state, this state could be represented in a number of ways. For example, let’s say we have several different UI components in our screen, each of which needs an individual piece of state to reflect its representation within our screen. When it comes to these different pieces of state, let’s imagine that we had each of these as individual fields within a controller class (such as a ViewModel) - where each of these fields are being individually read/written by the UI.</p>

<figure><img src="state_1.png"/></figure>

<p>With this arrangement we have multiple sources for our state - this means that we have state manipulations occurring in multiple places, rather than in an isolated location. The same also holds true for state reads, meaning that the both reading and writing is being carried out for multiple sources - even if these sources come from the same place, our screen is still going to be rendered from multiple streams of state. Alongside this, we can also never fully guarantee that our state is always going to be in sync. Because our UI is being rendered from multiple pieces of state, out-of-sync asynchronous tasks could easily result in results that aren’t quite lined up. I terms of maintenance, it can also become difficult to maintain this kind of arrangement as we have no guarantee as to where our state is being both read and written from.</p>

<p>To resolve this issue we can shift towards what is known as a <strong>Single Source of Truth</strong> - this where our state comes from a single place, allowing us to ensure that the state we are rendering our UI for is</p>

<figure><img src="state_2.png"/></figure>

<p>With this model we can already see the greater level of organisation that our state has. First up, our UI is no longer subscribing to multiple streams of data - there is a single state representation for our screen, meaning that the composition of our UI is happening from a single model as opposed to multiple pieces of individual data. When it comes to the writing of data, we also now know that this is all also happening at a single point - while multiple points in our UI can trigger operations in our controller (ViewModel), we are manipulating a single state representation as opposed to multiple streams.</p>

<hr />

<h2>Unidirectional Data Flow</h2>

<p>At this point we’ve touched on what state is and how it is used to manipulate the UI components of our application. We also mentioned how state can be manipulated so that our UI components can be recomposed to reflect these changes.</p>

<p>Often in applications we see a clear line of responsibility for the classes that exist within the flow of data. However, we often see there are many sources that are reading and writing data - for example, both the UI and controller (ViewModel) could be directly reading and writing application state. The issue with this is that the state of our application becomes far less predictable - as we have no guarantee where the recomposition was triggered from. This can not only result in unpredictable states for our users, but also make it hard for us to debug parts of our app.</p>

<figure><img src="readd.png"/></figure>

<p>To alleviate these concerns, we can lean into what is known as <strong>unidirectional data flow</strong>. This allows us to define a clear flow of operations between the UI and our state - we can see in the following diagram that data only flows in a single direction.</p>

<figure><img src="state-1.png"/></figure>

<p>With unidirectional data flow, we not only know that all of the updates to our UI are coming from the same place (from the state), but also that our state is also being updated from a single place (the ViewModel). With this unidirectional flow of data we are able to enforce some predictability for the representation of our state, along with creating a form of state management that is easier for developers to maintain.</p>

<hr />

<p>Throughout the projects in this book we’ll be utilising the approaches that have been outline above. When it comes to working with <strong>State</strong>, we’ll be encapsulating this inside of a <strong>Single Source of Truth</strong>, managing this state via the use of <strong>Unidirectional Data Flow</strong>.</p>

<h1>Building a Settings Screen</h1>

<p>In a lot of applications, there will be some aspects that will be configurable via a setting. For these cases, we often want to allow users to configure these various settings from within the application itself. A common approach to this is providing a settings screen that displays the available settings to the user, along with allowing a way to interact with or toggle the assigned value for a specific setting.</p>

<figure><img src="DraggedImage.png"/></figure>

<p>In this chapter, we’re going to walk through an approach to building out a settings screen with Jetpack Compose. We’ll be creating the above settings screen, which covers a variety of setting options that you might be displayed inside of an application.</p>

<p>In this screen we’ll need to handle four different settings items:</p>

<ul>
	<li>A setting that can be disabled / enabled using a <strong>Switch</strong></li>
	<li>A setting that can be turned on and off using a <strong>Checkbox</strong></li>
	<li>A setting that allows for one of the multiple choices to be selected, in the form of <strong>Radio Buttons</strong></li>
	<li>A setting item that can act as a link to a separate settings screen</li>
	<li>A setting that can be used to trigger another kind of action (such as opening an external link)</li>
</ul>

<p>With these, we’ll cover most of the kinds of settings that are displayed inside of applications. This also gives us a chance to explore how we can represent the state of our settings as composable state, as well as recompose our UI whenever any of the settings values changes. With that, let’s get started with building this settings screen!</p>

<h1>Defining the Settings State</h1>

<p>Within our settings screen, we’re going to be dealing with a few different pieces of state that depict how the UI is going to be displayed to the user. This state will be used to compose our UI, allowing us to control how our composables look and behave. While we’re showing a collection of settings in our screen, not all of them are dynamic - for example, some are static items that trigger some event when clicked. These static items will not need to be reflected in our state, as they will never need to be recomposed to reflect any state changes. However, there are some items in our settings that will need to be recomposed when the corresponding piece of state <strong>has</strong> changed.</p>

<ul>
	<li><strong> Toggle Notifications</strong>: This setting shows the enabled state in the form of a switch. The state for this switch will be toggled between on/off when the user interacts with it.</li>
	<li><strong> Show Hints</strong>: This setting is similar to Toggle Notifications, except that the enabled state is represented in the form of a checkbox. This component will be toggled when the user interacts with it, managed by the state within our ViewModel.</li>
	<li><strong>Receive Marketing Emails</strong>: This setting allows the user to select an option from a radio group. The currently selected radio group will be a part of the state in our ViewModel, which will be updated when the user selects an option from the group</li>
	<li><strong>App Theme</strong>: This setting allows the user to select the current theme that should be used for the app. Again, because this setting can be changed, we’ll need to keep a reference to it within our state</li>
</ul>

<p>With the above set out, we can start to see that there are going to be several pieces of state that we need to hold. Let’s start to take the above statements and build a class that will represent the state of our composable UI. We’ll start by creating a new class that will represent the state for our settings screen:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SettingsState.kt
</span><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsState</span>()</code></pre>

<hr />

<h2>Modelling the Notifications setting</h2>

<p>To start us off, let’s begin by taking a look at the <strong>Toggle Notifications</strong> setting. Because this is going to be represented by a <code>Switch</code>, the setting is going to be one of two values - <strong>on</strong> or <strong>off</strong>. This binary representation means that we can define this setting in the form of a boolean value - which we’ll do in the form of <code>notificationsEnabled</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">notificationsEnabled</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
)</code></pre>

<p>When <code>notificationsEnabled</code> is set as <strong>true</strong>, this will mean that the settings switch is <strong>ON</strong> and the notifications for our app are enabled. When the <code>Switch</code> is interacted with, we will update our <code>notificationsEnabled</code> value to represent <strong>false</strong> and the Switch will be recomposed to be marked as <strong>OFF</strong>.</p>

<hr />

<h2>Modelling the Hints setting</h2>

<p>Moving onto the next settings item, <strong>Show Hints</strong> is also represented in a binary fashion - meaning that this setting is going to be handled in the same way as our notifications setting. We can now add a second value to our state object, a boolean in the form of a <code>hintsEnabled</code> variable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">notificationsEnabled</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">hintsEnabled</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
)</code></pre>

<hr />

<h2>Modelling the Marketing setting</h2>

<p>The next settings item, <strong>Receive Marketing Emails</strong>, allows the user to select an option for their email marketing settings. While we’re going to initially be displaying two options on-screen, a boolean flag doesn’t feel quite right for this setting item - as we’re not working with a single toggleable component. So that we can have a typed representation of our marketing setting, we’re going to create a new enum class that will be used to represent each of the possible options:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MarketingOption.kt
</span><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MarketingOption</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>) {
    <span class="syntax-all syntax-entity">ALLOWED</span>(<span class="syntax-all syntax-constant">0</span>), <span class="syntax-all syntax-entity">NOT_ALLOWED</span>(<span class="syntax-all syntax-constant">1</span>)
}</code></pre>

<p>Here we also assign an <code>id</code> value to each of our settings, that way we can use this within our UI to determine the currently selected item based on the position within our <code>RadioGroup</code>.</p>

<p>💡 Using an Enum class in this way allows us to have a strongly-typed representation of our MarketingOption values. This is not only safer for development, but it also makes it easier for developers to understand the represented value.</p>

<p>With this enum defined we can now add this to our <code>SettingsState</code> in the form of a <code>MarketingOption</code>. We’ll provide a default value here of <code>MarketingOption.ALLOWED</code>, which will be used as the initial state of this setting.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">notificationsEnabled</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">hintsEnabled</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">marketingOption</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MarketingOption</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>
)</code></pre>

<hr />

<h2>Modelling the Theme setting</h2>

<p>For the final dynamic settings item on our screen, we have the <strong>App Theme</strong>, which can be managed by the user. Similar to the marketing option setting, this is something that can’t be handled by a boolean representation. We’re going to do a similar thing for this setting item and create a new enum class that will be used to represent the different theme options that are available for our app:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Theme.kt
</span><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Theme</span> {
    <span class="syntax-all syntax-entity">LIGHT</span>,
    <span class="syntax-all syntax-entity">DARK</span>, 
    <span class="syntax-all syntax-entity">SYSTEM</span>
}</code></pre>

<p>At this point, we have the representation of our theme in the form of an enum, which can be used within our settings UI to determine the options available to the user. However, these Enum values are not in the form of user-friendly (or translatable) labels. So that we have some user-friendly values to display within our UI we’re going to need to start by adding some strings to our module resources:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;theme_light&quot;</span>&gt;Light&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;theme_dark&quot;</span>&gt;Dark&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;theme_system&quot;</span>&gt;System&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>💡 While these strings could be hardcoded inside of the enum, string resources allow for localisation of text as well as keeping things nice and tidy!</p>

<p>We can then go ahead and modify our <strong>Theme</strong> enum so that each theme requires a label to be provided for it:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Theme</span>(<span class="syntax-all syntax-keyword">@StringRes</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>)</code></pre>

<p>Then, by using the string resources that we previously defined, we can state each of the theme labels that are to be used for the Theme types that we have defined:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Theme</span>(<span class="syntax-all syntax-keyword">@StringRes</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>) {
    <span class="syntax-all syntax-entity">LIGHT</span>(<span class="syntax-all syntax-entity">R</span>.string.theme_light), 
    <span class="syntax-all syntax-entity">DARK</span>(<span class="syntax-all syntax-entity">R</span>.string.theme_dark), 
    <span class="syntax-all syntax-entity">SYSTEM</span>(<span class="syntax-all syntax-entity">R</span>.string.theme_system)
}</code></pre>

<p>Now when we reference the <strong>Theme</strong> to be selected by the user, we also have access to a user-friendly label that can be displayed within the UI. With this defined we can go ahead and plug this last piece of the state into our <code>SettingsState</code> class. We’ll provide a default value here of <code>SYSTEM</code>, which will be overridden when the user selects a value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">notificationsEnabled</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">hintsEnabled</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">marketingSettingsOption</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">themeOption</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Theme</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Theme</span>.<span class="syntax-all syntax-entity">SYSTEM</span>
)</code></pre>

<hr />

<p>With all of the above in place, we now have a state reference for our Settings UI. This state class will also act as a single source of truth for our UI - this is because all of these values are stored within the same class, and they will always be provided as a single group to the UI. </p>

<p>We’ve only included some of the settings for our screen in this state reference because not all of our settings are dynamic. Because the other settings values display static content and do not change in any way (e.g from user interaction), we don’t need to keep a reference to them within our <code>SettingsState</code>. Those static settings will be composed with the defined content in the composable function, never being recomposed with a change of content.</p>

<p>For the other settings (the ones that we’ve defined within our state class), these are dynamic settings that change with user interaction. This is because these are settings that the user can modify to change the behaviour of the app. In a real-world scenario, these would be provided by some form of cache (such as preferences or data store), but when propagated to the UI layer they would still need to be declared in a state object to be used by our UI - so the only difference here is that we’re not basing our state off of persisted data.</p>

<p>At this point, we’re all set to start thinking about the ViewModel class that will be used to orchestrate this data to our UI.</p>

<h1>Creating the Settings ViewModel</h1>

<p>Now that we’ve defined the contracts for supported settings in our application, we need to tackle the next step for settings - persisting and observing the settings values. Now, in real-world cases we would use Android Preferences, Data Store or a Database - but for our settings screen, we’re going to persist the settings values within a view model. This is so that we can focus more on building the composable UI for our screen instead of the persistence of data which is very unrelated to Jetpack Compose! For this, we’re going to use a ViewModel with a data stream to hold our settings, which can then be observed to compose our UI. So before we can get started here, we’re going to add a new dependency to our project that will give us access to the Android Lifecycle ViewModel class:</p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span></code></pre>

<p>💡 You aren’t required to use a ViewModel when working with compose. For the sake of these exercises, it helps us to keep things simple and follow an approach that many developers are familiar with.</p>

<p>We’ll begin by creating a new ViewModel, called <code>SettingsViewModel</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SettingsViewModel.kt
</span><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>()</code></pre>

<p>This <code>ViewModel</code> is going to need to hold a reference to the state of our screen. For this we’re going to utilise <code>StateFlow</code> - this allows us to create a state-holder observable flow that will emit the default state we provide to it, along with any updates that occur during its lifetime. Here we’ll create a new <code>MutableStateFlow</code> instance, providing a reference to our <code>SettingsState</code> class as the default value for our <code>StateFlow</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {
    <span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">SettingsState</span>())
}</code></pre>

<p>With our state in place, we now want to provide some functions which can be called by external classes in-order to update our state. These are going to be quite small and simple functions that will update the value for the corresponding setting. </p>

<h3>Setting the Notifications setting</h3>

<p>We’ll start by creating the function to toggle the <strong>Notification Enabled</strong> settings:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">toggleNotificationSettings</span>() { }</code></pre>

<p>For this setting, we are toggling the status between on and off (true and false), and because a switch simply toggles between these two states we’re going to want to take the existing value within our state and flip it to the opposite. Once we have this value, we’re going to use the copy() function on our state reference and replace the existing value for <code>notificationsEnabled</code> using the opposite of the value that is currently present.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">toggleNotificationSettings</span>() {
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(notificationsEnabled <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>uiState.value.notificationsEnabled)
}</code></pre>

<p>💡 The copy function in Kotlin copies the existing class reference, replacing any values that have been provided as arguments to the function.</p>

<p>We update the value of our <code>StateFlow</code> by setting its value property to the <code>SettingsState</code> reference that we’ve copied and updated. This means that when our <code>toggleNotificationSettings</code> is called, our state will be updated with the <code>notificationsEnabled</code> flag toggled, followed by this updated state being emitted through our <code>StateFlow</code> reference.</p>

<h3>Setting the Hints setting</h3>

<p>Moving onto the next setting that we need to be able to change, the <strong>Show Hints </strong>setting has exactly the same behaviour as <strong>Notification Enabled</strong>. We’ll create a new toggle function for our hints setting and implement the same logic as the previous function, except this time updating the <code>hintsEnabled</code> value:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">toggleHintSettings</span>() {
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(hintsEnabled <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>uiState.value.hintsEnabled)
}</code></pre>

<p>Similar to before, now when we call the <code>toggleHintSettings</code>, our state will be updated to reflect the change of the <code>hintsEnabled</code> value and then this state will be emitted through our <code>StateFlow</code> reference.</p>

<h3>Setting the Marketing Option setting</h3>

<p>For our next function, we’re going to implement the ability to set the value for the <strong>Marketing Options</strong> setting. We previously defined a <code>MarketingOption</code> enum, which our <code>SettingsState</code> class uses to keep a reference to the currently selected option. To be able to update this state, we’re going to need to create a new function that allows for a <code>MarketingOption</code> reference to be provided to it:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">setMarketingSettings</span>(<span class="syntax-all syntax-parameter">option</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MarketingOption</span>) { 

}</code></pre>

<p>This function will be called from the external class, providing the option that has been selected in the UI so that the state can be updated. Inside of this function, we’re going again to utilise the copy function on our state reference, providing an override for the <code>marketingOption</code> value in the form of the <code>option</code> argument that has been provided to our function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">setMarketingSettings</span>(<span class="syntax-all syntax-parameter">option</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MarketingOption</span>) {
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		marketingOption <span class="syntax-all syntax-keyword">=</span> option)
}</code></pre>

<p>Once updated, our new state reference will be emitted and our UI can be recomposed to reflect the newly selected <code>MarketingOption</code>.</p>

<hr />

<h3>Setting the selected Theme setting</h3>

<p>While the <strong>App Theme</strong> setting is a slightly different UI component, the approach to updating the setting is going to be the same as what we just implemented for the <strong>Marketing Options</strong> setting. We need to create a new function that takes the <code>Theme</code> instance that we wish to be reflected in our state, and then use this to override the current <code>themeOption</code> value in our state object.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">setTheme</span>(<span class="syntax-all syntax-parameter">theme</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Theme</span>) {
	uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(themeOption <span class="syntax-all syntax-keyword">=</span> theme)
}</code></pre>

<p>When emitted, our UI can be recomposed to reflect this change of state for the selected App Theme.</p>

<hr />

<p>In this small amount of work, we’ve created a new ViewModel that is holding a reference for the state of our UI, in the form of the <code>SettingsState</code> class. Whenever this state reference is updated, it is emitted from our <code>StateFlow</code> instance so that many observers can be aware of updates that need to be reflected within our UI. So that we can see this in action, let’s move on and start building out the composes to represent the UI for our settings screen.</p>

<h1>Creating the Settings UI</h1>

<p>Now that we have all of the required logic in place to read and write the settings values for our application, we can move onto the main part of this sample project - displaying the UI for our settings using Jetpack Compose! Before we get started here we’re going to need to go ahead and add a couple of dependencies to our project.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// provides access to the `ComponentActivity` class that can be used to compose UI components
</span>implementation &#39;androidx.activity<span class="syntax-all syntax-keyword">:</span>activity<span class="syntax-all syntax-keyword">-</span>compose<span class="syntax-all syntax-keyword">:</span><span class="syntax-all syntax-constant">1.4</span>.<span class="syntax-all syntax-constant">0</span>&#39;

<span class="syntax-all syntax-comment">// provide functionality for accessing viewmodels within composable functions
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span>

<span class="syntax-all syntax-comment">// foundational classes from the Compose APIs
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.foundation:foundation:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// UI components from the Compose APIs
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Material Design components from the Compose APIs
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Tooling functionality for Composables, such as previews
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-tooling-preview:$compose_version&quot;</span>
debugImplementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-tooling:$compose_version&quot;</span></code></pre>

<p>With these dependencies in place we’re going to begin by building a root composable function, <code>Settings</code>, which will be used to house all of our Composable UI for the Settings screen. For this, we’ll create a new Kotlin file called <code>Settings.kt</code> (to keep our composables nicely organised), followed by creating a new composable function, <code>Settings</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Settings.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Settings</span>() {

}</code></pre>

<p>This composable is going to be the entry point to our Settings feature - so we don’t want this function to have to take any arguments. The point of composition will be able to simply compose this function, and this composable itself will handle everything else such as the ViewModel and state. While you won’t see anything visual just yet, you’ll want to compose this <code>Settings</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Settings</code> when running the project.</p>

<p>Within this root level composable, for any composition that takes place we’re going to want to apply our application theming, so we’ll add a <code>MaterialTheme</code> composable declaration here.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Settings</span>() {
	<span class="syntax-all syntax-entity">MaterialTheme</span> {

	}
}</code></pre>

<p>💡Wrapping your composable hierarchy in a theme allows all components to be consistently styled. In most cases, this can happen at the highest point of composition - even within the setContent function of the parent activity that is composing the UI.</p>

<p>When it comes to the composition of our settings UI, we’re going to need access to the state that we previously configured within our ViewModel. So that we can access this information, we’re going to need to obtain an instance to this ViewModel inside of our composable. Here we’ll use the <code>viewModel</code> function from the <code>lifecycle-viewmodel-compose</code> package. This will retrieve an instance of the desired ViewModel, creating one if it does not currently exist. We’ll define this desired type to be <code>SettingsViewModel</code>, which will give us access to this ViewModel from within our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Settings</span>() {
	<span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">SettingsViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()

	<span class="syntax-all syntax-entity">MaterialTheme</span> {

	}
}</code></pre>

<p>We’re then going to need to access this state within the composition of our UI, so we’re going to want to access the <code>uiState</code> property that we’ve defined within our ViewModel. With access to this state, we’ll use <code>collectAsState()</code> to collect the emissions of our <code>StateFlow</code> reference from our ViewModel as composable state. This means that whenever any of the values within the state reference are changed, these events will be emitted to this observation, which will trigger the recomposition of our UI once things are plugged in.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Settings</span>() {
	<span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">SettingsViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()

	<span class="syntax-all syntax-entity">MaterialTheme</span> {
		<span class="syntax-all syntax-keyword">val</span> state <span class="syntax-all syntax-keyword">=</span> viewModel.uiState.collectAsState().value
	}
}</code></pre>

<p>When it comes to this state, this is configured to be a <strong>Single Source of Truth</strong> - this allows us to ensure that our UI is always configured from the same source of data, increasing the predictability of the represented state within our UI. In the context of our settings screen, our state is represented by a list of Setting references. This state will need to be passed into a composable function so that the UI can be composed from it. For this, we’ll start by defining a new Composable function called <code>SettingsList</code> that will take a state reference in the form of our Settings state. When defining this function, we’ll allow a <code>Modifier</code> to be passed as an optional argument - this allows the parent composable to have some control over the composition of its child.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SettingsList</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">SettingsState</span>
)</code></pre>

<p>💡 It’s good practice to allow a modifier to be passed into a composable, this means that the parent who is composing the child can control the composition to some extent. This also helps to keep your composable functions re-usable across your UI.</p>

<p>In this function, we now need to think about composing the different components that make up the Settings UI that we saw at the start of this chapter. To get a better understanding of the work involved here, we’re going to need to break that down into a Composable representation.</p>

<figure><img src="intro.png"/></figure>

<p>From this structure, we can see that our composable hierarchy consists of:</p>

<ul>
	<li>A parent column to vertically display all of the child components</li>
	<li>A Top App Bar to represent the app bar of the screen</li>
	<li>Individual Row composables that represent each of the setting items</li>
	<li>A collection of Divider and Spacer composables to create some separation between setting items</li>
</ul>

<p>With the above in mind we can start building out our Composable UI to represent our settings screen. We’re going to build a collection of composable functions, all of which can be plugged together to create our entire screen.</p>

<hr />

<h2>Composing the Scrollable Settings Container</h2>

<figure><img src="col.png"/></figure>

<p>We’ll begin at the foundations of our composable, being the parent <code>Column</code> that will hold the entire settings UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SettingsList.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SettingsList</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">SettingsState</span>
)</code></pre>

<p>We’ll define a new reference to a <code>Column</code> composable here, as a <code>Column</code> is used to stack children composables in a vertical format. We can see from the diagram above that this is how the child composables are organized within the parent container.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SettingsList</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">SettingsState</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

	}
}</code></pre>

<p>💡 When passing in a Modifier via the composable function, this should always be applied at the highest point within our composable (such as the parent within that child).</p>

<p>Now that we have the <code>Column</code> in place, we’re going to make a small tweak to better support the different screens that our app might be used on. In our example, we only show several settings items on screen - we’ll likely either want to launch with more configurable settings options for the user or support more settings items over time. As this list might grow a bit, likely, smaller screens might not get the best experience when it comes to our settings, with it even being the case that some items might not be accessible and appear off-screen. With this in mind, we’re going to enable scrolling on our <code>Column</code> using the vertical scroll modifier. This modifier requires us to pass a reference to a <code>ScrollState</code> - this state class is used to configure and manage the state of the scrolling for our composable. We can utilise the <code>rememberScrollState</code> function to create <strong>and</strong> remember this for us, allowing the scroll state to be persisted across recompositions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SettingsList.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SettingsList</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">SettingsState</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
  		modifier <span class="syntax-all syntax-keyword">=</span> modifier.verticalScroll(
      		rememberScrollState()
  		)
	) {

	}
}</code></pre>

<p>💡 There are many remember functions in the jetpack compose APIs. These are all used to create and remember the desired class, allowing you to avoid redefining this logic every time you are looking to implement such behaviour in your project.</p>

<p>Now, if our settings list is too large vertically for some screens, scrolling will be enabled so that the list is accessible to all of our users.</p>

<hr />

<h2>Composing the Top App Bar</h2>

<figure><img src="TopAppBar.png"/></figure>

<p>With the parent container composable in place, we can start to think about adding children to be composed inside of it. We’ll start here by composing an app bar at the top of our column, which will be used to create a header for our screen and display a title to the user. We’ll declare this as the first child within the content of the column composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SettingsList.kt
</span><span class="syntax-all syntax-entity">Column</span>(
  modifier <span class="syntax-all syntax-keyword">=</span> modifier.verticalScroll(
      rememberScrollState()
  )
) {
  <span class="syntax-all syntax-entity">TopAppBar</span> {
  
  }
}</code></pre>

<p>💡 The TopAppBar is a material component that allows you to display information and actions within the context of the current screen.</p>

<p>At this point, the <code>TopAppBar</code> will be displayed as an empty area in our screen - that’s because we haven’t added any content to the composable. Here we’re going to want to add an Up icon (that allows the user to go up to the previous screen), along with a title that signifies the current screen that the user is on. We’re going to provide these using the <code>content</code> argument of the <code>TopAppBar</code>. Internally, the <code>content</code> argument houses any content that we provide to it inside of a <code>Row</code> composable, so these will automatically be laid out next to each other on the horizontal axis.</p>

<h3>Composing the navigation icon</h3>

<p>We’ll start here by declaring an <code>Icon</code> composable to display the Up icon at the start of our <code>TopAppBar</code></p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TopAppBar</span> {
	<span class="syntax-all syntax-entity">Icon</span>()
}</code></pre>

<p>This won’t compile as it is, because we’re missing two required arguments of the <code>Icon</code> composable. These are the image to be displayed, along with the content description that describes that image. We’ll go ahead and start by utilising the <code>imageVector</code> argument, passing one of the provided Icons from the compose packages, <code>Icons.Default.ArrowBack</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>
)</code></pre>

<p>We also need to add a content description for this icon, so that the composable is accessible to those utilising talkback. We’ll start by adding new string resources to the <code>strings.xml</code> file within our application <code>res</code> directory. This resource will describe what the icon is used for, which in this case it will be describing that the icon is used to go back to the previous screen:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_go_back&quot;</span>&gt;
	Go back to previous screen
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With this resource in place, we can go ahead and provide the string to the <code>contentDescription</code> argument of the <code>Icon</code> composable. To provide this as a string we need to use the <code>stringResource</code> composable function, which takes the ID of the resource that we just defined and retrieves the string value for it. The result of this operation will then be used as the content description for our icon.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_go_back)
)</code></pre>

<p>💡 Providing a content description for supporting composables helps to ensure that these remain accessible for all users of our app. This description will be used by the screenreader to communicate the meaning of the visual element that is being composed.</p>

<p>With this in place we now have a <code>TopAppBar</code> that is displaying our Up icon:</p>

<figure><img src="1.png"/></figure>

<h3>Composing the Title</h3>

<p>So that it’s clear what screen the user is currently on, we’re going to add a title to our <code>TopAppBar</code>. This is again done by adding a composable to the content area of the <code>TopAppBar</code>, which we’ll do in the form of a <code>Text</code> composable. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">Icon</span>(
		imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
		contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_go_back)
    )
    <span class="syntax-all syntax-entity">Text</span>(
        text <span class="syntax-all syntax-keyword">=</span> ...
   	)
}</code></pre>

<p>💡 The ordering of composition within a container depicts how those children will be composed. In the case of this <code>Row</code>, the <code>Icon</code> will be composed first, followed by the <code>Text</code> to the end of it.</p>

<p>To satisfy the requirements of the <code>Text</code> composable, we’ll need to add another string to our application resources. We’ll head on back over to the <code>strings.xml</code> file within the module for this project and add the following string declaration:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;title_settings&quot;</span>&gt;Settings&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With this in place we can then again use the <code>stringResource</code> composable function to assign a string reference to our <code>Text</code> composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">Icon</span>(
		imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
		contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_go_back)
    )
    <span class="syntax-all syntax-entity">Text</span>(
        text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.title_settings)
   	)
}</code></pre>

<p>At this point, we can now see our Up icon and Settings title at the top of our UI.</p>

<figure><img src="2.png"/></figure>

<h3>Adjusting the size of the Title</h3>

<p>As we can see, the title is a little small within the app bar. We’re going to adjust the size of this title by overriding the <code>fontSize</code> that is being used for the <code>Text</code> composable. Here we’ll pass in a value of <code>18sp</code>, which will give our title a more prominent place in the app bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_go_back)
)
<span class="syntax-all syntax-entity">Text</span>(
	text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.title_settings),
	fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
)</code></pre>

<p>💡 The sp dimension are scalable pixels. It’s important to use sp for any values that are related to font sizes, as this ensures that text is scaled based on the density of the device and the preferences the user has set for font size.</p>

<p>With this in place, we can see that the title of our Settings screen is now much more presentable when being composed:</p>

<figure><img src="3.png"/></figure>

<h3>Creating some visual space between composables</h3>

<p>To make another tweak here, we’ll go ahead and utilise the <code>Spacer</code> composable to create some visible space between the two components. The <code>Spacer</code> can be seen as a blank composable area, whose size we can define via the use of modifiers. In this case, we are only creating space on the horizontal axis, so we’ll go ahead and use the <code>width</code> modifier to create horizontal space between the <code>Icon</code> and <code>Text</code> composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_go_back)
)
<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">16</span>.dp))
<span class="syntax-all syntax-entity">Text</span>(
	text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.title_settings),
	fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
)</code></pre>

<p>With that in place, our <code>Icon</code> and <code>Text</code> composables now have a good amount of visual spacing between one another.</p>

<figure><img src="4.png"/></figure>

<h3>Styling the Top App Bar</h3>

<p>By default, the <code>TopAppBar</code> is currently using the <code>primarySurface</code> color from the theme of our application. While a lot of applications use this to create a bold app bar at the top of the screen, we’re going to modify the theming of our <code>TopAppBar</code> by overriding some of the colors that are used for it. Here we’re going to override the background color of our <code>TopAppbar</code>via the use of the <code>backgroundColor</code> attribute. We’ll again use the <code>MaterialTheme</code> class here to use a color from our theme, this time in the form of the surface.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TopAppBar</span>(
	backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface
)</code></pre>

<p>💡 It is possible to use direct Color references when overriding color values, such as <code>Color.White</code>. However, using Theme references helps to ensure that your theming is compatible with light + dark modes, as well as making it easier to maintain theming in your application.</p>

<figure><img src="5.png"/></figure>

<h3>Applying content padding to the app bar</h3>

<p>While we’re here, we’re also going to apply some padding to the start of our <code>TopAppBar</code>. Currently, the Up icon is pressed right against the edge of the container, so we can utilise the <code>contentPadding</code> argument to provide padding values to be applied to the content area.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TopAppBar</span>(
	backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
	contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp)
)</code></pre>

<p>💡 Under the hood, the PaddingValues class applies padding in the same way that you would do using the Padding modifier.</p>

<p>Now our <code>TopAppBar</code> has some additional spacing for the content, as well as appearing quite different visually:</p>

<figure><img src="6.png"/></figure>

<h3>Styling the app bar content</h3>

<p>Now that we’ve changed the styling of the <code>TopAppBar</code>, we can see that the content is no longer completely visible. This is because the content of the top app bar is themed for the default background color of the <code>TopAppBar</code>. To fix this, we’ll need to override the color of the content inside of the <code>TopAppBar</code>. This can be done by overriding each of the foreground colors in the child composables. We’ll start by applying a color to the <code>Text</code> composable, which we can use the <code>onSurface</code> color for:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Text</span>(
	text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.title_settings),
	color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface,
    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
)</code></pre>

<p>Next, we’ll need to do the same thing for our <code>Icon</code> composable, this will be done in the form of the <code>tint</code> argument - again passing the <code>onSurface</code> color from our application theme.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	tint <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface,
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_go_back)
)</code></pre>

<p>With this in place we now have a completed <code>TopAppBar</code> composable that should look something like the following:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TopAppBar</span>(
	backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
    contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp)
) {
	<span class="syntax-all syntax-entity">Icon</span>(
  	 	tint <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface,
        imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
        contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
			id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_go_back)
    )
	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">16</span>.dp))
   	<span class="syntax-all syntax-entity">Text</span>(
		color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface,
		text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.title_settings),
		fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
	)
}</code></pre>

<p>Within our composable preview we will now be able to see a styled <code>TopAppBar</code> with the composable content displayed inside of it:</p>

<figure><img src="8.png"/></figure>

<hr />

<h2>Building the Notifications Setting Item</h2>

<p>With the <code>TopAppBar</code> defined, we can now start thinking about each of the settings items that are going to make up our settings screen.</p>

<figure><img src="Notification%20Settings.png"/></figure>

<h3>Creating the notifications setting composable</h3>

<p>First off, we’re going to start by creating the <strong>Enable Notifications</strong> setting item. This setting item allows the user to toggle notifications on and off, using a switch component to toggle this setting. We’ll start here by creating a new composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// NotificationSettings.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NotificationSettings</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>With this composable function defined, we can start to build out the settings items for notifications. We’re going to need to start by adding a parent level composable that will be used to hold the body of our settings item. For this, we’ll use a <code>Surface</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NotificationSettings</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Surface</span> {
       
    }
}</code></pre>

<p>The <code>Surface</code> composable will compose the provided body inside of a <code>Box</code> composable. It will also theme itself use the <code>surface</code> color from the application theme, which is what we want to be applied to our settings item in terms of styling. </p>

<p>💡 Using the Surface composable saves us from using a Box composable and applying a collection of styling ourselves, when this component already exists to do it for us. </p>

<p>So that the parent that is composing this <code>NotificationSettings</code> can apply some constraints, we’re going to assign the provided <code>Modifier</code> as the modifier argument for our <code>Surface</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NotificationSettings</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
       
    }
}</code></pre>

<p>💡 Remember, it is the expected behaviour to apply the provided modifier to the highest-level composable within a composable function.</p>

<p>At this point, we now have a surface that can be interacted with by the user to update the value for the given setting item. However, we don’t have any real visuals configured for this composable yet. For this setting item, we’re going to want to show a label along with a switch, these will be displayed next to each other in a horizontal format. To display composables in such a way we can utilise the <code>Row</code> composable, which is used to stack composables horizontally. We’ll now compose a <code>Row</code> inside of our previously defined <code>Surface</code> composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
) {
	<span class="syntax-all syntax-entity">Row</span> {
	
	}
}</code></pre>

<h3>Composing the Label</h3>

<p>With this <code>Row</code> in place, we now have a layout container that is added and configured to hold the components that make up our setting item. We can now go ahead and add these composables to our <code>Row</code>, so we’ll start here by adding a <code>Text</code> composable to display the label for our setting item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
) {
	<span class="syntax-all syntax-entity">Row</span> {
		<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> ...)
	}
}</code></pre>

<p>For the <code>Text</code> composable we’re required to add a value for the <code>text</code> argument. To satisfy this argument we’re going to have this passed into our <code>NotificationSettings</code> function so that the title can be provided by the parent composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NotificationSettings</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)</code></pre>

<p>💡 Having the title passed into our composable means that this switch setting item can be reused for other settings in future, rather than constraining it to that of the Notification Settings.</p>

<p>We can then use this string reference to apply a value to the required argument within the <code>Text</code> composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
}</code></pre>

<p>At this point, you’ll be able to see this text value composed within the declared <code>Surface</code> composable.</p>

<figure><img src="1-1.png"/></figure>

<h3>Composing the Switch</h3>

<p>Now that we have the label in place, we can go ahead and add the key part of our settings item - the switch that will be used to toggle the setting on and off. For this we’ll go ahead and use the <code>Switch</code> composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
	<span class="syntax-all syntax-entity">Switch</span>(
        checked <span class="syntax-all syntax-keyword">=</span> ...,
        onCheckedChange <span class="syntax-all syntax-keyword">=</span> ...
    )
}</code></pre>

<p>The <code>Switch</code> composable is from the Compose Material APIs and allows us to display a switch that can be used to toggle between two values, on and off. There are two required arguments when using the <code>Switch</code> composable, these are:</p>

<ul>
	<li><strong>checked</strong>: states whether or not the <code>Switch</code> is currently on or off</li>
	<li><strong>onCheckedChange</strong>: a callback that provides the next value of the <code>Switch</code> when the toggle action is triggered </li>
</ul>

<p>To keep our composable <code>Switch</code> stateless, we’re going to pass these two values into our composable function. <code>checked</code> will be in the form of a boolean and will depict whether the <code>Switch</code> is currently checked, while the <code>onCheckedChanged</code> is a lambda that can be triggered to tell the parent composable that the setting value needs to be toggled.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NotificationSettings</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">checked</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onCheckedChanged</span><span class="syntax-all syntax-keyword">:</span> (checked<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>💡 Stateless refers to the fact that the composable has state passed into it, as opposed to having the composable manage the state itself. This allows us to adhere to the concept of a single source of truth.</p>

<p>We can keep our composable stateless because we are already storing the state of our screen inside of our <code>SettingsState</code> class within our ViewModel. For this reason our composable doesn’t need to hold or manage its state, it can simply delegate that to the parent composable.</p>

<p>With those in place, we can then assign these two values to our <code>Switch</code> composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
	<span class="syntax-all syntax-entity">Switch</span>(
        checked <span class="syntax-all syntax-keyword">=</span> checked,
        onCheckedChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged
    )
}</code></pre>

<p>With this in place, we should now be able to view this addition and see the <code>Text</code> and <code>Switch</code> composables displayed alongside one another.</p>

<figure><img src="2-1.png"/></figure>

<h3>Improving the visual spacing</h3>

<p>In terms of spacing and alignment, things don’t look quite right here. While our setting row fills the maximum available width, our content currently looks like it’s not making use of all the available space. We’re going to fix this by forcing our <code>Text</code> composable to utilise the redundant width on the screen, which we’ll do using the <code>weight</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title, modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
	<span class="syntax-all syntax-entity">Switch</span>(
        checked <span class="syntax-all syntax-keyword">=</span> checked,
        onCheckedChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged
    )
}</code></pre>

<p>The <code>weight</code> modifier allows us to apply weighting to our composable - this weights the composable relative to other composables within the <code>Row</code>. Because we haven’t manually applied weighting to the <code>Switch</code>, this will force the <code>Text</code> to use up all of the remaining space in the <code>Row</code>.</p>

<figure><img src="3-1.png"/></figure>

<h3>Aligning the child composables</h3>

<p>You might have noticed that the child composables aren’t quite aligned on the vertical axis. We can fix this by using the <code>verticalAlignment</code> argument for the <code>Row</code> composable - this will align the content on the vertical axis using the provided <code>Alignment</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title, modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
	<span class="syntax-all syntax-entity">Switch</span>(
        checked <span class="syntax-all syntax-keyword">=</span> checked,
        onCheckedChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged
    )
}</code></pre>

<p>With this applied, we can see that the content of our <code>Row</code> is now aligned in the center vertically.</p>

<figure><img src="4-1.png"/></figure>

<h3>Padding the setting item content</h3>

<p>We can still improve things visually, especially in terms of spacing for our <code>Row</code>. Here we’ll use the <code>padding</code> modifier to apply a padding value to the horizontal edges of the content area. This will create spacing at both the start and end of the <code>Row</code> composable, stopping the content from pressing against the edges.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
	verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title, modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
	<span class="syntax-all syntax-entity">Switch</span>(
        checked <span class="syntax-all syntax-keyword">=</span> checked,
        onCheckedChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged
    )
}</code></pre>

<p>We can see that with this padding in place, the composable has a nicer presentation away from the edges of the screen.</p>

<figure><img src="5-1.png"/></figure>

<h3>Improving the Switch Row Accessibility</h3>

<p>At this point, we haven’t plugged this into our UI yet but we do have a functional composable. We’re going to make some final tweaks before we go ahead with hooking it up in the form of improving the accessibility for our Switch row.</p>

<p>Currently, if you interact with the setting row via talkback on your device, each of the <code>Text</code> and <code>Switch</code> composables would focus on individually. While interaction is possible here, this adds a little bit of friction when navigating via talkback as the user might need to end up navigating through double the number of components on the screen. </p>

<figure><img src="6-1.png"/></figure>

<p>We’re going to improve this by propagating the toggle functionality up to the setting <code>Row</code>, instead of having the <code>Switch</code> handle this. We’ll need to start by removing the <code>onCheckedChange</code> listener from our <code>Switch</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
	verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title, modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
	<span class="syntax-all syntax-entity">Switch</span>(
        checked <span class="syntax-all syntax-keyword">=</span> checked,
        onCheckedChange <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
    )
}</code></pre>

<p>Next, we can utilise the <code>toggleable</code> modifier, allowing our <code>Row</code> to become a toggle-able component. The toggle modifier requires a couple of different arguments to be set:</p>

<ul>
	<li><strong>value</strong>: the current value of toggle state. This will be a boolean value to represent whether the component is currently on or off.</li>
	<li><strong>onValueChange</strong>: this is the lambda that will be triggered when the component is toggled, allowing us to update our state accordingly.</li>
	<li><strong>role</strong>: the role of the toggle-able component (e.g switch, checkbox). This is used by the system accessibility services to describe elements or perform customisations.</li>
</ul>

<p>We’ll populate these using the values that we currently have within our composable function. For the <code>value</code> and <code>onValueChange</code> arguments, we can simply switch out the values that we had assigned to our <code>Switch</code>. For the role we’re going to want to apply the <code>Role.Switch</code> value, as our <code>Row</code> is going to represent the functionality of a <code>Switch</code>.</p>

<pre><code class="code-highlighted code-kt">toggleable(
	value <span class="syntax-all syntax-keyword">=</span> checked,
	onValueChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged,
	role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Switch</span>
)</code></pre>

<p>We can then take these values and apply them to our <code>Row</code> composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.toggleable(
        	value <span class="syntax-all syntax-keyword">=</span> checked,
            onValueChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged,
            role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Switch</span>
        )
		.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
	verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title, modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
	<span class="syntax-all syntax-entity">Switch</span>(
        checked <span class="syntax-all syntax-keyword">=</span> checked,
        onCheckedChange <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
    )
}</code></pre>

<p>With this in place, we’ll now be able to see that the accessibility services recognise our <code>Row</code> as an individually toggle-able component, as opposed to each composable being an individually focusable item.</p>

<figure><img src="7.png"/></figure>

<p>With the above in place, we now have a completed composable function in the form of <code>NotificationSettings</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NotificationSettings</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">checked</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onCheckedChanged</span><span class="syntax-all syntax-keyword">:</span> (checked<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .toggleable(
                    value <span class="syntax-all syntax-keyword">=</span> checked,
                    onValueChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged,
                    role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Switch</span>
                )
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title, modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
            <span class="syntax-all syntax-entity">Switch</span>(
                checked <span class="syntax-all syntax-keyword">=</span> checked,
                onCheckedChange <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
            )
        }
    }
}</code></pre>

<p>When it comes to the accessibility of our notification setting, we can go one step further here by utilising the <code>stateDescription</code> semantic. This semantic allows us to control the description used by the accessibility services when describing the current state of the composable. In the context of our notification settings we are using a <code>Switch</code> which will have an <code>on</code> or <code>off</code> state - this will be read by the accessibility service as these values. We can improve things here by actually describing what that state represents - which is whether the notifications are currently enabled or disabled. For example, hearing the following string resources being read gives the user much more context on the current state of the component.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_notifications_enabled&quot;</span>&gt;
	Notifications Enabled
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_notifications_disabled&quot;</span>&gt;
	Notifications Disabled
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Within our <code>NotificationSettings</code> composable we can then use these strings resources to build a string reference based on the current <code>checked</code> flag that is provided to the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> notificationsEnabledState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (checked) {
	stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_notifications_enabled)
} <span class="syntax-all syntax-keyword">else</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_notifications_disabled)</code></pre>

<p>Finally, we can assign this to the semantics of our composable using the <code>semantics</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.toggleable(
        	value <span class="syntax-all syntax-keyword">=</span> checked,
            onValueChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged,
            role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Switch</span>
		)
        .semantics {
        	stateDescription <span class="syntax-all syntax-keyword">=</span> notificationsEnabledState
        }
        .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
    verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
)</code></pre>

<p>With this in place, the accessibility services will now use this string resource to describe the current state of our composable. This provides a much greater level of context for the current state of the notifications setting.</p>

<h3>Composing the notifications setting</h3>

<p>At this point we have our composable function created, but it’s not yet being composed within our UI. For this, we’re going to hop on back over to our parent composable and compose the <code>NotificationSettings</code> composable. When composing this we’re going to utilise the <code>modifier</code> argument to enforce the composable to fill the maximum width that is available to it - which we’ll do so using the <code>fillMaxWidth</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth())
	}
}</code></pre>

<p>While we’re providing the <code>modifier</code> here, we’re still missing the required arguments that we set up for the composable function. These are the <code>title</code> string, <code>checked</code> flag and <code>onCheckedChanged</code> lambda. </p>

<p>So that we can provide the title to our composable function, we’re going to need to add a new string resource to our <code>strings.xml</code> file. This will be the string that we display within the settings row for our <strong>Enable Notifications</strong> setting.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;setting_enable_notifications&quot;</span>&gt;
	Enable Notifications
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then utilise the <code>stringResource</code> composable function to retrieve the string for our declared resource ID, providing this to our composable function for the <code>title</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">NotificationSettings</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	title <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications)
)</code></pre>

<p>For the <code>checked</code> flag we’re going to need to provide the current state for our notifications enabled setting. This is being stored in the <code>SettingsState</code> class from which is being accessed through our ViewModel. For this we can reference the state reference that is being passed into our composable function, accessing the <code>notificationsEnabled</code> from this and passing this for the <code>checked</code> flag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">NotificationSettings</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	title <span class="syntax-all syntax-keyword">=</span> stringResource(
		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications),
	checked <span class="syntax-all syntax-keyword">=</span> state.notificationsEnabled
)</code></pre>

<p>Finally, we need to provide the callback that will be triggered when the enabled notification setting is toggled between on and off. We previously created a function in our ViewModel, <code>toggleNotificationSettings</code>, that matches the structure of the lambda, so we can pass this directly to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">NotificationSettings</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	title <span class="syntax-all syntax-keyword">=</span> stringResource(
		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications),
	checked <span class="syntax-all syntax-keyword">=</span> state.notificationsEnabled,
	onCheckedChanged <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::toggleNotificationSettings
)</code></pre>

<p>With those in place, our <code>NotificationSettings</code> composable is fully satisfied. We’ll wrap this up by adding a <code>Divider</code> composable to create some visual separation after our <code>NotificationSettings</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>(
			title <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications),
			checked <span class="syntax-all syntax-keyword">=</span> state.notificationsEnabled,
			onCheckedChanged <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::toggleNotificationSettings
		)
		<span class="syntax-all syntax-entity">Divider</span>()
	}
}</code></pre>

<p>We now have a <code>NotificationSettings</code> composable that allows the user to toggle between the on and off state for the notification setting. When this is toggled, we can see that our state is changed and the UI is recomposed to reflect this.</p>

<figure><img src="8-1.png"/></figure>

<hr />

<h2>Reusing our Setting Item</h2>

<p>The rest of the setting items that we create in this screen are going to be very similar visually to our <strong>Enable Notifications</strong> setting, with the key difference being the content within the composable. For this reason, we’re going to create a common composable function that can be reused across each of our setting types. This allows us to:</p>

<ul>
	<li>Enforce similar constraints for each setting item. This allows us to ensure that the different constraints (such as height and widths) are represented equally</li>
	<li>Enforce a similar visual representation through the use of a <code>Surface</code></li>
</ul>

<p>While we’re only reusing a small amount of code here, this allows us to learn how to create reusable components for our projects. We’ll start here by creating a new composable function called <code>SettingItem</code>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SettingItem.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>We’ll add some body for our composable by copying over what we had previously defined as the body of our <strong>Enable Notifications</strong> setting. This consisted of a <code>Surface</code> composable that utilised the provided modifier to have some constraints applied to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
    
	}
}</code></pre>

<p>When it comes to most of our settings items, we’re going to want them to all use the same height - unless they need to expand into a larger vertical area. So that can enforce some form of minimum height, we’re going to go ahead and utilise the <code>heightIn</code> modifier and assign a value of <code>56.dp</code> for the <code>min</code> argument. This means that the composable will have a height of <strong>at least</strong> <code>56.dp</code> - using the <code>heightIn</code> modifier instead of the <code>height</code> modifier does not enforce a fixed size for our composable and instead allows it to grow should it need to.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .heightIn(min <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">56</span>.dp)
    ) {
    
	}
}</code></pre>

<p>💡 Using minimum size modifiers instead of static sizing modifiers means that the composables can grow when they need to. This makes your UI more responsive across different screen sizes, and also helps to keep your UI accessible for users who might be adjusting text sizes via their system settings.</p>

<p>Finally, we’re going to want to show some content inside of our <code>SettingItem</code> composable. Because this composable is reusable for each of our setting items, we’re going to allow the passing of composable content into this composable via the use of a function argument. For this, we’ll add a new argument to our function, in the form of a <code>@Composable () -&gt; Unit</code> type. Within the body of our <code>Surface</code> composable, we can then invoke this composable function, allowing the provided composable content to be composed inside of our <code>Surface</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">content</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .heightIn(min <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">56</span>.dp)
    ) {
        content()
    }
}</code></pre>

<p>💡 When creating reusable composables function, allowing composable content to be provided into the function allows us to create flexible composables that can be utilised for different use cases.</p>

<p>With this composable in place, we can now hop back on over to our <code>NotificationSettings</code> composable. We can see what we currently have here represents the same structure as the <code>Surface</code> that we just defined for our <code>SettingItem</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NotificationSettings</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">checked</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onCheckedChanged</span><span class="syntax-all syntax-keyword">:</span> (checked<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-entity">Row</span>(...) {
            <span class="syntax-all syntax-entity">Text</span>(...)
            <span class="syntax-all syntax-entity">Switch</span>(...)
        }
    }
}</code></pre>

<p>We’ll switch out this <code>Surface</code> composable, replacing it with the use of our <code>SettingItem</code>. We can see here now that we no longer need to worry about any specific constraints for the parent of the item, as that is now being handled by the generalised composable that we have created.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NotificationSettings</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">checked</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onCheckedChanged</span><span class="syntax-all syntax-keyword">:</span> (checked<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">SettingItem</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier
	) {
        <span class="syntax-all syntax-entity">Row</span>(
           ...
        ) {
            <span class="syntax-all syntax-entity">Text</span>(...)
            <span class="syntax-all syntax-entity">Switch</span>(...)
        }
    }
}</code></pre>

<p>While our composable does not look very different (other than the enforced minimum height), we can now reuse this for our other setting items and enforce some consistency across our UI components.</p>

<figure><img src="9.png"/></figure>

<p>Reusing this logic allows us to ensure that our settings composables are not only styled in the same way but also behave consistently across the different declarations. It won’t always be appropriate to reuse these things across composables, but if you start to notice a pattern of repetitions, that can be a good indicator to centralise things for re-use.</p>

<hr />

<h2>Building the Show Hints Setting Item</h2>

<p>Alongside the <strong>Enable Notifications</strong> setting item, we’re also going to support a setting item that uses the <code>Checkbox</code> composable in the form of the <strong>Show Hints</strong> setting item. Both coming from the Material APIs, the <code>Switch</code> and <code>Checkbox</code> are very similar components but will be portrayed as having a different purpose by the user. </p>

<figure><img src="Show%20Hints.png"/></figure>

<h3>Creating the hints setting composable</h3>

<p>These two setting items are going to be very similar in terms of their composable structure. Let’s start here by creating a composable function for this <strong>Show Hints</strong> setting item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// HintSettingsItem.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">HintSettingsItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>Similar to our previous settings item, we’re going to need to pass in some additional information that will be used to compose our settings item here. This information is going to consist of:</p>

<ul>
	<li><strong>title</strong>: the title to be displayed within the settings item</li>
	<li><strong>checked</strong>: whether the settings item is currently marked as on or off</li>
	<li><strong>onShowHintsToggled</strong>: a lambda used to trigger a callback whenever the settings item is toggled, allowing the parent composable to update the state for the setting item</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">HintSettingsItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">checked</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onShowHintsToggled</span><span class="syntax-all syntax-keyword">:</span> (checked<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>	
)</code></pre>

<p>Inside of this composable function we’re going to start by defining the composable content, which we’ll begin by using our newly created <code>SettingItem</code> composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier
) {


}</code></pre>

<p>We’re then going to go ahead and define the <code>Row</code> composable that will be used to hold the content for our setting item. For the <strong>Enable Notifications</strong> setting item we defined a <code>Text</code> and <code>Switch</code> composable which were displayed next to each other using a <code>Row</code>, so we’re going to be recreating the same layout here.</p>

<p>When creating the <strong>Enable Notifications</strong> <code>Row</code> we propagated the toggle state up to the <code>Row</code> composable instead of having it managed by the <code>Switch</code> composable. We’re going to take this approach and apply it directly to the <code>Row</code> of our <strong>Show Hints</strong> setting item, utilising the information that we are passing into our <code>HintSettingsItem</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            .toggleable(
                value <span class="syntax-all syntax-keyword">=</span> checked,
                onValueChange <span class="syntax-all syntax-keyword">=</span> { onShowHintsToggled() },
                role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Checkbox</span>
            )
    ) {
        
    }
}</code></pre>

<p>One key difference here, when compared to the <strong>Enable Notifications,</strong> setting item is the <code>role</code> that is being used with the <code>toggleable</code> modifier. Because we are now going to be working with the <code>Checkbox</code> composable, we’re instead using the <code>Role.Checkbox</code> value here so that the accessibility services are aware of the UI component being used. Other than that small difference, you’ll notice that the above code is the same as our previously created setting item. We’ll then go ahead and apply the same <code>padding</code> values, along with aligning the content of our <code>Row</code> in the center on the vertical axis by utilising the <code>Alignment.CenterVertically</code> value for the <code>verticalAlignment</code> argument from the <code>Row</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
        .toggleable(
            value <span class="syntax-all syntax-keyword">=</span> checked,
            onValueChange <span class="syntax-all syntax-keyword">=</span> { onShowHintsToggled() },
            role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Checkbox</span>
        )
        .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
    verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
) {
        
}</code></pre>

<p>The only thing missing now is the actual body of our composable, so we’ll go ahead and copy the same structure that is used by our <strong>Enable Notifications</strong> composable. Except instead of using the <code>Switch</code> composable, we’ll switch this out for the <code>Checkbox</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
        .toggleable(
            value <span class="syntax-all syntax-keyword">=</span> checked,
            onValueChange <span class="syntax-all syntax-keyword">=</span> { onShowHintsToggled() },
            role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Checkbox</span>
        )
        .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
    verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title, modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
    <span class="syntax-all syntax-entity">Checkbox</span>(
        checked <span class="syntax-all syntax-keyword">=</span> checked,
        onCheckedChange <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
    )  
}</code></pre>

<p>Like the <code>Switch</code> composable, the <code>Checkbox</code> is also a toggle-able component. You’ll even notice that the <code>checked</code> and <code>onCheckedChange</code> types are also the same across both of these composables.</p>

<p>With this in place, we now have a composable function that allows the user to toggle the setting for displaying hints in our app.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">HintSettingsItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">checked</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onCheckedChanged</span><span class="syntax-all syntax-keyword">:</span> (checked<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .toggleable(
                    value <span class="syntax-all syntax-keyword">=</span> checked,
                    onValueChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged,
                    role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Switch</span>
                )
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title, modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
            <span class="syntax-all syntax-entity">Checkbox</span>(
                checked <span class="syntax-all syntax-keyword">=</span> checked,
                onCheckedChange <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
            )
        }
    }
}</code></pre>

<p>This will give us a composable UI component that displays the <strong>Show Hints</strong> title to the user, along with a <code>Checkbox</code> that can be used to toggle the setting on and off.</p>

<figure><img src="1-2.png"/></figure>

<p>We didn’t need to dive too deep into how this setting item was created, as we can see how similar it is to the previous <strong>Enable Notifications</strong> composable that we defined. We have however learned about the extra toggle-able component, the <code>Checkbox</code>, along with utilising our re-usable <code>SettingItem</code> composable that we defined in the previous section.</p>

<h4>Improving the Hints Setting accessibility</h4>

<p>When it comes to the accessibility of our hints setting, we can go one step further here by utilising the <code>stateDescription</code> semantic - similar to how we did for the notifications setting. We can improve things here by actually describing what that state represents - which is whether the notifications are currently enabled or disabled. For example, hearing the following string resources being read gives the user much more context on the current state of the component.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_hints_enabled&quot;</span>&gt;Hints Enabled&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_hints_disabled&quot;</span>&gt;Hints Disabled&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Within our <code>HintSettingsItem</code> composable we can then use these strings resources to build a string reference based on the current <code>checked</code> flag that is provided to the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> hintsEnabledState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (checked) {
	stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_hints_enabled)
} <span class="syntax-all syntax-keyword">else</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_hints_disabled)</code></pre>

<p>Finally, we can assign this to the semantics of our composable using the <code>semantics</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.toggleable(
        	value <span class="syntax-all syntax-keyword">=</span> checked,
            onValueChange <span class="syntax-all syntax-keyword">=</span> onCheckedChanged,
            role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">Switch</span>
		)
        .semantics {
        	stateDescription <span class="syntax-all syntax-keyword">=</span> hintsEnabledState
        }
        .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
    verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
)</code></pre>

<p>With this in place, the accessibility services will now use this string resource to describe the current state of our composable. This provides a much greater level of context for the current state of the notifications setting.</p>

<h3>Composing the hints setting</h3>

<p>With this created, we can now go ahead and plug this into the parent composable for our settings screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth())
	}
}</code></pre>

<p>You’ll notice at this point that other than the provided modifier, we’re missing the required arguments that we setup for the composable function. This was the <code>title</code>, <code>checked</code> flag and <code>onShowHintsToggled</code> lambda. </p>

<p>So that we can provide the title to our composable function, we’re going to need to add a new string resource to our <code>strings.xml</code> file. This will be the string that we display within the settings row for our <strong>Show Hints</strong> setting.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;setting_show_hints&quot;</span>&gt;Show Hints&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then utilise the <code>stringResource</code> composable function to retrieve the string for our declared resource ID, providing this to our composable function for the <code>title</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">HintSettingsItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	title <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_show_hints)
)</code></pre>

<p>For the <code>checked</code> flag we’re going to need to provide the current state for our show hints setting. This is being stored in the <code>SettingsState</code> class from which is being accessed through our ViewModel. For this we can reference this state variable that is observing the state from our ViewModel, accessing the <code>hintsEnabled</code> from this and passing this for the <code>checked</code> flag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">HintSettingsItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	title <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_show_hints),
	checked <span class="syntax-all syntax-keyword">=</span> state.hintsEnabled
)</code></pre>

<p>Finally, we need to provide the callback that will be triggered when the show hints setting is toggled between on and off. We previously created a function in our ViewModel, <code>onShowHintsToggled</code>, that matches the structure of the lambda - so we can pass this directly to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">HintSettingsItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	title <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_show_hints),
	checked <span class="syntax-all syntax-keyword">=</span> state.hintsEnabled,
	onShowHintsToggled <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::toggleHintSettings
)</code></pre>

<p>With those in place, our <code>HintSettingsItem</code> composable is fully satisfied. We’ll wrap this up by adding a <code>Divider</code> composable to create some visual separation after our <code>HintSettingsItem</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			title <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_show_hints),
			checked <span class="syntax-all syntax-keyword">=</span> state.hintsEnabled,
			onCheckedChanged <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::toggleHintSetting
		)
		<span class="syntax-all syntax-entity">Divider</span>()
	}
}</code></pre>

<p>With this in place, we now have a <code>HintSettingsItem</code> composable that allows the user to toggle between the on and off state for the show hints setting. When this is toggled we can see that our state is changed and the UI is recomposed to reflect this state change.</p>

<figure><img src="2-2.png"/></figure>

<hr />

<h2>Building the Manage Subscription Setting Item</h2>

<p>Now that we have both of the toggle settings items in place, we’re going to create the next settings item - the <strong>Manage Subscription</strong> item. </p>

<figure><img src="Manage%20Subscription.png"/></figure>

<h3>Creating the manage subscription composable</h3>

<p>This is going to be quite a minimal component that would be used to launch another screen of the app. While in this project we aren’t going to be working with navigating to other parent composables (as in, screens), this setting item will give us a chance to explore some other concepts around composables. We’ll start here by creating a new composable, <code>ManageSubscriptionSettingItem</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ManageSubscriptionSettingItem.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>And again, we’ll make use of our <code>SettingItem</code> composable to define the foundations of our setting item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        
    }
}</code></pre>

<p>Inside of the SettingItem, we’re then going to start building out the body of this composable. Similar to the other items, we’re going to add a <code>Row</code> composable to allow us to layout composables along the horizontal axis.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span> {
        
    }
}</code></pre>

<p>At this point, you might be starting to notice a pattern of further similarity. Each of our composable setting items so far is using a <code>Row</code> inside of the <code>SettingItem</code> composable. So, why haven’t we placed this <code>Row</code> inside of our setting item? The truth is, we could do! After this setting item, we’re creating 3 more items - however, 2 of these do not need the concept of a <code>Row</code>. While there would be no harm in using a <code>Row</code> with a single child, we’re going to avoid too much generalisation for our composable at this point. </p>

<p>💡 If you wish to explore further generalisation, it could be helpful to think about how you might structure these composables to allow for more code reuse. For example, most of the settings have a row containing a text label that fills the remaining space in a row. Exploring how we would remove some of the duplications there, without over-abstracting our settings, would be a good exercise to explore. </p>

<h3>Composing the Title</h3>

<p>With our <code>Row</code> in place, we can now start adding some of the content for the setting item. We’ll start here with the title, which we’ll need to have passed into our composable function:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)</code></pre>

<p>We’ll then go ahead and add a <code>Text</code> composable that will be used to display the label for our setting item We’ll again utilise the <code>weight</code> modifier to have this fill the available space in the width of the <code>Row</code>, along with assigning the title of the setting to the <code>text</code> argument of the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span> {
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
			text <span class="syntax-all syntax-keyword">=</span> title
		)
    }
}</code></pre>

<figure><img src="1-3.png"/></figure>

<h3>Composing the action icon</h3>

<p>Because this is a setting item that would be clicked to launch another screen, we want to make it clear to the user that this is the behaviour for the setting item. For this, we’re going to add an arrow icon to the end of our row using the <code>Icon</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span> {
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
			text <span class="syntax-all syntax-keyword">=</span> title
		)
        <span class="syntax-all syntax-entity">Icon</span>(
            imageVector <span class="syntax-all syntax-keyword">=</span> ...,
            contentDescription <span class="syntax-all syntax-keyword">=</span> ...
        )
    }
}</code></pre>

<p>Here we haven’t yet added values for the arguments that are required for the <code>Icon</code> declaration. We’ll fix this by starting with providing a value for the <code>imageVector</code> argument, similar to how we added an icon to the <code>TopAppBar</code> of the screen we’ll utilise the <code>Icons</code> class from the compose packages. This time around we’re going to use the <code>KeyboardArrowRight</code> icon to display an arrow at the end of the <code>Row</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">KeyboardArrowRight</span>,
	contentDescription <span class="syntax-all syntax-keyword">=</span> ...
)</code></pre>

<p>We’re not quite done here yet, as the <code>Icon</code> requires a <code>contentDescription</code> to be provided for the composable - this description will be used to describe the visual element to accessibility services. We’re going to start by adding a description for this icon to our <code>strings.xml</code> file. The description needs to describe the purpose of the icon, so we’ll do this using the phrase “Open Subscription Management”.</p>

<pre><code class="code-highlighted code-xml">// strings.xml
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_open_subscription&quot;</span>&gt;
	Open Subscription Management
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>💡 If we were going to be reusing this setting item to launch other screens, it would be a good idea to have this content description passed into the composable function.</p>

<p>With this added to our resources, we can then use the <code>stringResource</code> composable function to retrieve the string value for this resource and pass the result directly to the <code>contentDescription</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">KeyboardArrowRight</span>,
	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(<span class="syntax-all syntax-entity">R</span>.string.cd_open_subscription)
)</code></pre>

<p>💡 It’s important to only provide content descriptions where they are going to be helpful for accessibility services. If a visual element is only being provided for decoration, then you can simply pass null for the description and the element will be ignored by the accessibility services.</p>

<p>With this in place, we now have our Manage Subscription setting item displaying the composables that we’ve defined above.</p>

<figure><img src="2-3.png"/></figure>

<h3>Creating visual space between the child composables</h3>

<p>Things look a little cramped in the settings row, so we’ll add some padding to the <code>Row</code> composable to create some visual spacing around the edges of the item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp)
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
			text <span class="syntax-all syntax-keyword">=</span> title
		)
        <span class="syntax-all syntax-entity">Icon</span>(
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">KeyboardArrowRight</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
				<span class="syntax-all syntax-entity">R</span>.string.cd_open_subscription)
        )
    }
}</code></pre>

<figure><img src="3-2.png"/></figure>

<p>While our setting item is now being displayed, it’s not yet interactable - meaning that when our user clicks on this item, nothing would happen. Before we go ahead and implement any form of click listener on our composable, we’re going to take the same approach as our other setting items and pass in a lambda function into our composable. This will be used to pass up the click event to the parent composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onSettingClicked</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>So that we can trigger this lambda function, we’re going to need to make our <code>Row</code> clickable. For this we’ll use the <code>clickable</code> modifier to support click events on our setting row, triggering our <code>onSettingClicked</code> lambda when this click event occurs.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
			.clickable { onSettingClicked() }
            .padding(<span class="syntax-all syntax-constant">16</span>.dp)
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
			text <span class="syntax-all syntax-keyword">=</span> title
		)
        <span class="syntax-all syntax-entity">Icon</span>(
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">KeyboardArrowRight</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
				<span class="syntax-all syntax-entity">R</span>.string.cd_open_subscription)
        )
    }
}</code></pre>

<p>💡 Here we place the clickable modifier before the padding modifier. This is because the ordering of modifiers matters, and this ensures that the whole padded area of the composable is clickable.</p>

<p>At this point, we have a functioning composable that support interaction events from our user. However, we can go one step further here and improve things in terms of accessibility. Our <code>Row</code> is clickable, but it isn’t communicated to the accessibility services what that click event does - the only way of knowing would be to navigate into the <code>Icon</code> composable to read the <code>contentDescription</code>. What we can do here is utilise the <code>onClickLabel</code> argument of the <code>clickable</code> modifier - this allows us to describe the click event, enabling accessibility services to be able to communicate the purpose of the click action.</p>

<p>To utilise this click label support, we’re going to move the content description of our <code>Icon</code> composable to the <code>onClickLabel</code> of our <code>clickable</code> modifier. We only need to have this content description in one place, and it makes more sense to place this at a higher level of this composable where the click event is managed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
			.clickable(
                onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_open_subscription
				)
            ) { onSettingClicked() }
            .padding(<span class="syntax-all syntax-constant">16</span>.dp)
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
			text <span class="syntax-all syntax-keyword">=</span> title
		)
        <span class="syntax-all syntax-entity">Icon</span>(
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">KeyboardArrowRight</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
        )
    }
}</code></pre>

<p>With this in place, we now have a composable for the <strong>Manage Subscription</strong> setting item completed and ready to be composed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onSettingClicked</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">SettingItem</span> {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .clickable(
                    onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_open_subscription, title
					)
                ) { onSettingClicked() }
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">Text</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
				text <span class="syntax-all syntax-keyword">=</span> title
			)
            <span class="syntax-all syntax-entity">Icon</span>(
                imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">KeyboardArrowRight</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
            )
        }
    }
}</code></pre>

<figure><img src="4-2.png"/></figure>

<h3>Composing the Manage Subscription setting</h3>

<p>Now that the composable is created, we can go ahead and plug this into our settings screen. We’ll start by composing the <code>ManageSubscriptionSettingItem</code> composable within the parent settings composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth())
	}
}</code></pre>

<p>Before we can continue we’ll need to add the required arguments to the composable - the <code>title</code> String and <code>onSettingClicked</code> lambda. </p>

<p>So that we can provide the title to our composable function, we’re going to need to add a new string resource to our <code>strings.xml</code> file. This will be the string that we display within the settings row for our <strong>Manage Subscription</strong> setting.</p>

<pre><code class="code-highlighted code-xml">// strings.xml
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;setting_manage_subscription&quot;</span>&gt;
	Manage Subscription
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then utilise the <code>stringResource</code> composable function to retrieve the string for our declared resource ID, providing this to our composable function for the <code>title</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	title <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_manage_subscription)
)</code></pre>

<p>Finally, we need to provide the callback that will be triggered when the <strong>Manage Subscription</strong> setting is clicked. As mentioned previously, we’re not going to be handling the click event of this settings item as it’s out of scope for this project - so we’ll leave this blank for now.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	title <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_manage_subscription),
	onSettingClicked <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-comment">// Handle setting click
</span>	}
)</code></pre>

<p>With those in place, our <code>ManageSubscriptionSettingItem </code> composable is fully satisfied. We’ll wrap this up by adding a <code>Divider</code> composable to create some visual separation after our <code>ManageSubscriptionSettingItem </code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			title <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_manage_subscription),
			onSettingClicked <span class="syntax-all syntax-keyword">=</span> {
				<span class="syntax-all syntax-comment">// Handle setting click
</span>			}
		)
		<span class="syntax-all syntax-entity">Divider</span>()
	}
}</code></pre>

<p>With this in place, we now have a <code>ManageSubscriptionSettingItem</code> composable that allows us to display a clickable settings item to the user. This composable has no aspects that need to update the state of our screen, making it a <strong>stateless</strong> static item that does not change based on state.</p>

<figure><img src="5-2.png"/></figure>

<hr />

<h2>Building a Spacer Item</h2>

<p>So far we’ve been using the <code>Divider</code> composable to separate most of our setting items. This has satisfied our requirements so far, but in some cases, we might want to create a more visual separation between different sections of our settings screen. </p>

<figure><img src="Spacer%20One.png"/></figure>

<p>To support this we’re going to create a new composable that can be used as a section spacer to create a visual gap. We’ll start by creating a new composable function, <code>SectionSpacer</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SectionSpacer.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SectionSpacer</span>(<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>)</code></pre>

<p>This visual separator is going to essentially be a blank composable that has a couple of different properties assigned to it:</p>

<ul>
	<li>We’ll want to fix the height of the section spacer. It’ll be fine for us to use a fixed size here, there’s going to be no content inside of the composable so we won’t need to worry about anything being cut-off.</li>
	<li>We’ll want the spacer to fill the maximum available width - similar to how we enforce the max-width for our other setting items.</li>
	<li>We’ll want to apply a background color to our composable. For this, we’ll want to use an existing color from our theme, allowing us to ensure that the color remains correct across any theming changes.</li>
</ul>

<p>With the above in mind, we end up with something that looks like the following:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SectionSpacer</span>(<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>) {
    <span class="syntax-all syntax-entity">Box</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">48</span>.dp)
            .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(
				alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.12f</span>))
    )
}</code></pre>

<p>To satisfy the different points from above:</p>

<ul>
	<li>We use the <code>height</code> modifier to set a fixed height of <code>48.dp</code> for the composable.</li>
	<li>We use the <code>fillMaxWidth</code> modifier to force the composable to use all of the available width.</li>
	<li>For the <code>background</code> modifier, we take the <code>onSurface</code> color from our theme and modify the alpha value for the color. The <code>onSurface</code> color itself is way too dark for what we’re looking for, so we’ll apply an alpha to achieve a more subtle color for use.</li>
</ul>

<p>With this in place, we can now compose this within our settings list, resulting in a component that allows us to create a clear visual separation between settings sections on our screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {	
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>()
		<span class="syntax-all syntax-entity">SectionSpacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth())
	}
}</code></pre>

<figure><img src="1-4.png"/></figure>

<hr />

<h2>Building the Marketing Options Setting Item</h2>

<p>Next up on our settings list is the Marketing Options setting item - this is used by the user to select their preference for any marketing content that they can receive from our app.</p>

<figure><img src="Marketing.png"/></figure>

<h3>Creating the Marketing Options setting item</h3>

<p>For this we’re going to explore the use of radio buttons - the <code>RadioButton</code> is a component from the Material APIs that allows the user to select an option from a presented set. We’ll again start here by creating a new composable function, placing our <code>SettingItem</code> composable inside of it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MarketingSettingItem.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

	}
}</code></pre>

<p>We’re going to be displaying two options to the user inside of our composable, one for opting into marketing emails and another for requesting to not receive emails. Before we can add these options to our UI, we’ll add the required strings for these to our <code>strings.xml</code> resources file:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string-array</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;setting_options_marketing_choice&quot;</span>&gt;
	&lt;<span class="syntax-all syntax-tag">item</span>&gt;Opt-in for marketing emails&lt;/<span class="syntax-all syntax-tag">item</span>&gt;
    &lt;<span class="syntax-all syntax-tag">item</span>&gt;Don\&#39;t send me emails&lt;/<span class="syntax-all syntax-tag">item</span>&gt;
&lt;/<span class="syntax-all syntax-tag">string-array</span>&gt;</code></pre>

<p>We’ll then need to access these from our composable function. We’ll do this by utilising the <code>stringArrayResource</code> composable function - this works similarly to the <code>stringResource</code> function that we’ve previously been using, except this is used for retrieving string arrays from our resource files. For now, we’ll assign this to a variable for later use.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-keyword">val</span> options <span class="syntax-all syntax-keyword">=</span> stringArrayResource(id <span class="syntax-all syntax-keyword">=</span> 	
		<span class="syntax-all syntax-entity">R</span>.array.setting_options_marketing_choice)
	<span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

	}
}</code></pre>

<p>Now we need to start building out the visuals of our settings item. Because we’re showing a title followed by selectable items, we’ll need to use a <code>Column</code> composable to allow us to stack these composables vertically. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-keyword">val</span> options <span class="syntax-all syntax-keyword">=</span> stringArrayResource(id <span class="syntax-all syntax-keyword">=</span> 	
		<span class="syntax-all syntax-entity">R</span>.array.setting_options_marketing_choice)
	<span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">Column</span> {


		}
	}
}</code></pre>

<h3>Composing the setting Title</h3>

<p>Now that we have a container for our child composables to be added to, we’ll next add the title for the setting item to our <code>strings.xml</code> resource file:</p>

<pre><code class="code-highlighted code-xml">// strings.xml
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;setting_option_marketing&quot;</span>&gt;
	Receive marketing emails?
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’ll then add a <code>Text</code> composable to our <code>Column</code> using the string resource that we just added to our resources file, again using the <code>stringResource</code> function to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-keyword">val</span> options <span class="syntax-all syntax-keyword">=</span> stringArrayResource(id <span class="syntax-all syntax-keyword">=</span> 	
		<span class="syntax-all syntax-entity">R</span>.array.setting_options_marketing_choice)
	<span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">Column</span> {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_option_marketing))
		}
	}
}</code></pre>

<p>At this point we now have this title displaying inside of our setting item:</p>

<figure><img src="1-5.png"/></figure>

<p>We can see here that things look a little bit cramped around the edges of the setting item. To improve things here we’re going to add some padding to our composable, using the <code>padding</code> modifier to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-keyword">val</span> options <span class="syntax-all syntax-keyword">=</span> stringArrayResource(id <span class="syntax-all syntax-keyword">=</span> 	
		<span class="syntax-all syntax-entity">R</span>.array.setting_options_marketing_choice)
	<span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">Column</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp)
		) {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_option_marketing))
		}
	}
}</code></pre>

<figure><img src="2-4.png"/></figure>

<h3>Composing the selectable options</h3>

<p>With the title in place, we can now think about adding the selectable marketing options to our setting item. We’re going to loop through the array of strings that we previously retrieved, building a selectable item for each one - let’s start by setting up this loop.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp)
) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
	options.forEachIndexed { index, option <span class="syntax-all syntax-keyword">-&gt;</span>

	}
}</code></pre>

<p>Inside of this loop, we’re now going to construct a selectable item that consists of a <code>RadioButton</code> composable, along with a label in the form of a <code>Text</code> composable. We’ll be displaying these horizontally next to one another, so we’ll start by adding a <code>Row</code> here. Because we’re looping through our array of options, this will cause a <code>Row</code> to be composed for each item in that array.</p>

<pre><code class="code-highlighted code-kt">options.forEachIndexed { index, option <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-entity">Row</span> {
		     
	}
}</code></pre>

<p>With the <code>Row</code> in place, we can now compose a <code>RadioButton</code> - this is a toggle-able component that works in the same way as the <code>Checkbox</code> and <code>Switch</code> composables that we’ve previously worked with. The main difference here is that the behaviour of a <code>RadioButton</code> group is slightly different as one item must <strong>always</strong> be selected, which is something we have already configured to be the case within our state. We’ll go ahead and add this composable to our <code>Row</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">RadioButton</span>(
		selected <span class="syntax-all syntax-keyword">=</span> ...,
		onClick <span class="syntax-all syntax-keyword">=</span> ...
	)      
}</code></pre>

<p>You’ll notice here that there are two required arguments here:</p>

<ul>
	<li><strong>selected</strong>: whether the <code>RadioButton</code> is currently selected</li>
	<li><strong>onClick</strong>: callback triggered when the composable is clicked</li>
</ul>

<p>Within our composable, we don’t currently have the concept of either of these things. Similar to the other composables that we’ve created in this chapter, we’re going to pass these in from the parent. We’ll go ahead and add arguments to our <code>MarketingSettingItem</code> function to satisfy the requirements of the <code>selected</code> and <code>onClick</code> values from above.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">selectedOption</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MarketingOption</span>,
	<span class="syntax-all syntax-parameter">onOptionSelected</span><span class="syntax-all syntax-keyword">:</span> (option<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MarketingOption</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With these values now available to our composable function we can slot them into our <code>RadioButton</code>, starting with the <code>selected</code> argument. Each <code>MarketingOption</code> has an <code>id</code> value which we created to match the index within the list of options. Because this is the case we can simply check if the <code>id</code> of the selected option is equal to the current index in our loop, assigning the result of this check to the <code>selected</code> argument. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">RadioButton</span>(
		selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
		onClick <span class="syntax-all syntax-keyword">=</span> ...
	)      
}</code></pre>

<p>💡 Using the index as the ID of our item isn’t the most scalable approach, but it helps to keep things simple for the sake of this example. If building this for production, it would be worth thinking about having the ID represented by something that didn’t rely on the index of a list.</p>

<p>With our <code>selected</code> argument now satisfied, we can satisfy the <code>onClick</code> argument. The listener that has been provided to our composable requires us to pass back the item that has been selected. Because we’re working with a string array we again need to utilise the <code>index</code> from our loop here. We can again keep this simple by returning either the <code>MarketingOption</code> <code>ALLOWED</code> or <code>NOT_ALLOWED</code> value based on the index of the clicked item. Once we’ve calculated this we can pass the result back using the <code>onOptionSelected</code> callback.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">RadioButton</span>(
		selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
		onClick <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">val</span> marketingOption <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>.id) {
                	<span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>
                } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">NOT_ALLOWED</span>
            onOptionSelected(marketingOption)
		}
	)      
}</code></pre>

<p>At this point, we’ll be able to see our <code>RadioButton</code> composed within our UI.</p>

<figure><img src="3-3.png"/></figure>

<p>Things are looking a bit blank here though, it also isn’t very clear what <code>RadioButton</code> is which! We’ll go ahead and add a <code>Text</code> composable to represent the label - passing the current <code>option</code> for the <code>text</code> argument of the composable. We’ll also go ahead and add some padding to the start of the <code>Text</code> composable so that it isn’t pressed right against our <code>Radiobutton</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span> {
	<span class="syntax-all syntax-entity">RadioButton</span>(
		selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
		onClick <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">val</span> marketingOption <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>.id) {
                	<span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>
                } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">NOT_ALLOWED</span>
            onOptionSelected(marketingOption)
		}
	)
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(
			start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.dp
		),
		text <span class="syntax-all syntax-keyword">=</span> option
	)   
}</code></pre>

<p>Now we have a label that describes the purpose of each marketing option:</p>

<figure><img src="4-3.png"/></figure>

<h3>Creating visual space</h3>

<p>Now that this is being composed in our UI, we can see two things that don’t feel quite right visually:</p>

<ul>
	<li>When clicking the composable function, the touch state does not expand the full width of the settings area. This feels a little odd and results in the items looking like they are different lengths on click events</li>
	<li>The items are very close together, making it difficult to interact with each item individually</li>
</ul>

<p>To solve these concerns we’re going to add two modifiers to the <code>Row</code> that holds the <code>RadioButton</code> and the supporting <code>Text</code> composable. First of all, the <code>fillMaxWidth</code> modifier will force the composable to fill the maximum available space - while this doesn’t look any different at first visually, the touch state of the composable will now fill the entire width of the setting area.</p>

<p>We’ll also utilise the <code>padding</code> composable to create some visual spacing for our composable - the will prevent the items from being pressed so closely together, removing any friction when trying to interact with them individually.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
	.fillMaxWidth()
	.padding(<span class="syntax-all syntax-constant">10</span>.dp)
) {
	<span class="syntax-all syntax-entity">RadioButton</span>(
		selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
		onClick <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">val</span> marketingOption <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>.id) {
                	<span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>
                } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">NOT_ALLOWED</span>
            onOptionSelected(marketingOption)
		}
	)
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(
			start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.dp
		),
		text <span class="syntax-all syntax-keyword">=</span> option
	)      
}</code></pre>

<p>With this in place, we can see that things are looking much nicer visually.</p>

<figure><img src="5-3.png"/></figure>

<p>The title of the marketing options is also very close to the selectable options, so we’ll go ahead and use the <code>Spacer</code> composable to create some visual spacing between these two parts of the setting item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp)
) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))
	options.forEachIndexed { index, option <span class="syntax-all syntax-keyword">-&gt;</span>
		...
	}
}</code></pre>

<figure><img src="6-2.png"/></figure>

<h3>Improving the selectable option interactions</h3>

<p>At this point, we have a functioning setting item that allows the user to select their desired marketing options. When interacting with the setting item, you might notice that only clicking the <code>RadioButton</code> composable triggers the selection of the marketing option. This isn’t very accessible for the user, so we’re going to lift the click listener and instead apply it to the container for our marketing option row. We’ll start here by removing the existing listener from our <code>RadioButton</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
	.fillMaxWidth()
	.padding(<span class="syntax-all syntax-constant">10</span>.dp)
) {
	<span class="syntax-all syntax-entity">RadioButton</span>(
    	selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
    	onClick <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
	)
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.dp),
		text <span class="syntax-all syntax-keyword">=</span> option
	)
}</code></pre>

<p>Now we take the previous listener that we had in place and instead assign it to our marketing option row using the <code>clickable</code> modifier. This way when the <code>Row</code> is clicked, the <code>onOptionSelected</code> callback will be triggered. While adding the modifier we’ll also provide an <code>onClickLabel</code> for the <code>Row</code> in the form of the current <code>option</code> - that way our <code>Row</code> has a description for its click action.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
	.fillMaxWidth()
    .clickable(
		onClickLabel <span class="syntax-all syntax-keyword">=</span> option
	) {
		<span class="syntax-all syntax-keyword">val</span> marketingOption <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> 		
			<span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>.id) {
				<span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>
            } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">NOT_ALLOWED</span>
                onOptionSelected(marketingOption)
            }
	}
    .padding(<span class="syntax-all syntax-constant">10</span>.dp)
) {
    <span class="syntax-all syntax-entity">RadioButton</span>(
        selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
        onClick <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
    )
    <span class="syntax-all syntax-entity">Text</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.dp),
        text <span class="syntax-all syntax-keyword">=</span> option
    )
}</code></pre>

<p>💡 Outside of accessibility services, this improves the usability of the component for all users of our app - as the row can be clicked as a complete item, rather than relying on individual component interactions.</p>

<p>With this in place, we now have a complete <code>MarketingSettingItem</code> composable function that is accessible to our users and allows the user to select a marketing option.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">selectedOption</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MarketingOption</span>,
    <span class="syntax-all syntax-parameter">onOptionSelected</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MarketingOption</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> options <span class="syntax-all syntax-keyword">=</span> stringArrayResource(id <span class="syntax-all syntax-keyword">=</span> 	
		<span class="syntax-all syntax-entity">R</span>.array.setting_options_marketing_choice)
    <span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Column</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
            <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))
            options.forEachIndexed { index, option <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .fillMaxWidth()
                    .clickable(
						onClickLabel <span class="syntax-all syntax-keyword">=</span> option
					) {
                        <span class="syntax-all syntax-keyword">val</span> marketingOption <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> 							<span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>.id) {
                            <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>
                        } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">NOT_ALLOWED</span>
                        onOptionSelected(marketingOption)
                    }
                    .padding(<span class="syntax-all syntax-constant">10</span>.dp)
                ) {
                    <span class="syntax-all syntax-entity">RadioButton</span>(
                        selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
                        onClick <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
                    )
					<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">10</span>.dp))
                    <span class="syntax-all syntax-entity">Text</span>(
                        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(
							start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.dp
						),
                        text <span class="syntax-all syntax-keyword">=</span> option
                    )
                }
            }
        }
    }
}</code></pre>

<h3>Improving the selectable option accessibility</h3>

<p>While in the above step we pulled up the listener to the parent of the selectable option to improve the interaction with the item, we’re going to go one step further here and lean into a more native approach. We’re instead going to use the <code>selectable</code> modifier to make our whole <code>Row</code> a selectable item, as opposed to it being a clickable item. When it comes to accessibility services, this makes quite a bit of difference as a clickable item does not represent any state to mark it as selected. When it comes to this setting item, one of the radio options is always going to be selected, so this needs to be reflected to the user.</p>

<p>The <code>selectable</code> modifier takes a collection of arguments:</p>

<ul>
	<li><strong>selected</strong>: This is the currently selected state of the item. For this, we’re going to use the same logic that is being used for the <code>selected</code> value of the nested <code>RadioButton</code></li>
	<li><strong>onClick</strong>: This is the lambda that is triggered when the item is clicked. We can use the same logic that we declared for the <code>clickable</code> modifier that was previously in use, passing up the click event to be handled by the parent</li>
	<li><strong>role</strong>: The <code>Role</code> used by the accessibility services to depict the component type. Here we’ll declare the <code>RadioButton</code> type.</li>
</ul>

<p>With this information in place, we can now switch out the <code>clickable</code> modifier for the <code>selectable</code> modifier, applying the logic described in the points above.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
	.selectable(
		selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
		onClick <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">val</span> marketingOption <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>.id) {
				<span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">ALLOWED</span>
			} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">NOT_ALLOWED</span>
			onOptionSelected(marketingOption)
		},
		role <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Role</span>.<span class="syntax-all syntax-entity">RadioButton</span>
	)
    .fillMaxWidth()
	.padding(<span class="syntax-all syntax-constant">10</span>.dp)
) {
	<span class="syntax-all syntax-entity">RadioButton</span>(
		selected <span class="syntax-all syntax-keyword">=</span> selectedOption.id <span class="syntax-all syntax-keyword">==</span> index,
		onClick <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
	)
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.dp),
		text <span class="syntax-all syntax-keyword">=</span> option
	)
}</code></pre>

<p>We can see that the configuration of this modifier is very similar to the <code>toggleable</code> modifier that we previously utilised in this chapter. Now that we are working with a <code>RadioButton</code>, this corresponds more to a <code>selectable</code> state as opposed to a <code>toggleable</code> state.</p>

<h3>Composing the Marketing Options setting item</h3>

<p>We next need to compose this setting item within our UI, so we’ll slot it in beneath the previous items that we added.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>()
		<span class="syntax-all syntax-entity">Spacer</span>()
		<span class="syntax-all syntax-entity">MarketingSettingItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth())
	}
}</code></pre>

<p>Here we’re still missing the required arguments that we setup for the composable function. These are the <code>selectedOption</code> and <code>onOptionSelected</code> lambda arguments.</p>

<p>For the <code>selectedOption</code> flag we’re going to need to provide the current state for our marketing option setting. This is being stored in the <code>SettingsState</code> class from which is being provided to our settings composable. For this we can access the <code>marketingOption</code> value from this state, passing the value for the <code>selectedOption</code> flag of our <code>MarketingSettingItem</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	selectedOption <span class="syntax-all syntax-keyword">=</span> state.marketingOption
)</code></pre>

<p>Finally, we need to provide the callback that will be triggered when a marketing option is selected. We previously created a function in our ViewModel, <code>setMarketingSettings</code> that matches the structure of the required lambda, so we can pass this directly to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MarketingSettingItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	selectedOption <span class="syntax-all syntax-keyword">=</span> state.marketingOption
	onOptionSelected <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::setMarketingSettings
)</code></pre>

<p>With those in place, our <code>MarketingSettingItem</code> composable is fully satisfied. We’ll wrap this up by adding a <code>Divider</code> composable to create some visual separation after our <code>MarketingSettingItem </code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>()
		<span class="syntax-all syntax-entity">Spacer</span>()
		<span class="syntax-all syntax-entity">MarketingSettingItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			selectedOption <span class="syntax-all syntax-keyword">=</span> state.marketingOption
			onOptionSelected <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::setMarketingSettings
		)
		<span class="syntax-all syntax-entity">Divider</span>()
	}
}</code></pre>

<p>With this in place, we now have a <code>MarketingSettingItem </code> composable that allows us to display selectable marketing options to the user. When interacting with the options that are composed here, we’ll be able to see the UI update based on the state changes.</p>

<figure><img src="7-1.png"/></figure>

<hr />

<h2>Building the Theme Selection Setting Item</h2>

<p>For the next item within our settings UI, we allow the user to change the theme that is being used to style the components within the application. We aren’t going to be triggering a theme change here, but exploring the UI components that can be used to display these options to the user.</p>

<figure><img src="Theme.png"/></figure>

<h3>Creating the Theme Selection setting composable</h3>

<p>This setting item is going to show a Dropdown menu that the user can select a theme from, which is then saved to our settings state. We’ll start here by creating a new composable function, <code>ThemeSettingItem</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ThemeSettingItem.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ThemeSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>Similar to the last setting composable that we created, this composable function is also going to need to know what option is currently selected, as well as know when any of the options are selected by the user. In the case of our application theme, we’ll pass in the selected theme in the form of a <code>Theme</code> reference, along with an <code>onOptionSelected</code> lambda that allows a <code>Theme</code> reference to be passed up to update the state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ThemeSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">selectedTheme</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Theme</span>,
    <span class="syntax-all syntax-parameter">onOptionSelected</span><span class="syntax-all syntax-keyword">:</span> (option<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Theme</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We’ll then follow the same pattern as our other composables - adding a <code>SettingItem</code> composable, follow by a <code>Row</code> composable that will be used to hold the composables used for the label and currently selected item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ThemeSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">selectedTheme</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Theme</span>,
    <span class="syntax-all syntax-parameter">onOptionSelected</span><span class="syntax-all syntax-keyword">:</span> (option<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Theme</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">SettingItem</span> {
        <span class="syntax-all syntax-entity">Row</span> {

        }
    }
}</code></pre>

<p>We’ll then display this label and the currently selected item in our <code>Row</code> by using two <code>Text</code> composables. Before we can do that though, we’ll need to add a new string to our <code>strings.xml</code> resources file.</p>

<pre><code class="code-highlighted code-xml">// strings.xml
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;setting_option_theme&quot;</span>&gt;Theme&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’ll then use this string for the first <code>Text</code> composable that we’re going to add to our <code>Row</code>, assigning the value to the <code>text</code> argument. We’ll also declare this in the same way that we’ve defined the expanding labels in the rest of our setting items, utilising the <code>weight</code> modifier to force the composable to fill the width of the settings area. For the second <code>Text</code> composable we’ll use the <code>label</code> property from the <code>selectedTheme.label</code> value that is provided to the composable function. This <code>label</code> represents the string resource for the corresponding theme, which we can retrieve the string value for using the <code>stringResource</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span> {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 			
				<span class="syntax-all syntax-entity">R</span>.string.setting_option_theme)
        )
        <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> selectedTheme.label))
    }
}</code></pre>

<p>With this in place, we can see the selected theme displayed in our UI.</p>

<figure><img src="1-6.png"/></figure>

<p>We can see here that our composable is being pushed against the edges of its bounds, so we’ll utilise the <code>padding</code> modifier to create some visual spacing for the content of the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp)
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 			
				<span class="syntax-all syntax-entity">R</span>.string.setting_option_theme)
        )
        <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> selectedTheme.label))
    }
}</code></pre>

<p>With this modifier in place, our setting item is now looking a bit more presentable when composed.</p>

<figure><img src="2-5.png"/></figure>

<h3>Composing the Dropdown Menu</h3>

<p>Now that the currently selected item is being displayed, we’re going to want to implement the theme selector that allows the user to select a theme - we’ll do this in the form of a selector menu, using the <code>DropdownMenu</code> composable. This composable allows us to display a menu of selectable items in the form of a dropdown menu. We’ll start by adding the composable declaration to our function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp)
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
            text <span class="syntax-all syntax-keyword">=</span> title
        )
        <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> selectedTheme.label))
    }
	<span class="syntax-all syntax-entity">DropdownMenu</span>(
        expanded <span class="syntax-all syntax-keyword">=</span> ...
    ) {
        
    }
}</code></pre>

<p>There are two required arguments for the <code>DropdownMenu</code> composable - the <code>expanded</code> state and the <code>content</code> for the menu. This isn’t going to be a part of our global screen state, so we’ll begin by implementing the required <code>expanded</code> state for the menu. We’re not making this a part of our global state and passing it into the composable because our screen does not need to know about the state of the <code>DropdownMenu</code>, so we’ll keep this scoped to our composable function.</p>

<p>For this piece of state, we’re going to create a new piece of mutable state and wrap it in a <code>remember</code> block. There are two parts to this:</p>

<ul>
	<li>We create a piece of mutable state using the <code>mutableStateOf</code> function. This allows us to create a value that can be observed as state by composed. By default our <code>DropdownMenu</code> will be collapsed, so we’ll default this expanded flag to <code>false</code>.</li>
	<li>Wrapping this state in the remember declaration will mean that the state will be persisted across recompositions. Without this, the reference will be recreated when recomposition occurs, meaning that now we have a state value that will survive across compositions.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">var</span> expanded by remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }</code></pre>

<p>With this state in place, we can now assign this <code>expanded</code> value to the <code>expanded</code> argument for our <code>DropdownMenu</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">var</span> expanded by remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }
<span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp)
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
            text <span class="syntax-all syntax-keyword">=</span> title
        )
        <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> selectedTheme.label))
    }
	<span class="syntax-all syntax-entity">DropdownMenu</span>(
        expanded <span class="syntax-all syntax-keyword">=</span> expanded
    ) {
        
    }
}</code></pre>

<p>💡 This is a good example of state that can be kept local to a composable function. The rest of our screen does not need to know about this state, so containing it locally keeps its responsibility clearly defined.</p>

<p>At this point though, the <code>expanded</code> flag is not yet being toggled to actually expand our dropdown menu, so we’ll assign a click listener to the <code>Row</code> of our setting item to detect when the user is requesting the dropdown menu. Using the <code>clickable</code> modifier, we toggle the <code>expanded</code> flag to the opposite of the current value, along with providing a click label to describe the action that is triggered from the click event.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_select_theme&quot;</span>&gt;Select theme&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
      	.clickable(
        	onClick <span class="syntax-all syntax-keyword">=</span> { expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>expanded },
          	onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_select_theme)
        )
        .padding(<span class="syntax-all syntax-constant">16</span>.dp)
)</code></pre>

<p>💡 Remember, the ordering of modifiers matters! We place the clickable modifier before the padding here for a reason. If the padding was applied before, then the touch indicator for the click event would not expand to fill the padded area. Applying the padding after the clickable modifier ensures that the indicator will spread to the padded edges of the composable.</p>

<p>Aside from expanding the dropdown menu, we’ll also want to ensure that the dropdown menu is collapsed when dismissal is requested. The <code>DropdownMenu</code> allows you to provide a lambda which is triggered upon dismiss requests, in the form of <code>onDismissRequest</code>. In this lambda we’re going to simply set our expanded value to <code>false</code> - so when the dismiss request takes place, our dropdown menu will be collapsed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">DropdownMenu</span>(
    expanded <span class="syntax-all syntax-keyword">=</span> expanded,
    onDismissRequest <span class="syntax-all syntax-keyword">=</span> { expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span> }
)</code></pre>

<p>With the foundations of our <code>DropdownMenu</code> in place, we can now think about adding the items that will make up the content of the menu. For this, we’re going to take our existing <code>Theme</code> enum and loop through the declared values. During this looping, we’ll declare the composition of a <code>DropdownMenuItem</code> composable. This composable is an item that is to be displayed inside of a <code>DropdownMenu</code>, requiring us to implement an <code>onClick</code> callback along with composable content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">DropdownMenu</span>(
    expanded <span class="syntax-all syntax-keyword">=</span> expanded,
    onDismissRequest <span class="syntax-all syntax-keyword">=</span> { expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span> }
) {
   <span class="syntax-all syntax-entity">Theme</span>.values().forEach { theme <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-entity">DropdownMenuItem</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
            ...
        }) {
            ...
        }
    }  
}</code></pre>

<p>For the content body, we’re just going to show the name of the theme that can be selected. We’ll do this using a <code>Text</code> composable, setting the <code>text</code> argument using the string resource to the theme that we are currently at during the values loop.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">DropdownMenuItem</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
	...
}) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> theme.label))
}</code></pre>

<p>We’ll next need to implement the action that is to be triggered when a click event occurs on our menu item. When this occurs we’re going to want to do two things:</p>

<ul>
	<li>Utilise the <code>onOptionSelected</code> callback that was passed to the composable function. This allows us to notify the parent composable about the theme that has been selected</li>
	<li>When an option is selected we want to dismiss the dropdown, so we will set the expanded flag to <code>false</code></li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">DropdownMenuItem</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
	onOptionSelected(theme)
	expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
}) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> theme.label))
}</code></pre>

<p>At this point, we now have a dropdown menu that displays selectable theme options to the user.</p>

<figure><img src="3-4.png"/></figure>

<p>We’re going to utilise the <code>offset</code> argument to allow us to offset the dropdown menu slightly, this will allow us to shift the menu away from the edge of the screen slightly.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">DropdownMenu</span>(
    expanded <span class="syntax-all syntax-keyword">=</span> expanded,
    onDismissRequest <span class="syntax-all syntax-keyword">=</span> { expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span> },
	offset <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">DpOffset</span>(<span class="syntax-all syntax-constant">16</span>.dp, <span class="syntax-all syntax-constant">0</span>.dp)
)</code></pre>

<p>Now our dropdown menu sits a little nicer on screen.</p>

<figure><img src="4-4.png"/></figure>

<p>With this in place, we have a completed composable function that allows the user to select a theme for our application.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ThemeSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">selectedTheme</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Theme</span>,
    <span class="syntax-all syntax-parameter">onOptionSelected</span><span class="syntax-all syntax-keyword">:</span> (option<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Theme</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> expanded by remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }
    <span class="syntax-all syntax-entity">SettingItem</span> {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .clickable(
                    onClick <span class="syntax-all syntax-keyword">=</span> { expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>expanded },
                    onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_select_theme)
                )
                .padding(<span class="syntax-all syntax-constant">16</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">Text</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
                text <span class="syntax-all syntax-keyword">=</span> title
            )
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> selectedTheme.label))
        }
        <span class="syntax-all syntax-entity">DropdownMenu</span>(
            expanded <span class="syntax-all syntax-keyword">=</span> expanded,
            onDismissRequest <span class="syntax-all syntax-keyword">=</span> { expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span> },
            offset <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">DpOffset</span>(<span class="syntax-all syntax-constant">16</span>.dp, <span class="syntax-all syntax-constant">0</span>.dp),
            properties <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PopupProperties</span>(
                usePlatformDefaultWidth <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
            )
        ) {
            <span class="syntax-all syntax-entity">Theme</span>.values().forEach { theme <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">DropdownMenuItem</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                    onOptionSelected(theme)
                    expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
                }) {
                    <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> theme.label))
                }
            }
        }
    }
}</code></pre>

<h3>Composing the Theme Selection setting</h3>

<p>We next need to add the composable to our settings UI, so we’ll slot it in beneath the previous items that we added.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>()
		<span class="syntax-all syntax-entity">Spacer</span>()
		<span class="syntax-all syntax-entity">MarketingSettingItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ThemeSettingItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth())
	}
}</code></pre>

<p>Here we now need to provide the required arguments that we setup for the composable function. These are the <code>selectedTheme</code> and <code>onOptionSelected</code> lambda values.</p>

<p>For the <code>selectedTheme</code> flag we’re going to need to provide the current state for our theme setting. This is being stored in the <code>SettingsState</code> class which is being provided to our composable function. For this value, we can access the <code>themeOption</code> from this state and pass its value for the <code>selectedTheme</code> flag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">ThemeSettingItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	selectedTheme <span class="syntax-all syntax-keyword">=</span> state.themeOption
)</code></pre>

<p>Finally, we need to provide the callback that will be triggered when a theme option is selected. We previously created a function in our ViewModel, <code>onOptionSelected</code>, that matches the structure of the lambda. We can pass this directly to our composable function to be triggered when the toggle occurs.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">ThemeSettingItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	selectedTheme <span class="syntax-all syntax-keyword">=</span> state.themeOption,
	onOptionSelected <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::setTheme
)</code></pre>

<p>With those in place, our <code>ThemeSettingItem</code> composable is fully satisfied. We’ll wrap this up by adding a <code>Divider</code> composable to create some visual separation after our <code>ThemeSettingItem </code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>()
		<span class="syntax-all syntax-entity">SectionSpacer</span>()
		<span class="syntax-all syntax-entity">MarketingSettingItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ThemeSettingItem</span>()
		<span class="syntax-all syntax-entity">SectionSpacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth())
	}
}</code></pre>

<p>With this in place, we now have a <code>ThemeSettingItem</code> composable that allows us to display selectable theme options to the user. </p>

<figure><img src="5-4.png"/></figure>

<hr />

<h2>Building the App Version Setting Item</h2>

<p>For our last settings item, we’re going to take a<code>Row</code> that will display the current version of the app. We’ve created quite a few of these settings items now, so we’re not going to dive too deep into the breakdown of how this is made up. </p>

<figure><img src="App%20Version.png"/></figure>

<h3>Creating the App Version setting composable</h3>

<p>We’ll start here by adding a new string to our <code>strings.xml</code> resource file that will represent the label for our setting item.</p>

<pre><code class="code-highlighted code-xml">// strings.xml
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;setting_app_version_title&quot;</span>&gt;
	App Version
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With this in place, we now have a label to be used for our settings item. We can now go ahead and create the composable for our <strong>App Version</strong> item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AppVersionSettingItem.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AppVersionSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">appVersion</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
) {
    <span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Row</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
                text <span class="syntax-all syntax-keyword">=</span> title
            )
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> appVersion
            )
        }
    }
}</code></pre>

<p>Most of the above we have covered throughout this section already, but let’s brush over the composable to clarify what is going on here:</p>

<ul>
	<li>We start by creating a composable function, <code>AppVersionSettingItem</code>. We define an argument here for the app version, this will be passed in by the parent composable.</li>
	<li>Next, we reuse our <code>SettingItem</code> composable to hold the setting item content.</li>
	<li>We then define a <code>Row</code> to hold the label and app version, utilise modifiers to apply some padding on either side of the item - along with aligning the content on the vertical axis using the <code>verticalAlignment</code> argument.</li>
	<li>Finally, we add the <code>Text</code> composables which will be used to display the label and app version content.</li>
</ul>

<p>With this all in place, we have a composable which will display a setting item that presents the current version of the app to the user.</p>

<figure><img src="vers.png"/></figure>

<h3>Improving screen reader navigation</h3>

<p>We can make a small tweak here to improve the navigation through our UI via a screenreader. Currently, if the user is navigating through the setting items using accessibility services, the two <code>Text</code> composables will be read as separate items. In this case, it feels like it makes more sense for these to be read as a single item. For example, if the user is read “App Version” then they would expect to also hear the version of the app - whereas currently, they would need to navigate further to the next item to find that out. To improve things here, we can utilise the <code>semantics</code> modifier to merge the descriptions of these two <code>Text</code> composables. This is done via the <code>mergeDescendants</code> flag within the <code>semantics</code> modifier - passing this as <code>true</code> will merge these two <code>Text</code> composables so that they will be focused as a single node by the screen reader.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AppVersionSettingItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">appVersion</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
) {
    <span class="syntax-all syntax-entity">SettingItem</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)
                .semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) {},
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
                text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span>
	 				<span class="syntax-all syntax-entity">R</span>.string.setting_app_version_title)
            )
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> appVersion
            )
        }
    }
}</code></pre>

<p>💡 It might not always make sense to merge the descriptions of child composables, hence why it is not the default behaviour. Before merging descriptions, be sure that would be an expected behaviour for the user.</p>

<h3>Composing the App Version setting</h3>

<p>As the final step for our App Version Settings item, we’re going to need to compose it within our Settings UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>()
		<span class="syntax-all syntax-entity">SectionSpacer</span>()
		<span class="syntax-all syntax-entity">MarketingSettingItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ThemeSettingItem</span>()
		<span class="syntax-all syntax-entity">SectionSpacer</span>()
		<span class="syntax-all syntax-entity">AppVersionSettingItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth())
	}
}</code></pre>

<p>You’ll notice at this point that the project won’t compile, this is because we’re missing the required <code>appVersion</code> argument that we setup for the composable function. This is the only single required argument for our composable, for which we’ll first need to add a new resource to our <code>strings.xml</code> file. </p>

<pre><code class="code-highlighted code-xml">// strings.xml
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;setting_app_version&quot;</span>&gt;v1.1&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>In a real scenario, we would likely fetch/calculate the application version and pass that into the composable function. For the sake of simplicity, we’ll use a string resource here. With this in place, we can now pass the string value for this resource directly to our composable, via the use of the <code>stringResource</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">AppVersionSettingItem</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	appVersion <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_app_version)
)</code></pre>

<p>With those in place, our <code>AppVersionSettingItem</code> composable is fully satisfied. We’ll wrap this up by adding a <code>Divider</code> composable to create some visual separation after our <code>AppVersionSettingItem</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MaterialTheme</span> {
	<span class="syntax-all syntax-entity">Column</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>()
		<span class="syntax-all syntax-entity">NotificationSettings</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">HintSettingsItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>()
		<span class="syntax-all syntax-entity">SectionSpacer</span>()
		<span class="syntax-all syntax-entity">MarketingSettingItem</span>()
		<span class="syntax-all syntax-entity">Divider</span>()
		<span class="syntax-all syntax-entity">ThemeSettingItem</span>()
		<span class="syntax-all syntax-entity">SectionSpacer</span>()
		<span class="syntax-all syntax-entity">AppVersionSettingItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			appVersion <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_app_version)
		)
		<span class="syntax-all syntax-entity">Divider</span>()
	}
}</code></pre>

<figure><img src="tot.png"/></figure>

<p>With this in place, we now have an <code>AppVersionSettingItem</code> composable that allows us to display selectable theme options to the user. </p>

<hr />

<h2>Wrapping Up</h2>

<p>At this point, we now have a completed settings screen, built up of the composables that we’ve defined throughout this section. These are being composed from the state that we’ve defined in the previous sections for this project, which all comes together to render our UI.</p>

<figure><img src="fin.png"/></figure>

<p>With all this in place, our UI is functional, but we can go one step further here to ensure that it remains this way over time. In the next section, we’ll continue to work on this screen, adding automated tests to perform assertions on our composable UI.</p>

<h1>Testing the Settings UI</h1>

<p>Now that we’ve built our settings screen, we’re going to take a look at how we can write some automated tests for our composables. We’re going to be writing some instrumentation tests using the compose <code>ui-test-junit</code> package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of compose test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>)
debugImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to utilise mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered when expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:3.12.4&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependant on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		exclude <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/AL2.0&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/LGPL2.1&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
	}
}</code></pre>

<hr />

<h2>Setting up the test class</h2>

<p>We’ll start here by creating a new class, <code>SettingsTest</code> - this class will be used to contain the different tests that we’re going to write. You’ll need to create this class inside of the <code>androidTest</code> directory of the module.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SettingsTest.kt
</span>
<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the <code>ComposeContentTestRule</code> class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@get:Rule
</span><span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched in, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside of. With this in place, we’re now ready to start writing some tests!</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SettingsTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<hr />

<h2>Testing the Settings Composable</h2>

<p>At the root of our feature is the <code>Settings</code> composable. What makes this different from our lower level composables (such as each setting item composable), is that this composable allows us to interact with elements to trigger state updates and recomposition of our UI. This means that with the tests for the <code>Settings</code> composable we can assert not only that the expected UI components are displayed, but also that interactions with them result in the expected state changes.</p>

<p>With that in mind, we’re going to start with some simple tests to ensure that the expected composables are shown on screen. To start with, our <code>Settings</code> composable displays a collection of settings items - we’ll write some tests to ensure that these are displayed as expected. We’ll start with the <strong>Enable Notifications</strong> setting item, for which we’ll create a new test function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Setting_Is_Displayed</span>()</code></pre>

<p>Inside of this test, we’re going to need to start by setting the composable content that is to be displayed on screen for us to assert against. Here we’ll use the test rule that we previously defined, along with its <code>setContent</code> function. This function takes a composable function as an argument, allowing us to define what is to be composed on screen for our tests. Because we’re wanting to test the Settings Composable that we defined in the previous sections of this chapter, we’ll go ahead and pass the Settings composable function for this composable argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Setting_Is_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
}</code></pre>

<p>While we aren’t yet performing any assertions, running this test will launch an activity that displays the content of our <code>Settings</code> composable. With this now being displayed, we can next perform the required assertions to ensure that the <strong>Enable Notifications</strong> setting is being displayed within our composable UI. We’ll do this by utilising the <code>onNodeWithText</code> function on our test rule reference.</p>

<p>The <code>onNodeWithText</code> function can be used to locate a composable that is displaying the text that we have provided to the function. Composables will be located in the form of a semantic node. Because our composables are represented via semantics, in our tests we are going to be locating nodes within our semantic tree. In this case, this is done using the onNodeWithText function, which will return us with a <code>SemanticsNodeInteraction</code> reference to perform assertions against. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Setting_Is_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
    composeTestRule.onNodeWithText(
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
				<span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications)
    )
}</code></pre>

<p>For this test we want to assert that this node is being displayed within our composed UI, so we’re going to go ahead and utilise the <code>assertIsDisplayed</code> function. This is one of the assertions available on the <code>SemanticsNodeInteraction</code> class, allowing us to assert whether this node is being displayed on the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Setting_Is_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
    composeTestRule.onNodeWithText(
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
				<span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications)
    ).assertIsDisplayed()
}</code></pre>

<p>With this pieced together, we now have a test that:</p>

<ul>
	<li>Uses the Settings composable to set the UI to be displayed on the screen.</li>
	<li>Locates a node within our composable UI, using a String from our application resources.</li>
	<li>Asserts that the retrieved node is displayed within our UI.</li>
</ul>

<p>If you run this test within your IDE, you’ll not only see the UI spin up inside of the connected device / emulator, but the tests should also be passing due to the required string being composed within the UI.</p>

<p>We’re next going to write similar tests for each of our other settings items so that we can assert that they are displayed within our UI. Because the tests are going to look the same, we’re going to start by refactoring the test we just wrote into a reusable function. This function, <code>assertSettingIsDisplayed</code>, is going to look the same as the test we just wrong. The key difference here is that instead of asserting a hardcoded string resource reference, it’ll take a string resource as an argument of the function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">assertSettingIsDisplayed</span>(
	<span class="syntax-all syntax-keyword">@StringRes</span> <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>
) {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Settings</span>()
	}
	composeTestRule.onNodeWithText(
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(title)
    ).assertIsDisplayed()
}</code></pre>

<p>With this in place, we can now replace the code that we had initially written for our text - calling this function to run the assertion against our <code>Settings</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Setting_Is_Displayed</span>() {
    assertSettingIsDisplayed(
		<span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications)
}</code></pre>

<p>We can now do the same again for the rest of the setting items that are expected to be composed inside of our <code>Settings</code> composable - asserting that the setting items are displayed on the screen. The key difference here is the string resource that we are using the locate each of the nodes, which will be passed into the <code>assertSettingIsDisplayed </code> within each test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Show_Hints_Setting_Is_Displayed</span>() {
	assertSettingIsDisplayed(
		<span class="syntax-all syntax-entity">R</span>.string.setting_show_hints)
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">View_Subscription_Setting_Is_Displayed</span>() {
	assertSettingIsDisplayed(
		<span class="syntax-all syntax-entity">R</span>.string.setting_manage_subscription)
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">App_Version_Setting_Is_Displayed</span>() {
    assertSettingIsDisplayed(
    	<span class="syntax-all syntax-entity">R</span>.string.setting_app_version_title)
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Theme_Setting_Is_Displayed</span>() {
    assertSettingIsDisplayed(
		<span class="syntax-all syntax-entity">R</span>.string.setting_option_theme)
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Marketing_Options_Setting_Is_Displayed</span>() {
    assertSettingIsDisplayed(
		<span class="syntax-all syntax-entity">R</span>.string.setting_option_marketing)
}</code></pre>

<h3>Testing the Enable Notification state</h3>

<p>When it comes to our <strong>Enable Notifications</strong> setting, it is of the Toggle Setting type - meaning that it displays a switch that can be used to toggle the setting on and off. We’ll want to perform some assertions here to ensure that the switch correctly reflects its new state within the UI. Because our composable function handles interactions by updating the state via event callbacks, having tests for these ensures that those connections are working as expected. We’ll write a test here, <code>Enable_Notifications_Toggles_Selected_State</code>, that will compose our Settings composable, click on the <strong>Enable Notifications</strong> setting item, followed by performing the assertion that the switch is marked as on. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Toggles_Selected_State</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
}</code></pre>

<p>Next, we’re going to locate the node within our composable hierarchy so that we can perform interactions and assertions on it. Here we’ll utilise the <code>onNodeWithText</code> function, providing the label of our settings item to locate the node.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Toggles_Selected_State</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
	composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications)
}</code></pre>

<p>At this point, the <code>onNodeWithText</code> function will return us with a <code>SemanticsNodeInteraction</code> reference which we can perform assertions against. For this interaction we’re going to use the <code>performClick</code> function, this is a gesture action that is available on the <code>SemanticsNodeInteraction</code> class, allowing us to perform a click gesture on the specified node.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Toggles_Selected_State</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
	composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications)
    ).performClick()
}</code></pre>

<p>Once the <code>performClick</code> gesture has been performed, we to check that the state is correctly reflected for our Enable Notifications switch.</p>

<p>So that we can perform assertions on our switch, we’re going to need to be able to locate it. Unlike the previous tests where we used text values to locate nodes within our composable UI, a switch does not have any uniquely identifiable data that we can use to locate it within our UI. For this reason, we’re going to need to add a tag to the switch composable, this tag can then be used to locate our composable within our tests. We’ll need to start here by defining a tag reference that can be accessed from both our tests and our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_TOGGLE_ITEM</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;toggle_item&quot;</span>
}</code></pre>

<p>With this tag defined, we’ll need to assign it to our composable - this assignment means that we can then retrieve nodes in our UI that have the corresponding tag. We’ll do this by utilising the testTag modifier to assign our tag to the switch composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// NotificationSettings.kt
</span>
<span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.testTag(<span class="syntax-all syntax-entity">TAG_TOGGLE_ITEM</span>)
		.toggleable(
			...
		)
		.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
	...
) { ... }</code></pre>

<p>When this <code>testTag</code> modifier is applied, the provided tag is set as a semantic property on the node. This is not visible to users but will be used by testing and accessibility services to locate composables via a tag identifier.</p>

<p>Now that our composable has a tag assigned to it, we can now use the <code>onNodeWithTag</code> function within our tests to locate composables whose tag match the requested tag. This operates in the same way that the previously used <code>onNodeWithText</code> function operates, but by using a tag instead of textual content.</p>

<pre><code class="code-highlighted code-kt">composeTestRule.onNodeWithTag(
    <span class="syntax-all syntax-entity">TAG_TOGGLE_ITEM</span>
)</code></pre>

<p>Now that the tag is in place, we can locate the node to perform assertions on. To perform these assertions we can use the <code>assertIsOn</code> function - this is one of the assertions available on the <code>SemanticsNodeInteraction</code> class, allowing us to assert whether this node is marked as being <strong>on</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Enable_Notifications_Toggles_Selected_State</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
    
	composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.setting_enable_notifications)
    ).performClick()

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_TOGGLE_ITEM</span>
    ).assertIsOn()
}</code></pre>

<h3>Testing the Show Hints state changes</h3>

<p>With the above tests in place, we’re now going to test the same concepts for the <strong>Show Hints</strong> setting item and that its state is reflected within the <code>Settings</code> composable. Before we can test this, we’ll again need to add a new tag to be used within our tests for the <strong>Show Hints</strong> item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    ...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHECK_ITEM</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;check_item&quot;</span>
}</code></pre>

<p>We can then assign this tag to our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// HintsSettingItem.kt
</span>
<span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.testTag(<span class="syntax-all syntax-entity">TAG_CHECK_ITEM</span>)
		.toggleable(
			...
        )
        .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
	...
)</code></pre>

<p>With this tag in place, we can now continue to test our composable. Next, we’ll use the label of the setting item to perform a click operation on the row. When this occurs, the state of our screen should be flipped to the opposite value - meaning that our state should represent hints being enabled. This should trigger a recomposition and cause our <code>Checkbox</code> to be marked as <strong>On</strong>. Similar to the tests for the notifications setting item, we can again use the tag that we applied to the composable to assert that this is the case.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Show_Hints_Toggles_Selected_State</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.setting_show_hints)
    ).performClick()

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_CHECK_ITEM</span>
    ).assertIsOn()
}</code></pre>

<h3>Testing the Marketing Option state changes</h3>

<p>For the last tests of our <code>Setting</code> composable we’re going to perform the same state assertions against the <strong>Marketing Options</strong> setting item. We’ll need to add another tag here - this time we’re going to append an underscore to the end of the tag. This is because we’re going to need to apply a tag to each of the radio buttons that are displayed within the Radio Group, this is so that we can locate each of these nodes by their corresponding index. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
    ...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_MARKETING_OPTION</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;marketing_option_&quot;</span>
}</code></pre>

<p>Within our <code>MarketingSettingItem</code> composable we’ll go ahead and assign this tag using the <code>testTag</code> modifier, appending the current <code>index</code> for the marketing option that is being composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MarketingSettingItem.kt
</span>
<span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
	.testTag(<span class="syntax-all syntax-entity">TAG_MARKETING_OPTION</span> <span class="syntax-all syntax-keyword">+</span> index)
 	.selectable(
		...
    )
)</code></pre>

<p>We can then use this tag to perform assertions within our tests. We’re going to want to assert that state changes are triggered and our composable represent any changed state. Here we’re going to trigger a change for the selected marketing option, followed by asserting that the newly selected option is selected. Where we’re previously been retrieving the value of a string resource to perform interactions on, here we’re going to need to retrieve the string array that holds the different values for our marketing options. By default, the first of these is selected (at index 0), so here we’ll select the next option within the collection. Once that click has been performed, we can then assert that the given node that represents that option is marked as selected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Marketing_Options_Toggles_Selected_State</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Settings</span>()
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.resources.getStringArray(
                <span class="syntax-all syntax-entity">R</span>.array.setting_options_marketing_choice)[<span class="syntax-all syntax-constant">1</span>]
    ).performClick()

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_MARKETING_OPTION</span> <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>
    ).assertIsSelected()
}</code></pre>

<hr />

<h2>Testing the Notification Setting Item</h2>

<p>Now that we have tests in place that performs assertions against our <code>Settings</code> composable, we’re going to focus on writing some fine-grained tests for the individual composable functions that represent our individual setting items. This allows us to focus on performing assertions on the behaviour of the composable function itself, without the concern of our global state. We’ll start here by creating a new test class, <code>NotificationSettingItemTest</code>, configuring our <code>ComposeContentTestRule</code> ready for use.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NotificationSettingItemTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()
   
}</code></pre>

<p>We’re going to start here by writing a test to assert that the composable correctly displays the title that is provided to it. Here we’ll create a new test function, <code>Title_Displayed</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>()</code></pre>

<p>With this is we’re going to need to compose our <code>NotificationSettings</code> composable, providing values for each of its required arguments. Here we’re going to hardcode a string that will be passed for the <code>title</code> argument. The value that we provide here does not matter, we just care that the composable displays what is provided to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Enable Notifications&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">NotificationSettings</span>(
            title <span class="syntax-all syntax-keyword">=</span> title,
            checked <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
			onToggleNotificationSettings <span class="syntax-all syntax-keyword">=</span>  { }
        )
    }
}</code></pre>

<p>Next, we can then use this <code>title</code> value to assert that there is a node displayed that represents this value. We’ll start here by using the <code>onNodeWithText</code> function to locate the composable that has that text value, followed by performing an assertion on it being displayed using the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Enable Notifications&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">NotificationSettings</span>(
            title <span class="syntax-all syntax-keyword">=</span> title,
            checked <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
			onToggleNotificationSettings <span class="syntax-all syntax-keyword">=</span>  { }
        )
    }
    composeTestRule
		.onNodeWithText(title)
		.assertIsDisplayed()
}</code></pre>

<p>Now that we know the <code>title</code> of the composable is being displayed, we can next assert that the switch reflects the <code>checked</code> value that is passed to our composable function. For this we’ll write a new test, <code>Setting_Checked</code>, providing values for each of its required arguments.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Setting_Checked</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">NotificationSettings</span>(
			title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Enable Notifications&quot;</span>,
			checked <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
			onToggleNotificationSettings <span class="syntax-all syntax-keyword">=</span>  { }
		)
    }
}</code></pre>

<p>Next, we’re going to use the <code>TAG_TOGGLE_ITEM</code> that we defined in a previous test to locate the node that represents the current state of our <code>toggleable</code> component.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Setting_Checked</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">NotificationSettings</span>(
			title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Enable Notifications&quot;</span>,
			checked <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
			onToggleNotificationSettings <span class="syntax-all syntax-keyword">=</span>  { }
		)
    }
	composeTestRule
		.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_TOGGLE_ITEM</span>)
}</code></pre>

<p>At this point, the <code>onNodeWithTag</code> function will return us with a <code>SemanticsNodeInteraction</code> reference which we can perform assertions against. In the case of this test we want to asset that notifications are enabled because we are passing in <code>true</code> for the <code>checked</code> argument - so we’ll want to check that the switch is on to represent the <code>checked</code> value that we have provided to the composable function. For this we can use the <code>assertIsOn</code> function - this is one of the assertions available on the <code>SemanticsNodeInteraction</code> class, allowing us to assert whether this node is marked as being <strong>on</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Setting_Checked</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">NotificationSettings</span>(
			title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Enable Notifications&quot;</span>,
			checked <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
			onToggleNotificationSettings <span class="syntax-all syntax-keyword">=</span>  { }
		)
    }
	composeTestRule
		.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_TOGGLE_ITEM</span>)
		.assertIsOn()
}</code></pre>

<hr />

<h2>Testing the Show Hints Setting Item</h2>

<p>Next up, we’re going to write some similar tests for the Show Hints setting item. We’ll start here by creating a new test class, <code>HintsSettingItemTest</code>, configuring our <code>ComposeContentTestRule</code> ready for use.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">HintsSettingItemTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’re going to start here by writing a test to assert that the composable correctly displays the title that is provided to it. Here we’ll create a new test function, <code>Title_Displayed</code>. Here this is we’re going to need to compose our <code>HintSettingsItem</code> composable, providing values for each of its required arguments. Here we’re going to hardcode a string that will be passed for the <code>title</code> argument. The value that we provide here does not matter, we just care that the composable displays what is provided to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Show Hints&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">HintSettingsItem</span>(
            title <span class="syntax-all syntax-keyword">=</span> title,
            checked <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
			onShowHintsToggled <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Next, we can then use this <code>title</code> value to assert that there is a node displayed that represents this value. We’ll start here by using the <code>onNodeWithText</code> function to locate the composable that has that text value, followed by performing an assertion on it being displayed using the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Show Hints&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">HintSettingsItem</span>(
            title <span class="syntax-all syntax-keyword">=</span> title,
            checked <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
			onShowHintsToggled <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithText(title)
        .assertIsDisplayed()
}</code></pre>

<p>Now that we know the <code>title</code> of the composable is being displayed, we can next assert that the switch reflects the <code>checked</code> value that is passed to our composable function. For this we’ll write a new test, <code>Setting_Checked</code>, providing values for each of its required arguments. This test is going to be represented in the same way as the previous setting checked test we wrote for the notifications setting item, except this time utilising the <code>TAG_CHECK_ITEM</code> to locate the corresponding node.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Setting_Checked</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">HintSettingsItem</span>(
            title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Show Hints&quot;</span>,
            checked <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
			onShowHintsToggled <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CHECK_ITEM</span>)
        .assertIsOn()
}</code></pre>

<hr />

<h2>Testing the Manage Subscription Setting item</h2>

<p>Next up, we’re going to write some tests for our <code>ManageSubscriptionSettingItem</code> composable. We’ll start by creating a test class, along with a test that asserts that the provided title is displayed. This is the same as the previous tests that we have written for our other setting items.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ManageSubscriptionSettingItemTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

	<span class="syntax-all syntax-keyword">@Test
</span>	<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_displayed</span>() {
		<span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Manage Subscription&quot;</span>
		composeTestRule.setContent {
			<span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
                title <span class="syntax-all syntax-keyword">=</span> title,
                onSettingClicked <span class="syntax-all syntax-keyword">=</span> { }
            )
        }
        composeTestRule
            .onNodeWithText(title)
            .assertIsDisplayed()
    }
}</code></pre>

<p>When testing our <code>Setting</code> composable we performed assertions to ensure that composable interactions correctly update state. The <code>ManageSubscriptionSettingItem</code> also has a similar listener that can be provided to the composable function, but this doesn’t manipulate any state. In the case of this setting item, this is something that would be used to launch another screen - not something that is represented within our state. To give this some test coverage, we’re going to write a new test called <code>On_Setting_Clicked_Triggered</code> that will be used to assert that the provided lambda is triggered when the composable is clicked.</p>

<p>When composing the <code>ManageSubscriptionSettingItem</code>, the key difference here is that we are going to pass in a <code>mock</code> lambda function for the <code>onSettingClicked</code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based on composable events.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">On_Setting_Clicked_Triggered</span>() {
	<span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Manage Subscription&quot;</span>
    <span class="syntax-all syntax-keyword">val</span> onSettingClicked<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
            title <span class="syntax-all syntax-keyword">=</span> title,
            onSettingClicked <span class="syntax-all syntax-keyword">=</span> onSettingClicked
        )
    }
}</code></pre>

<p>We’ll then use the <code>onNodeWithText</code> function to locate the node using the <code>title</code> that is assigned to our composable, followed by performing a click action on the composable using the <code>performClick</code> function. When this click event occurs, it is expected that our lambda is triggered - so we’ll use mockito here to <code>verify</code> that the lambda has been invoked. If this is the case, the test will succeed - otherwise, the lambda not being triggered will mean that our verification will not be satisfied and the test will fail.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">On_Setting_Clicked_Triggered</span>() {
	<span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Manage Subscription&quot;</span>
    <span class="syntax-all syntax-keyword">val</span> onSettingClicked<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ManageSubscriptionSettingItem</span>(
            title <span class="syntax-all syntax-keyword">=</span> title,
            onSettingClicked <span class="syntax-all syntax-keyword">=</span> onSettingClicked
        )
    }
    composeTestRule
        .onNodeWithText(title)
        .performClick()
        
    verify(onSettingClicked).invoke()
}</code></pre>

<hr />

<h2>Testing the Marketing Options Setting item</h2>

<p>We’re next going to write some tests for our <code>MarketingSettingItem</code> composable. We’ll start by creating a test class that will be used to house the test that we’re going to create.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MarketingSettingItemTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>For this composable, we’re just going to create a single test that will be used to determine that the radio button within the composable is marked as selected, based on the value that is passed into the composable function. While we have an <code>onOptionSelected</code> lambda that is being provided here, we know this is working from the tests on the <code>Settings</code> composable - but feel free to write the same ones here if you see a benefit!</p>

<p>We’ll start here by composing the <code>MarketingSettingItem</code> providing a reference to a <code>MarketingOption</code> for the <code>selectedOption</code> argument. We’ll keep a reference to this so that we can use it in our assertions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Marketing_Option_Selected</span>() {
    <span class="syntax-all syntax-keyword">val</span> option <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">NOT_ALLOWED</span>

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
            selectedOption <span class="syntax-all syntax-keyword">=</span> option,
			onOptionSelected <span class="syntax-all syntax-keyword">=</span>  { }
        )
    }
}</code></pre>

<p>Next, we’re going to use the <code>TAG_MARKETING_OPTION</code> tag to locate the node for the marketing option that should be selected - remember, we designed the tag so that we can append the id onto the end. We’ll then use the <code>assertIsSelected</code> function so that we can assert that the <code>MarketingOption.NOT_ALLOWED</code> that we passed to the composable as the <code>selectedOption</code> is indeed selected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Marketing_Option_Selected</span>() {
    <span class="syntax-all syntax-keyword">val</span> option <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MarketingOption</span>.<span class="syntax-all syntax-entity">NOT_ALLOWED</span>

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">MarketingSettingItem</span>(
            selectedOption <span class="syntax-all syntax-keyword">=</span> option,
			onOptionSelected <span class="syntax-all syntax-keyword">=</span>  { }
        )
    }

    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MARKETING_OPTION</span> <span class="syntax-all syntax-keyword">+</span> option.id)
        .assertIsSelected()
}</code></pre>

<hr />

<h2>Testing the Theme Setting item</h2>

<p>When it comes to the <code>ThemeSettingItem</code> composable, there are a couple of layers to the composable. Not only is the selected item displayed initially, but clicking the component will display a popup sheet to change the selection. With this in mind, we’ll write some tests to cover these cases. We’ll start by setting up a new test class, <code>ThemeSettingItemTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ThemeSettingItemTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>Next, we’re going to write a test to assert that the <code>Theme</code> provided as the <code>selectedTheme</code> is displayed within the composable as the current theme. We’ll start by composing the <code>ThemeSettingItem</code> within the <code>setContent</code> block for our test rule, passing a <code>Theme</code> reference that we will later use for assertions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Selected_Theme_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> option <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Theme</span>.<span class="syntax-all syntax-entity">DARK</span>

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ThemeSettingItem</span>(
            selectedTheme <span class="syntax-all syntax-keyword">=</span> option,
			onOptionSelected <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Before we can perform assertions on our composable, we’ll need to add a tag so that we can locate the node within our composable hierarchy.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
    ...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_THEME</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;theme&quot;</span>
}</code></pre>

<p>With this <code>TAG_THEME</code> in place, we can now assign this to the corresponding composable within the <code>ThemeSettingItem</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ThemeSettingItem.kt
</span>
<span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
	text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.setting_option_theme)
)
<span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_THEME</span>),
	text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> selectedTheme.label)
)</code></pre>

<p>Now, we can use this tag along with the <code>onNodeWithTag</code> function to locate this composable. With this node retrieved, we want to assert that it’s text is equal to the label of the <code>selectedTheme</code> that we provided to the composable. So here, we’ll fetch the string representation of our <code>option</code> that we’ve defined in our tests, using this within the <code>assertTextEquals</code> function to check that the composable with our tag has text equal to that of our <code>option</code> label.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Selected_Theme_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> option <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Theme</span>.<span class="syntax-all syntax-entity">DARK</span>

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ThemeSettingItem</span>(
            selectedTheme <span class="syntax-all syntax-keyword">=</span> option,
			onOptionSelected <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_THEME</span>, useUnmergedTree <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>)
        .assertTextEquals(
			<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.targetContext.getString(option.label)
        )
}</code></pre>

<p>Now that we can assert the selected <code>Theme</code> is showing, we’re next going to write a test that checks all of the available <code>Theme</code> options are displayed. We’ll need to add another tag to our <code>Tags</code> object so that we can interact with the theme selection composable. While this has a string resource assigned to it, this can help to keep our test code simpler and context-free.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
    ...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_SELECT_THEME</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;select_theme&quot;</span>
}</code></pre>

<p>We’ll then assign this tag to the corresponding <code>Row</code> composable that is used to hold the composable for the currently selected <code>Theme</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ThemeSettingItem.kt
</span>
<span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxWidth()
        .clickable(
            ...
        )
        .padding(<span class="syntax-all syntax-constant">16</span>.dp)
        .testTag(<span class="syntax-all syntax-entity">TAG_SELECT_THEME</span>)
)</code></pre>

<p>While we can now interact with this composable to display the theme options, we don’t have a way to locate the nodes that represent the theme options. For each of these options, we’re also going to want to assign a tag. Here will append an underscore to the end of the tag so that we can append the label for each theme when assigning the tag in our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
    ...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_THEME_OPTION</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;theme_&quot;</span>
}</code></pre>

<p>We’ll then assign this tag using the <code>testTag</code> modifier to each <code>DropdownMenuItem</code> composable that is composed for our <code>Theme</code> items. When assigning this tag, we’ll also apply the <code>theme.label</code> to be appended to the tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ThemeSettingItem.kt
</span>
<span class="syntax-all syntax-keyword">val</span> themeLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> theme.label)
<span class="syntax-all syntax-entity">DropdownMenuItem</span>(
	onClick <span class="syntax-all syntax-keyword">=</span> {
		...
	},
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_THEME_OPTION</span> <span class="syntax-all syntax-keyword">+</span> theme.label)
) { ... }</code></pre>

<p>With these tags in place, we can now continue writing the logic that will be used to interact with the composables within our tests. We’ll start here by retrieving the node that has the <code>TAG_SELECT_THEME</code> tag assigned to it, followed by triggering the <code>performClick</code> function to click the corresponding composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Theme_Options_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ThemeSettingItem</span>(
            selectedTheme <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Theme</span>.<span class="syntax-all syntax-entity">DARK</span>,
			onOptionSelected <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

	composeTestRule
		.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SELECT_THEME</span>)
		.performClick()
}</code></pre>

<p>Now that we’ve clicked on this composable, it would be expected that the local state flag would be toggled and the theme select popup will be displayed. At this point we should be able to see each of the <code>Theme</code> options displayed in the sheet, these are the options that we previously used the <code>Theme</code> labels to apply the <code>TAG_THEME_OPTION</code> tag. </p>

<p>Within our test we’re now going to loop through the values that represent our <code>Theme</code> enum, locating a node based on the label of the current <code>Theme</code> that we are at within the loop, and then asserting that the code is currently displayed. If this test passes, it means that each of the <code>Theme</code> options that are supported by our app is currently being displayed within the theme selection popup.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Theme_Options_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ThemeSettingItem</span>(
            selectedTheme <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Theme</span>.<span class="syntax-all syntax-entity">DARK</span>,
			onOptionSelected <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

	composeTestRule
		.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SELECT_THEME</span>)
		.performClick()

    <span class="syntax-all syntax-entity">Theme</span>.values().forEach { theme <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule
            .onNodeWithTag(
                <span class="syntax-all syntax-entity">TAG_THEME_OPTION</span> <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-entity">InstrumentationRegistry</span>
					.getInstrumentation().targetContext
						.getString(theme.label
                    )
                )
                .assertIsDisplayed()
    }
}</code></pre>

<p>There is also scope here to test that the <code>onOptionSelected</code> lambda is triggered when expected - feel free to write tests for that if desired!</p>

<hr />

<h2>Testing the App Version Setting item</h2>

<p>For the last tests that we’re going to write for our Settings Screen, we’ll cover a quick test for our App Version setting item. We’ll again need to start here by creating a new test class with a supporting compose test rule.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AppVersionSettingItemTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()
  
}</code></pre>

<p>For this test, we’re simply going to want to assert that the app version provided via the <code>appVersion</code> argument is displayed within our composable. We can use a lot of learnings from other tests in this chapter to put this together.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">App_Version_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> version <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;1.0.4&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AppVersionSettingItem</span>(appVersion <span class="syntax-all syntax-keyword">=</span> version)
    }
    composeTestRule
        .onNodeWithText(version)
        .assertIsDisplayed()
}</code></pre>

<ul>
	<li>We start by defining a <code>version</code> that can be passed to the <code>appVersion</code> argument, along with being used in our assertion</li>
	<li>We then compose the <code>AppVersionSettingItem</code>, passing the <code>version</code> variable for the <code>appVersion</code> argument</li>
	<li>We location the corresponding node using the <code>version</code> and the <code>onNodeWithText</code> function</li>
	<li>Finally, we use the <code>assertIsDisplayed</code> function to assert that the composable we are looking for is being displayed</li>
</ul>

<hr />

<p>With all of these tests in place, we’ve covered a lot of different cases that help to ensure our UI is working as expected. We’ve not only tested that composables are being composed based on the information that they are provided with, but also that they triggered the expected callbacks and trigger state manipulations within our composables. While the tests here aren’t extensive, we’ve been able to learn not only what options are available to us while testing composables, but also the approaches that we can take when doing so.</p>

<h1>Building an Authentication Form</h1>

<p>When building apps, it’s often that we’ll be working with some kind of user account - meaning that we’ll need to provide a way for users to create a new account or access an existing one. The ability to be able to achieve this will be provided through an authentication screen, providing a way for users to sign-up or sign-in using one of the methods that your application offers. While many apps offer authentication via third-party sites (such as social accounts), a common requirement is email authentication - not only does this decouple users accounts from third-party sites, but it also offers a common authentication method for connecting with your application. </p>

<p>With this in mind, we’re going to build out an email authentication screen using jetpack compose. While an email form isn’t visually the most exquisite experience to be building, it offers a collection of ways for us to think about state management and is a perfect example of how different an implementation may be when compared to the existing Android UI toolkit. </p>

<figure><img src="1-7.png"/></figure>

<p>When it comes to this screen, we need to configure and handle several different things.</p>

<ul>
	<li>Add the UI for user interaction to perform authentication</li>
	<li>Persist the state for the entered email and password</li>
	<li>Manage the UI state based on the entered credentials, such as disabling the button when no credentials have been entered</li>
	<li>Handle the state change when the authentication mode toggle button is pressed</li>
	<li>Correctly support IME actions, allowing field focus to be changed and the form to be submitted via the software keyboard</li>
</ul>

<p>We can see here that when it comes to the authentication screen, there is more to it than a minimal form that is used for credential entry. The management of state and recomposition of the UI based on those state changes gives us some good foundations to really start to explore the concept of state within Jetpack Compose.</p>

<h1>Defining the Authentication State</h1>

<p>&nbsp;Within our authentication form, we’re going to be dealing with many different pieces of state that depict how the UI is going to be displayed to the user. This state will be used to compose our UI, allowing us to control how our composables look and behave to the user. Within our UI we’re going to need to show the following things:</p>

<ul>
	<li>A title that will tell the user that they need to sign-in or sign-up</li>
	<li>An input field which will be used to enter an email address</li>
	<li>An input field which will be used to enter a password</li>
	<li>A password validation indicator to notify the user whether their password meets the minimum requirements</li>
	<li>A button that will allow the user to trigger the authentication flow. This button will also be disabled when there is no content input into the email and password fields</li>
	<li>A button that will allow the user to toggle between sign-in and sign-up</li>
	<li>A progress indicator which will display when the sign-in or sign-up operation is being performed</li>
</ul>

<p>With the above set out, we can start to see that there are going to be several pieces of state that we need to hold. With that in mind, let’s start to take the above statements and build a class that will represent the state of our composable UI. Let’s create a new class, <code>AuthenticationState</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationState.kt
</span><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationState</span>(
   
)</code></pre>

<h2>Modelling the user credentials</h2>

<p>We’ll start with the content that is going to be input by the user - the email address and password. Because this is something that the user will enter and will be displayed within our UI, each of these is going to represent a piece of our state. For this, we’ll go ahead and add two string references to our state class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationState</span>(
	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<h2>Modelling the password requirements</h2>

<p>Alongside the user being able to enter their password, we’re also going to enforce some requirements for that password. We’ll represent these requirements in the form of an enum - this allows us to enforce the length and content of the password that is entered.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PasswordRequirements</span> {
    <span class="syntax-all syntax-entity">CAPITAL_LETTER</span>, <span class="syntax-all syntax-entity">NUMBER</span>, <span class="syntax-all syntax-entity">EIGHT_CHARACTERS</span>
}</code></pre>

<p>For each of the requirements we’re going to want to show a message, this will be used to communicate what the requirement is to the user. For this, we’ll need to start by adding some new strings to our <code>strings.xml</code> file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;password_requirement_characters&quot;</span>&gt;
	At least 8 characters
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
    
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;password_requirement_capital&quot;</span>&gt;
	At least 1 upper-case letter
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;

&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;password_requirement_digit&quot;</span>&gt;
	At least 1 digit
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’ll then adjust the <code>PasswordRequirement</code> to contain a <code>label</code> in the form of a string resource integer, setting a resource for each of the requirement enums values that we previously defined.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PasswordRequirement</span>(
    <span class="syntax-all syntax-keyword">@StringRes</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>
) {
    <span class="syntax-all syntax-entity">CAPITAL_LETTER</span>(<span class="syntax-all syntax-entity">R</span>.string.requirement_capital),
    <span class="syntax-all syntax-entity">NUMBER</span>(<span class="syntax-all syntax-entity">R</span>.string.requirement_digit),
    <span class="syntax-all syntax-entity">EIGHT_CHARACTERS</span>(<span class="syntax-all syntax-entity">R</span>.string.requirement_characters)
}</code></pre>

<p>Within the state, we’ll need the current <code>PasswordRequirements</code> that are satisfied so that we can communicate this to the user. For this reason, we’ll add a new <code>passwordRequirements</code> field to our state that represents a list of requirements that have been met.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationState</span>(
	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">passwordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt; <span class="syntax-all syntax-keyword">=</span> emptyList()
)</code></pre>

<h2>Modelling the authentication mode</h2>

<p>The above gives us the key parts of the state that we need to allow the user to sign-up or sign-in to our application. However, we’re going to be doing a little more than that! Because a user can sign-up and sign-in to our application, we need to allow the form to be toggle-able between these two modes. To be able to represent this in our state we’re going to start by defining a new enum that will be used to signify whether the form is currently being used to sign up or sign in.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationMode</span> {
	<span class="syntax-all syntax-entity">SIGN_UP</span>, <span class="syntax-all syntax-entity">SIGN_IN</span>
}</code></pre>

<p>Now we can go ahead and add this to our state - this will then allow us to easily toggle between these two modes and have our UI recompose whenever the selected mode changes.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">passwordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt; <span class="syntax-all syntax-keyword">=</span> emptyList()
)</code></pre>

<h2>Modelling the loading state</h2>

<p>Now that our state represents both a sign-in and sign-up flow, we’re going to want to be able to handle the state when a user reaches the point of performing those operations. While we won’t be hitting an API in our UI example, in the real world this would be an asynchronous operation - meaning that we would have to wait a second or two for it to complete. In this scenario, we would want to show a progress indicator to the user so that they know a request is taking place. We’ll represent this in our state by adding a loading flag to the state class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">passwordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt; <span class="syntax-all syntax-keyword">=</span> emptyList(),
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">isLoading</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
)</code></pre>

<h2>Modelling the error state</h2>

<p>Once the loading of the request has been completed, we’ll want to handle the response that would come back from our API. In the case of success, we would navigate onto the next part of our application, but things might not always go as planned. In these cases, we’ll want to show an error to the user, usually in the form of the error that has come back from the API. To allow for this, we’ll add a new field to our state class which will represent if an error has occurred and at the same time, the content of that error.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span> <span class="syntax-all syntax-keyword">=</span>
		<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">passwordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt; <span class="syntax-all syntax-keyword">=</span> emptyList(),
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">isLoading</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<h2>Modelling the valid state</h2>

<p>As well as the content that can be entered into the input fields, the user can also delete this content. These fields themselves will also start blank, so in both of these states, we don’t want the user to be able to submit the form. We also want to block the form from being submitted if the password requirements have not been satisfied. To handle these cases we’ll add a new function to our state - this will return a boolean value that represents whether the form content is valid. We’re using a function for this so that the place that has the access to this state can easily check if the current state allows the user to proceed, instead of adding another value within our state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">passwordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt; <span class="syntax-all syntax-keyword">=</span> 
		emptyList(),
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">isLoading</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {
    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">isFormValid</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> {
        <span class="syntax-all syntax-keyword">return</span> password?.isNotEmpty() <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">true</span> <span class="syntax-all syntax-keyword">&amp;&amp;</span>
            email?.isNotEmpty() <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">true</span> <span class="syntax-all syntax-keyword">&amp;&amp;</span>
            (authenticationMode <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span> 			<span class="syntax-all syntax-keyword">||</span> passwordRequirements.containsAll(
					<span class="syntax-all syntax-entity">PasswordRequirements</span>.values().toList()))
    }
}</code></pre>

<p>With that in place, we now have a class that can be used to represent the state of our UI. Over the next few sections of this chapter, we’ll utilise this state when building out our UI, modifying its values as interactions with composables take place, triggering recompositions to reflect any state changes.</p>

<h1>Creating the Authentication ViewModel</h1>

<p>Now that we have the state modelled for our Authentication screen, we can start thinking about the ViewModel that will be used to manage that state and provide a way to orchestrate it to the user interface. </p>

<hr />

<h2>Setting up the ViewModel</h2>

<p>Before we can get started here, we’re going to add a new dependency to our project that will give us access to the Android Lifecycle ViewModel class:</p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span></code></pre>

<p>💡 You aren’t required to use a ViewModel when working with compose. For the sake of these exercises, it helps us to keep things simple and follow an approach that many developers are familiar with.</p>

<p>Next, we’ll create a new ViewModel, called <code>AuthenticationViewModel</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationViewModel.kt
</span><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

}</code></pre>

<p>This <code>ViewModel</code> is going to need to hold a reference to the state of our screen. For this we’re going to utilise <code>StateFlow</code> - this allows us to create a state-holder observable flow that will emit the default state we provide to it, along with any updates that occur during its lifetime. Here we’ll create a new <code>MutableStateFlow</code> instance, providing a reference to our <code>AuthenticationState</code> class as the default value for our <code>StateFlow</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {
	<span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">AuthenticationState</span>())
}</code></pre>

<p>With this in place, we now have a StateFlow reference that is holding a reference to our authentication state, initialising it with a new instance of the state class and relying on the defaults that the constructor provides.</p>

<hr />

<h2>Manipulating state using events</h2>

<p>While this state is now in place, we need to start thinking about the different ways in which it can be manipulated - whenever something is changed in our UI (text edited, button pressed), we’ll want to update the state within our ViewModel so that the observing UI can reflect those changes. </p>

<p>For when this is the case, we’re going to model some events that can be triggered in our composable UI and in turn these events will be used to manipulate the state within the view model. This allows us to have a single way of our composable UI communicating with the ViewModel, rather than needing to pass the entire ViewModel or many references to separate functions which could be used to trigger state changes. Instead, we can pass a single function reference to our composable UI which can then be used to trigger these events in the ViewModel. For these events we’re going to need to define different types that can be triggered, so we’ll go ahead and create a new sealed class to represent these.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationEvent.kt
</span><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span> {

}</code></pre>

<h2>Handling authentication mode toggling</h2>

<p>With this sealed class in place, we can start to think about using it to represent the different events that can occur. We’re going to start by handling the scenario where the authentication mode can be toggled between sign-up and sign-in. For this, we’ll create a new event called <code>ToggleAuthenticationMode</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> ToggleAuthenticationMode<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

}</code></pre>

<p>With this event in place, this can now be triggered from our composable UI to cause a state change within our view model. For that to happen though, we need to write this logic inside of our ViewModel. We’ll start here by creating a new function that will be used to ‘flip’ the current authentication mode - switching it between sign-up and sign-in.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">toggleAuthenticationMode</span>() {
    <span class="syntax-all syntax-keyword">val</span> authenticationMode <span class="syntax-all syntax-keyword">=</span> uiState.value.authenticationMode
    <span class="syntax-all syntax-keyword">val</span> newAuthenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
		authenticationMode <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>
	) {
    	<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>
    } <span class="syntax-all syntax-keyword">else</span> {
      	<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>
    }
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
      authenticationMode <span class="syntax-all syntax-keyword">=</span> newAuthenticationMode
    )
}</code></pre>

<p>With this code above, we take the current authentication mode within our authentication state and set it to the opposite value. We then use this to copy our existing authentication state, setting the authentication mode to reflect the newly calculated value. When this is done, the new value will be emitted to the observer of our live data - allowing our UI to be recomposed to reflect this new state. </p>

<p>💡 The copy function in Kotlin copies the existing class reference, replacing any values that have been provided as arguments to the function.</p>

<p>Now that we have this function available to handle the state change of the authentication mode, we need to go ahead and add support for triggering it from outside of our ViewModel. For this, we’ll add a new function to our ViewModel that will take a reference to an <code>AuthenticationEvent</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) {
	<span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
        
	}
}</code></pre>

<p>This function takes an <code>AuthenticationEvent</code> reference and then can use that to trigger the desired outcome, based on the event which has been provided to it. So in this case of the authentication mode toggle event, we’re going to trigger the <code>toggleAuthenticationMode</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) {
    <span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">ToggleAuthenticationMode</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            toggleAuthenticationMode()
        }
    }
}</code></pre>

<p>While we’re not going to implement the call to <code>handleEvent</code> until the next section of this chapter, our composable UI will be able to make the following call to trigger the authentication mode toggle:</p>

<pre><code class="code-highlighted code-kt">viewmodel.handleEvent(
	<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>
)</code></pre>

<h2>Handling input field changes</h2>

<p>With the authentication mode toggle in place, we can start thinking about the other events that we want to trigger from outside of our ViewModel. If we take a look at the authentication state model then we can see the other pieces of the state that we need to manipulate. Two key pieces of this state are the email address and password, these will represent the data that has been input by the user and will need to be reflected in our state whenever they change. For this, we’re going to add two more events to our Authentication Event sealed class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> ToggleAuthenticationMode<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">EmailChanged</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">emailAddress</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>):
      <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PasswordChanged</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>): 
      <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

}</code></pre>

<p>Here, we’ve added an <strong>EmailChanged</strong> event, along with a <strong>PasswordChanged</strong> event. These will allow the UI to trigger these events whenever the input of the email and password fields are changed. For that to be possible, we’ll go ahead and implement some functions in our ViewModel that allow for this state change to be reflected. We’ll start with a function, <code>updateEmail</code>, that will simply be used to update our state reference with the provided email address.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">updateEmail</span>(<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) {
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
    	email <span class="syntax-all syntax-keyword">=</span> email
	)
}</code></pre>

<p>When it comes to updating the password, we’ll need to create another new function, <code>updatePassword</code>, that will be used to update the password reference within our state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">updatePassword</span>(<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) {
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		password <span class="syntax-all syntax-keyword">=</span> password
	)
}</code></pre>

<p>However, whenever the password is updated we’ll always want to update the validity of the password requirements. For this, we’re going to create a new list that consists of <code>PasswordRequirements</code>, for which we’ll add references for the requirements that have been met. This list can then be set on our state so that the UI layer can be aware of the requirements that have been satisfied. When building this list of satisfied requirements, we’ll need to base this on several different constraints.</p>

<ul>
	<li>When the length of the password is greater than 7, this means that the minimum password length has been met. This means that we can add the <code>PasswordRequirements.EIGHT_CHARACTERS</code> to the list.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">if</span> (password.length <span class="syntax-all syntax-keyword">&gt;</span> <span class="syntax-all syntax-constant">7</span>) {
	requirements.add(<span class="syntax-all syntax-entity">PasswordRequirements</span>.<span class="syntax-all syntax-entity">EIGHT_CHARACTERS</span>)
}</code></pre>

<ul>
	<li>When the password contains an uppercase character, this means another one of our minimum requirements has been met. In this case, we’ll add the <code>PasswordRequirements.CAPITAL_LETTER</code> to the list.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">if</span> (password.any { it.isUpperCase() }) {
	requirements.add(<span class="syntax-all syntax-entity">PasswordRequirements</span>.<span class="syntax-all syntax-entity">CAPITAL_LETTER</span>)
}</code></pre>

<ul>
	<li>Finally, if the password contains any digit, this means that this requirement has been satisfied. In this case, we’ll add the <code>PasswordRequirements.NUMBER</code> value to the list.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">if</span> (password.any { it.isDigit() }) {
	requirements.add(<span class="syntax-all syntax-entity">PasswordRequirements</span>.<span class="syntax-all syntax-entity">NUMBER</span>)
}</code></pre>

<p>With this logic now defined, we can slot this into our <code>updatePassword</code> function and assign the result to the <code>passwordRequirements</code> within our <code>AuthenticationState</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">updatePassword</span>(<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) {

	<span class="syntax-all syntax-keyword">val</span> requirements <span class="syntax-all syntax-keyword">=</span> mutableListOf&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;()
    <span class="syntax-all syntax-keyword">if</span> (password.length <span class="syntax-all syntax-keyword">&gt;</span> <span class="syntax-all syntax-constant">7</span>) {
    	requirements.add(<span class="syntax-all syntax-entity">PasswordRequirements</span>.<span class="syntax-all syntax-entity">EIGHT_CHARACTERS</span>)
    }
    <span class="syntax-all syntax-keyword">if</span> (password.any { it.isUpperCase() }) {
    	requirements.add(<span class="syntax-all syntax-entity">PasswordRequirements</span>.<span class="syntax-all syntax-entity">CAPITAL_LETTER</span>)
    }
    <span class="syntax-all syntax-keyword">if</span> (password.any { it.isDigit() }) {
        requirements.add(<span class="syntax-all syntax-entity">PasswordRequirements</span>.<span class="syntax-all syntax-entity">NUMBER</span>)
    }
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		password <span class="syntax-all syntax-keyword">=</span> password,
        passwordRequirements <span class="syntax-all syntax-keyword">=</span> requirements.toList()
	)
}</code></pre>

<p>With these email and password functions in place, these can now be triggered via an event whenever the input is changed for either of those fields. We can then go ahead and add these function calls to our <code>handleEvent</code> function - now when the event is triggered outside of the ViewModel, the state can be updated based on the corresponding event.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) {
    <span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">ToggleAuthenticationMode</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            toggleAuthenticationMode()
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            updateEmail(authenticationEvent.emailAddress)
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">PasswordChanged</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            updatePassword(authenticationEvent.password)
        }
    }
}</code></pre>

<h2>Handling authentication triggers</h2>

<p>Now that users can toggle between authentication modes and enter their account credentials, naturally, the next step would be to allow the UI to trigger authentication. For this event we don’t need to send any data from the UI - this is because the entered email address and password are already reflected within our Authentication State. So here we can simply add another event type to our Authentication Event sealed class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> ToggleAuthenticationMode<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">EmailChanged</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">emailAddress</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PasswordChanged</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> Authenticate<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

}</code></pre>

<p>With this in place, we can next add a function that this event will be used to trigger. For this example, we won’t be triggering a network request, but instead will be responding to the authentication request from the UI and reflecting this via the loading property within the authentication state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">authenticate</span>() {
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		isLoading <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	)
    <span class="syntax-all syntax-comment">// trigger network request
</span>}</code></pre>

<p>With this function in place, we now have something that will simulate the network request taking place within our application. We can now also add this event type to our handleEvent function, allowing the Authenticate event to be triggered and handled from outside of our ViewModel.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) {
    <span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">ToggleAuthenticationMode</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            toggleAuthenticationMode()
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            updateEmail(authenticationEvent.emailAddress)
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">PasswordChanged</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            updatePassword(authenticationEvent.password)
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">Authenticate</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            authenticate()
        }
    }
}</code></pre>

<h2>Handling authentication errors</h2>

<p>With the above in place, we have a ViewModel that can handle the different required state properties and events that allow the user to enter their credentials, toggle between authentication modes and then proceed with triggering the authentication process. </p>

<p>However, we still have a final property from our Authentication State to handle - and that is the error. This property defaults to null within our state, so in that case, our UI won’t need to display any kind of error. But when this is not null, the UI will represent that error in some way and then also provide a way for it to be dismissed from view. So that we can simulate this scenario and then manage the expected state we will modify our <code>authenticate</code> function. </p>

<p>After we have emitted the loading state we’ll add a delay to simulate a network request, followed by removing the loading status and emitting an error message in the authentication state. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">authenticate</span>() {
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		isLoading <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	)
    viewModelScope.launch(<span class="syntax-all syntax-entity">Dispatchers</span>.<span class="syntax-all syntax-entity">IO</span>) {
        delay(<span class="syntax-all syntax-constant">2000L</span>)

        withContext(<span class="syntax-all syntax-entity">Dispatchers</span>.<span class="syntax-all syntax-entity">Main</span>) {
            uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
				isLoading <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
				error <span class="syntax-all syntax-keyword">=</span> “<span class="syntax-all syntax-entity">Something</span> went wrong<span class="syntax-all syntax-keyword">!</span>”
			)
        }
    }
}</code></pre>

<p>You’ll notice here that we’re hopping between coroutine dispatchers - while we’re not making a real network request there, this is to simulate a real scenario and ensure that the asynchronous work and live data emissions happen using the expected dispatchers. With this in place, the error will be emitted as part of the authentication state for the UI to reflect. While we haven’t created the UI yet, this error will be composed in the form of an alert dialog - this means that we will also need to be able to dismiss this dialog. To support this, the error of our state will need to be cleared so that the UI is recomposed the alert dialog is not a part of the composition. So that this can be cleared from our state from our UI, we’re going to add a new AuthenticationEvent called ErrorDismissed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> ToggleAuthenticationMode<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">EmailChanged</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">emailAddress</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PasswordChanged</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> Authenticate<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()

	 <span class="syntax-all syntax-keyword">object</span> ErrorDismissed<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>()
}</code></pre>

<p>With this in place, we are now able to receive error dismissal events from our UI layer, meaning that we also need to implement the state change for when this occurs. Here we’ll create a new function that will be used to simply clear the error</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">dismissError</span>() {
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		error <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
	)
}</code></pre>

<p>The last thing to do here is trigger this function whenever the ErrorDismissed event is triggered. For this, we’ll add a final check to our handleEvent when clause to trigger our function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) {
    <span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">ToggleAuthenticationMode</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            toggleAuthenticationMode()
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            updateEmail(authenticationEvent.emailAddress)
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">PasswordChanged</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            updatePassword(authenticationEvent.password)
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">Authenticate</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            authenticate()
        }
        <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">ErrorDismissed</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            dismissError()
        }
    }
}</code></pre>

<p>With this implemented, we are now managing the state of our authentication screen and providing the required entry points for our UI layer to manipulate the state based on user interaction. Our view model is now ready to be plugged into a composable UI, which we’ll create in the next section of this chapter!</p>

<h1>Creating the Authentication UI</h1>

<p>With the ViewModel and state management all in place, we’re ready to move on and start implementing the composable UI for our authentication screen. When we’re finished building this UI, we’re going to end up with something that looks like the following:</p>

<figure><img src="1-8.png"/></figure>

<p>This UI will give our users a screen that can be used to log in to an application - giving the option of performing either a sign-in or sign-up operation. While building this UI we’ll dive into the specifics of how the composables can be configured, along with adding some nice touches to improve the User Experience of our Authentication screen.</p>

<hr />

<h2>Setting up the entry point</h2>

<p>Before we can get start building our project, we’re going to need to add a couple of dependencies that we’re going to need. We’ll start here by adding these to the <code>build.gradle</code> file for our new project:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// provides access to the `ComponentActivity` class that can be used to compose UI components
</span>implementation &#39;androidx.activity<span class="syntax-all syntax-keyword">:</span>activity<span class="syntax-all syntax-keyword">-</span>compose<span class="syntax-all syntax-keyword">:</span><span class="syntax-all syntax-constant">1.4</span>.<span class="syntax-all syntax-constant">0</span>&#39;

<span class="syntax-all syntax-comment">// foundational classes from the Compose APIs
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.foundation:foundation:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// UI components from the Compose APIs
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Material Design components from the Compose APIs
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Provides an extended collection of Material Iconography
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material-icons-extended:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Tooling functionality for Composables, such as previews
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-tooling-preview:$compose_version&quot;</span>
debugImplementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-tooling:$compose_version&quot;</span></code></pre>

<p>The current release of this book is building against 1.1.0 of compose - be sure to check compatibly if using a newer version.</p>

<p>With these added to our project, we’re now ready to start building out our UI. We’re going to start here by building the access point to our feature - this is how the messaging feature will initially be composed within our user interface. </p>

<p>Here we’ll begin by building a root composable function, <code>Authentication</code> that will be used to house all of our Composable UI for the Authentication screen. For this, we’ll create a new Kotlin file called <code>Authentication.kt</code> (to keep our composables nicely organised), followed by creating a new composable function, <code>Authentication</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Authentication.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authentication</span>() { }</code></pre>

<p>This composable is going to be the entry point to our Authentication screen - so we don’t want this function to have to take any arguments. The point that is navigating to authentication will be able to just compose this function, and this composable will handle everything else. While you won’t see anything visual just yet, you’ll want to compose this <code>Authentication</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Authentication</code> when running the project.</p>

<p>Within this root level composable we’re going to want to force our application theme on the composables that are contained inside of it, so we’ll add a <code>MaterialTheme</code> composable declaration here.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authentication</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        
    }
}</code></pre>

<p>💡Wrapping your composable hierarchy in a theme allows all components to be consistently styled. In most cases, this can happen at the highest point of composition - even within the setContent function of the parent activity that is composing the UI.</p>

<p>This now means that for any of the composables that are composed in the content block of our <code>MaterialTheme</code>, these will be themed according to the colors and styles that are declared within our theme.</p>

<p>Saying that though, we don’t currently have any composables that are going to make up the content of our authentication form. We’ll go ahead and create a new composable function here, <code>AuthenticationContent</code>. The difference here is that this composable is going to be responsible for composing our UI based on the state of the screen, meaning that this function <strong>is</strong> going to take some form of argument. Because it’s composing UI based on our state, it’s also going to need to propagate any events so that the state can be updated accordingly. For this reason, it’s also going to need to be able to handle the <code>AuthenticationEvent</code> types that we previously defined. We’ll need to define two additional arguments for our composable to satisfy these requirements.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationContent</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
  	<span class="syntax-all syntax-parameter">authenticationState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationState</span>,
  	<span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {

}</code></pre>

<p>💡 It’s good practice to allow a modifier to be passed into a composable, this means that the parent who is composing the child can control the composition to some extent. This also helps to keep your composable functions re-usable across your UI.</p>

<p>This composable will take an <code>AuthenticationState</code> that represents the state of our screen, along with an event handler that allows us to pass up <code>AuthenticationEvent</code> instances when they are triggered.</p>

<p>So, why can’t this just be the entry point to our authentication screen? One clear thing here is that this decouples the composable with being concerned about how the state is provided - passing in the state via an argument makes it simpler, as in, it gets passed a state and composes UI based on it. This also makes it much easier to write tests our composable - because we can simply pass it a state object and perform assertions based on that, rather than needing to simulate user actions and perform mocking to produce expected states.</p>

<p>With this composable defined, we can then hop up to the root <code>Authentication</code> that we defined and compose the <code>AuthenticationContent</code> within our theme block.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authentication</span>() {

    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">AuthenticationContent</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            authenticationState <span class="syntax-all syntax-keyword">=</span> ...,
            handleEvent <span class="syntax-all syntax-keyword">=</span> ...
        )
    }
}</code></pre>

<p>Things aren’t quite satisfied here yet though, we need to provide both the state and event handler to our <code>AuthenticationContent</code>. We’ll be using our <code>AuthenticationViewModel</code> that we created in the previous sections to satisfy these arguments, so we’ll first need to retrieve an instance of this. So that we can access this information, we’re going to need to obtain an instance to this ViewModel inside of our composable. Here we’ll use the <code>viewModel</code> function from the <code>lifecycle-viewmodel-compose</code> package. This will retrieve an instance of the desired ViewModel, creating one if it does not currently exist. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()</code></pre>

<p>We can then use this ViewModel within our root composable for our required arguments.</p>

<ul>
	<li>We’ll use <code>collectAsState()</code> to collect the emissions of our <code>StateFlow</code> reference from our ViewModel as composable state. We’ll then pass the value of this emission as the state reference to our composable.</li>
	<li>For event handling, our ViewModel contains a function that matches the requirements of our lambda function argument. We can pass this function reference directly to our composable using <code>viewModel::handleEvent</code>.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authentication</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()

    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">AuthenticationContent</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            authenticationState <span class="syntax-all syntax-keyword">=</span>
				viewModel.uiState.collectAsState().value,
            handleEvent <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::handleEvent
        )
    }
}</code></pre>

<p>With this in place, we have a composable function that will house the composables making up our authentication UI. As you might remember from when we created the AuthenticationState, there’s a lot to take into account when it comes to the UI. While there is plenty of space for there to be more complexity and conditions to think about in regards to the state, we have plenty to think about here when it comes to building the actual UI. When it comes to this, we’re going to need to break that down into a Composable representation.</p>

<figure><img src="intro-1.png"/></figure>

<p>• A Parent Box to hold the different composables that make up our authentication screen</p>

<p>• A Progress Indicator to signify the loading state of the screen</p>

<p>• An authentication form composable that will hold the input fields, buttons and other form components</p>

<p>• An Alert Dialog used to display authentication error messages</p>

<p>With the above in mind, we can start building out our Composable UI to represent our authentication screen. We’re going to build a collection of composable functions, all of which can be plugged together to create the complete screen.</p>

<hr />

<h2>Defining the Parent Container</h2>

<figure><img src="two.png"/></figure>

<p>We begin at the start of the above illustration, the parent <code>Box</code> composable. Because our UI can show three different child composables, we need a container to house those. Other than the authentication form, we’re going to be displaying either a progress indicator (which needs to be displayed in the center of the parent) or an alert dialog (which will be shown over the top of the authentication form), we need these to be placed in a container to allow support for these different scenarios. The <code>Box</code> composable provides support for the alignment of child composables, as well as the ability to show overlapping composables - which makes it perfect for what we need.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationContent</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-entity">Box</span> {

	}
}</code></pre>

<p>Here we’ve defined an empty <code>Box</code>, which is enough to allow us to display child composables inside of it. However, we need to provide some properties to have the <code>Box</code> fill the entire available space on-screen, while also providing alignment for any children that it displays.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
  modifier <span class="syntax-all syntax-keyword">=</span> modifier,
  contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
) {

}</code></pre>

<p>Here we use the <code>fillMaxSize</code> modifier to have the Box fill all of the available space on the screen (both the width and height within its parent), along with using the <code>contentAlignment</code> argument to align all of its children in the center of the <code>Box</code>.</p>

<hr />

<h2>Display a Progress State</h2>

<figure><img src="progress.png"/></figure>

<p>Before we go ahead and start showing content to users, we’re going to think about the state that occurs beforehand - which is when a loading indicator will be displayed to users. We’re going to start here by using the <code>isLoading</code> property from our AuthenticationState reference. Using this we’re either going to want to show a progress indicator or go on to display content to the user. To handle these different scenarios, we’ll start by adding an if statement that checks the status of this loading flag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
  modifier <span class="syntax-all syntax-keyword">=</span> modifier,
  contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
) {
	<span class="syntax-all syntax-keyword">if</span> (authenticationState.isLoading) {
    
	} <span class="syntax-all syntax-keyword">else</span> {

	}
}</code></pre>

<p>With this in place, we can now decide whether to compose the loading state or the content state. Here we’re just going to tackle the loading state of our UI, so we’ll go ahead and utilise one of the available progress indicator composables - the <code>CircularProgressIndicator</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">if</span> (authenticationState.isLoading) {
  <span class="syntax-all syntax-entity">CircularProgressIndicator</span>()
} <span class="syntax-all syntax-keyword">else</span> {

}</code></pre>

<p>If we do not provide a progress value to the CircularProgressIndicator then the indicator is composed as an indeterminate indicator, meaning that it will spin indefinitely while it is displayed on the screen. This is fine for our requirements, as we’re just going to show it on screen until the content is loaded. If you need to display a specific progress value on the indicator, you can provide this progress value to the composable so that the indicator can be composed to represent that current progress.&nbsp;</p>

<hr />

<h2>Displaying the Login Content</h2>

<figure><img src="Login.png"/></figure>

<p>Even though now we have a progress indicator in place for our login screen, this isn’t something we’re going to be displaying until the user has triggered the authentication flow. So that we can have this be triggered, we’re now going to go ahead and build out the authentication form UI. We’ll need to start here by creating a new composable function that will be used to house our authentication form.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>Inside of this, we’re going to start here by defining a <code>Column</code> composable - our authentication form is going to represent a vertical stack of components, so a <code>Column</code> is most appropriate for this. When composing this <code>Column</code>, we’ll pass the <code>Modifier</code> reference that was provided to our <code>AuthenticationForm</code> composable to apply the provided constraints to this parent composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

	}
}</code></pre>

<p>Looking at the design of the screen, we’re also going to want all of the child composables to be positioned in the center horizontally. For this we’ll utilise the <code>horizontalAlignment</code> argument, providing <code>CenterHorizontally</code> as the value to be used for alignment. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
  		horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
	) {

	}
}</code></pre>

<p>With this in place, we now have a <code>Column</code> that will be used to house the contents of our login form.</p>

<hr />

<h2>Adding the Authentication Title</h2>

<figure><img src="title.png"/></figure>

<p>We’ll start first by adding the title for our authentication form - this will display a header that will state that the user can either <strong>sign in</strong> or <strong> sign up</strong>, depending on the current state of the screen. So that we can display this title, we’ll need to begin by adding two new strings to our <code>strings.xml</code> file:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_sign_in_to_account&quot;</span>&gt;
	Sign In to your account
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_sign_up_for_account&quot;</span>&gt;
	Sign Up for an account
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’re not going to use these just yet, but at least they’re now in place for when it comes to slotting them into our UI. So that we can start building out our authentication title, we’ll need to create a new composable function, <code>AuthenticationTitle</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationTitle.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationTitle</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>And so that this knows what title needs to display, it’s going to need to know the current <code>AuthenticationMode</code> of the screen - which we’ll pass in as an argument to the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationTitle</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
)</code></pre>

<p>Next, we’ll build out a minimal Text composable using a string retrieved from one of the previously added string resources. The <code>AuthenticationMode</code> reference we have depicts whether the user is currently signing-in or signing-up. Based on this mode we want to set the title of the screen, so it is clear to the user whether they are signing-in or signing-up. Using the provided <code>AuthenticationMode</code> we’ll set the resource to be used for our <code>Text</code> composable. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationTitle</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(
        text <span class="syntax-all syntax-keyword">=</span> stringResource(
            <span class="syntax-all syntax-keyword">if</span> (authenticationMode <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>) {
                <span class="syntax-all syntax-entity">R</span>.string.label_sign_in_to_account
            } <span class="syntax-all syntax-keyword">else</span> {
                <span class="syntax-all syntax-entity">R</span>.string.label_sign_up_for_account
            }
        )
    )
}</code></pre>

<p>Our title will now be displaying a string based on the <code>AuthenticationMode</code> that is provided to the function.</p>

<figure><img src="2-6.png"/></figure>

<p>Because this Text composable is the title of the screen, we’re going to want to style the text according to the theme of our application. Here we’re going to apply a <code>fontSize</code> to our <code>Text</code> composable that feels a bit more fitting for a title. We’ll do this by passing the value of <code>24.sp</code> to the <code>fontSize</code> argument of the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Text</span>(
	text <span class="syntax-all syntax-keyword">=</span> stringResource(
    	<span class="syntax-all syntax-keyword">if</span> (authenticationState.authenticationMode <span class="syntax-all syntax-keyword">==</span>
        	<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>) {
      		<span class="syntax-all syntax-entity">R</span>.string.label_sign_in_to_account
    	} <span class="syntax-all syntax-keyword">else</span> {
      		<span class="syntax-all syntax-entity">R</span>.string.label_sign_up_for_account
    	}
  	),
	fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">24</span>.sp
)</code></pre>

<p>We’ll also adjust the <code>fontWeight</code> of our composable - this will help to make it stand out a bit more at the top of our UI. We don’t want this to be too bold when displayed, so we’ll apply the weight as the <code>FontWeight.Black</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Text</span>(
	text <span class="syntax-all syntax-keyword">=</span> stringResource(
    	<span class="syntax-all syntax-keyword">if</span> (authenticationState.authenticationMode <span class="syntax-all syntax-keyword">==</span>
        	<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>) {
      		<span class="syntax-all syntax-entity">R</span>.string.label_sign_in_to_account
    	} <span class="syntax-all syntax-keyword">else</span> {
      		<span class="syntax-all syntax-entity">R</span>.string.label_sign_up_for_account
    	}
  	),
	fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">24</span>.sp,
	fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Black</span>
)</code></pre>

<figure><img src="3-5.png"/></figure>

<p>Now that our title is styled, we can go ahead and compose it within our UI. Before we go ahead and compose it inside of our <code>AuthenticationForm</code>, we need to ensure there is access to an <code>AuthenticationMode</code> reference that our title can use. We’re going to be passing this from our state, so we’ll need to first add this as an argument to our <code>AuthenticationForm</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
)</code></pre>

<p>Followed by passing this into our <code>AuthenticationForm</code> function at the point of composition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationContent</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	...

	<span class="syntax-all syntax-entity">AuthenticationForm</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
		authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationState.authenticationMode
	)

	...
}</code></pre>

<p>Hopping back over to our <code>AuthenticationForm</code> composable, we can then compose our <code>AuthenticationTitle</code> and pass in the required <code>AuthenticationMode</code> reference that is now accessible from the authentication form.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
		<span class="syntax-all syntax-entity">AuthenticationTitle</span>(
			authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode
		)
	}
}</code></pre>

<p>To create a bit of visual spacing at the top of our UI, we’ll also add a <code>Spacer</code> composable, sized with a height of <code>32dp</code> via the use of the <code>height</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">32</span>.dp))
		<span class="syntax-all syntax-entity">AuthenticationTitle</span>(
			authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode
		)
	}
}</code></pre>

<p>With this in place, the title for our authentication form is now being composed within our UI - this title is then composed based on the current <code>AuthenticationMode</code> that is within our state.</p>

<figure><img src="3-6.png"/></figure>

<hr />

<h2>Creating the input container</h2>

<figure><img src="container.png"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</figure>

<p>With our title now in place, we can go ahead and start putting together the area that will be used to hold the components for the form input area. As seen in the end goal of our design, and the composable structure in the diagram above, this is all going to be contained within a <code>Card</code> component. The <code>Card</code> is a composable used to hold child components in a <code>Card</code> shaped container, often elevated from the surface that it is displayed on top of.</p>

<p>We’re still going to be working within the <code>AuthenticationForm</code> composable that we previously defined, continuing composition from where we last added the <code>AuthenticationTitle</code>. Before we add our <code>Card</code>, we’re going to start by adding another <code>Spacer</code> composable, this time beneath our <code>AuthenticationTitle</code> declaration - this is so that our <code>Card</code> does not end up pressed up right against the bottom of our title.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">32</span>.dp))
		<span class="syntax-all syntax-entity">AuthenticationTitle</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode
		)

		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">40</span>.dp))
	}
}</code></pre>

<p>With this in place, we can now add the declaration for our <code>Card</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">32</span>.dp))
		<span class="syntax-all syntax-entity">AuthenticationTitle</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode
		)

		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">40</span>.dp))

		<span class="syntax-all syntax-entity">Card</span> {
			<span class="syntax-all syntax-entity">Column</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
				horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
			) {

			}
		}
	}
}</code></pre>

<p>The <code>Card</code> composable only has one required argument, which is the <code>content</code> of the composable. Under the hood, the <code>Card</code> utilises a <code>Surface</code> which in turn uses a <code>Box</code> to contain the <code>content</code> that we provide it with. However, we are going to be stacking content vertically - something that we can’t achieve from relying on the <code>Box</code> here. We’ll compose a <code>Column</code> within the <code>content</code> of our <code>Card</code> composable, which will allow us to then compose our children inside of the <code>Column</code>, achieving the result of vertically stacked composables. When adding this we’ll also apply some styling so that the <code>Column</code> has some padding applied to it, along with aligning its children horizontally in the center via the use of its <code>horizontalAlignment</code> argument.</p>

<p>Next, we’re going to add some constraints to our <code>Card</code> using modifiers. As seen in the design, we want the <code>Card</code> to fill the maximum width of our screen, but with some spacing around the outside so that it isn’t pressing against the edges of the screen. To fill the width of the area we’ll use the <code>fillMaxWidth</code> modifier, along with the <code>padding</code> modifier to apply horizontal padding to the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Card</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxWidth()
		.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">32</span>.dp)
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
		horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
	) {

	}
}</code></pre>

<p>Currently, our card won’t look like much, but we’d be able to see something like the following currently.</p>

<figure><img src="5-5.png"/></figure>

<p>By default the <code>Card</code> uses an elevation value of <code>1dp</code>, which we can see doesn’t make our card too visible on the surface background. Here we’re going to increase this to <code>4dp</code> by overriding the default value by passing in our own value via the <code>elevation</code> argument of the <code>Card</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Card</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxWidth()
		.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">32</span>.dp),
	elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
) {

}</code></pre>

<p>We can see now that our <code>Card</code> has greater padding applied to it.</p>

<figure><img src="6-3.png"/></figure>

<p>With this in place, we now have an area that is configured for our form input area. At this point, our <code>AuthenticationForm</code> composable should look something like the following.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">32</span>.dp))
		<span class="syntax-all syntax-entity">AuthenticationTitle</span>(
			authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode
		)
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">40</span>.dp))
		<span class="syntax-all syntax-entity">Card</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
				.fillMaxWidth()
				.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">32</span>.dp),
			elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
		) {
			<span class="syntax-all syntax-entity">Column</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
				horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
			) {

			}
		}
	}
}</code></pre>

<hr />

<h2>Displaying the Email Address Input Field</h2>

<figure><img src="email.png"/></figure>

<p>Now that we have the <code>Card</code> in place to hold our input form, we can now think about moving ahead with adding the first of our input fields - the Email Input. We’ll start here by creating a new composable, <code>EmailInput</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// EmailInput.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>For the email input, we’re going to explore the use of the <code>TextField</code> composable, which we can add directly to our composable function. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-entity">TextField</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier)
}</code></pre>

<p>You’ll notice at this point the IDE will give you a warning, that’s because the <code>TextField</code> requires two arguments for the function to be satisfied. These are the value (that represents the current value to be displayed in the textfield) and the value change handler (triggered when the input changes and used to update the composable state). We’ll need to satisfy these before we can continue, so let’s start by focusing on the required value argument.</p>

<p>Within our authentication state, we have an email address property, which represents the currently entered email address from the user. We’re going to need to use this piece of state for our email input field - so we’ll need to pass it into our <code>EmailInput</code> composable and assign it to the <code>value</code> argument of the <code>Textfield</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>
) {
	<span class="syntax-all syntax-entity">TextField</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> email <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
	)
}</code></pre>

<p>When present, this will be shown as the current input value in our email address field and if this state changes, then the <code>TextField</code> value will be updated to reflect that change. However, we are not currently providing a way for our state to be changed - so this recomposition is never going to occur. To fix this, let’s implement an argument in the form of a lambda function that allows us to hoist the latest entered email up out of our composable function. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We can then use this lambda to trigger the state hoisting, providing a function call within the <code>onValueChange</code> block.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">TextField</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> email <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
		onValueChange <span class="syntax-all syntax-keyword">=</span> { email <span class="syntax-all syntax-keyword">-&gt;</span>
            onEmailChanged(email)
        }
	)
}</code></pre>

<p>This means that our email address will be passed up and out of our composable function, allowing us to update the state of our screen when it comes to implementing that part of the project.</p>

<p>At this point, we have an email input field that is being displayed inside of our composable function. It’s very minimal, but it’s enough to allow user input.</p>

<figure><img src="11.png"/></figure>

<h3>Adding a label to the email input field</h3>

<p>At the moment out input field looks a little blank, and it isn’t too clear what the input field is to be used for. To add some clarity here, we’re going to utilise the <code>label</code> argument to provide a composable that will act as a label. We’re going to want this to simply read “Email Address”, so we’ll need to add a new string resource to our project:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_email&quot;</span>&gt;Email Address&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then go ahead and compose a <code>Text</code> composable for the <code>label</code> of our <code>TextField</code>, passing this string resource as the content of that composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">TextField</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> email <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
		onValueChange <span class="syntax-all syntax-keyword">=</span> { email <span class="syntax-all syntax-keyword">-&gt;</span>
            onEmailChanged(email)
        },
		label <span class="syntax-all syntax-keyword">=</span> { 
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_email)
			) 
		}
	)
}</code></pre>

<p>With this in place, our <code>TextField</code> is now displaying a label that adds clarity for what the field is to be used for.</p>

<figure><img src="22.png"/></figure>

<h3>Enforcing the supported number of lines</h3>

<p>If we have a little play with the input field, we might notice that if we provide an input that exceeds the length of the input field, the text will start to expand onto multiple lines. </p>

<figure><img src="33.png"/></figure>

<p>We don’t want this as it’s not an expected behaviour for this kind of form. We can fix this by utilising the <code>singleLine</code> argument of the composable, allowing us to enforce all entered text to remain on a single line - the composable will allow horizontal navigation to move through an entered string when this is enabled.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">TextField</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> email <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
		onValueChange <span class="syntax-all syntax-keyword">=</span> { email <span class="syntax-all syntax-keyword">-&gt;</span>
            onEmailChanged(email)
        },
		label <span class="syntax-all syntax-keyword">=</span> { 
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_email)
			) 
		},
		singleLine <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	)
}</code></pre>

<p>We can see now that with this being enforced, our <code>TextField</code> behaves in a much more expected way.</p>

<figure><img src="44.png"/></figure>

<h3>Adding some iconography</h3>

<p>Our Email Input is feeling good at this point, but we’re going to add a small piece of visual decoration by utilising the <code>leadingIcon</code>. This argument allows us to provide a composable that will be displayed at the <strong>start</strong> of the input field. For this, we’re going to use an <code>Icon</code> composable to display an email icon - this won’t serve any real purpose other than being a visual decoration. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TextField</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> email,
        onValueChange <span class="syntax-all syntax-keyword">=</span> { email <span class="syntax-all syntax-keyword">-&gt;</span>
            onEmailChanged(email)
        },
		label <span class="syntax-all syntax-keyword">=</span> { 
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_email)
			) 
		},
		singleLine <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
        leadingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Email</span>, 			
				contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
			)
        }
    )
}</code></pre>

<p>Because this is just a visual decoration, we don’t need to provide a <code>contentDescription</code> for our <code>Icon</code>. The email input field also has a label that describes the purpose of the field, so we can rely on that for describing the component to the user. With this in place, we can now see an email icon is displayed at the start of the input field.</p>

<figure><img src="55.png"/></figure>

<h3>Composing the Email Input field</h3>

<p>Now that our email input is complete, we can go ahead and compose it within our UI. Before we go ahead and compose it inside of our <code>AuthenticationForm</code>, we need to ensure there is access to both an <code>email</code> and <code>onEmailChange</code> reference that the composable can use. We’re going to be passing this from our state, so we’ll need to first add these as arguments to our <code>AuthenticationForm</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Along with then passing this into our <code>AuthenticationForm</code> function at the point where it is being composed. For the <code>email</code> field we can pass the email address reference from within our screen state, while for the <code>onEmailChange</code> we’ll need to trigger an <code>AuthenticationEvent</code> by using our <code>handleEvent</code> lambda. When calling this, we’ll utilise the <code>EmailChanged</code> event type - instantiating a reference by providing the email address that is passed through the callback.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationContent</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	...

	<span class="syntax-all syntax-entity">AuthenticationForm</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
		authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationState.authenticationMode,
		email <span class="syntax-all syntax-keyword">=</span> authenticationState.email,
    	onEmailChanged <span class="syntax-all syntax-keyword">=</span> { email <span class="syntax-all syntax-keyword">-&gt;</span>
			handleEvent(
				<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span>(email))
		}	
	)

	...
}</code></pre>

<p>Hopping back over to our <code>AuthenticationForm</code> composable, we can then compose our <code>EmailInput</code> and pass in the required <code>email</code> and <code>onEmailChanged</code> references that are now accessible from the authentication form.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
    ) {
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">32</span>.dp))
        <span class="syntax-all syntax-entity">AuthenticationTitle</span>(
			authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode)

        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">40</span>.dp))
        <span class="syntax-all syntax-entity">Card</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">32</span>.dp),
            elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
        ) {
            <span class="syntax-all syntax-entity">Column</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
                horizontalAlignment <span class="syntax-all syntax-keyword">=</span> 		
					<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
            ) {
                <span class="syntax-all syntax-entity">EmailInput</span>(
					modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
					email <span class="syntax-all syntax-keyword">=</span> email <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>, 
					onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged
				)
            }
        }
    }
}</code></pre>

<p>We’re going to make a small tweak here to customise how the <code>EmailInput</code> is composed within our UI. When creating the composable, we added support for an optional modifier. We’re going to utilise this argument so that we can force the email input field to fill the available width, which is the width of the parent <code>Column</code>. For this, we’ll utilise the <code>fillMaxWidth</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">EmailInput</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	email <span class="syntax-all syntax-keyword">=</span> email <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>, 
	onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged
)</code></pre>

<p>With this in place, the email input field for our authentication form is now being composed within our UI - the content of this is then composed based on the current <code>email</code> that is within our state, which in turn is then updated via the use of our <code>onEmailChanged</code> lambda function.</p>

<figure><img src="66.png"/></figure>

<hr />

<h2>Displaying the Password Input Field</h2>

<figure><img src="Password.png"/></figure>

<p>Now that we have our email input field, we’re going to want to create a similar component, except this time for the entry of a password. A lot of this component is going to be the same as our previously created composable, so we’re going to start by duplicating what we have so far, adapting it for password entry.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PasswordInput</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">TextField</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> password,
        onValueChange <span class="syntax-all syntax-keyword">=</span> {
            onPasswordChanged(it)
        },
		singleLine <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
		label <span class="syntax-all syntax-keyword">=</span> { 
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_password)
			) 
		}
        leadingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Lock</span>, 
				contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
			)
        }
	)
}</code></pre>

<p>We can see a couple of differences here:</p>

<ul>
	<li>We pass some slightly different arguments into the composable. This time in the form of a <code>password</code> and <code>onPasswordChanged</code> callback.</li>
	<li>We now call this <code>onPasswordChanged</code> whenever the password entry has changed</li>
	<li>The <code>leadingIon</code> for our composable is utilising the <code>Lock</code> icon</li>
</ul>

<p>We are also using a slightly different label for our input field, which will need to be added to our <code>strings.xml</code> resource file before we can continue.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_password&quot;</span>&gt;Password&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>At this point we’ll have a simple input field that can be used for our password:</p>

<figure><img src="pa.png"/></figure>

<p>Now that we have the similarities implemented, we can go ahead and think about the things that make our input field slightly different from the email input.</p>

<h3>Toggling password visibility</h3>

<p>One common thing in password input fields is the ability to toggle between visibilities of the entered password. We’re going to implement this for our <code>PasswordInput</code> composable, but to do so we’re going to need some form of state that allows our composable to know how the password field should be composed. We’ll need to add a piece of mutable state to our composable, <code>isPasswordHidden</code>. We’ll default this to <strong>false</strong> for security reasons, followed by wrapping this in <code>remember</code> so that the value is persisted across recompositions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PasswordInput</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {

	<span class="syntax-all syntax-keyword">var</span> isPasswordHidden by remember {
        mutableStateOf(<span class="syntax-all syntax-constant">true</span>)
    }
	
	<span class="syntax-all syntax-entity">TextField</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> password <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
        onValueChange <span class="syntax-all syntax-keyword">=</span> {
            onPasswordChanged(it)
        },
		singleLine <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
		label <span class="syntax-all syntax-keyword">=</span> { 
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_password)
			) 
		}
        leadingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Lock</span>, 
				contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
			)
        }
	)
}</code></pre>

<p>💡 Not all pieces of our state need to be declared at a global level. This password visibility state is specific to this composable function, so coupling this here is something that makes sense for us to do.</p>

<p>With this state in place, we can now utilise this to compose our UI. The first thing we’re going to do is utilise the <code>trailingIcon</code> of the <code>TextField</code> composable. We’ll start by composing a new <code>Icon</code>, whose content will depend on the current state of <code>isPasswordHidden</code> When the password is being hidden we want to show an icon that indicates the visibility is disabled, while on the other hand, we want to indicate that the password is currently visible. For now, we’ll use a <strong>null</strong> <code>contentDescription</code>, as we’ll be implementing that piece of logic shortly.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
		<span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Visibility</span>
	} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">VisibilityOff</span>,
	contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>So that this icon is intractable by the user, we’re going to want to enable click events. Using the <code>clickable</code> modifier we can toggle the <code>isPasswordHidden</code> state so that when the icon is clicked, this state flag is flipped to the opposite value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.clickable {
		isPasswordHidden <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!is</span>PasswordHidden
	},
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
		<span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Visibility</span>
	} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">VisibilityOff</span>
)</code></pre>

<p>This means that now when our <code>Icon</code> is clicked, the state flag will be flipped and our <code>Icon</code> will be recomposed to reflect this state change.</p>

<figure><img src="paaa.png"/></figure>

<p>With this in place, we have a functioning icon that can be interacted with by the user. However, at this point are icon isn’t very accessible - the click event is in place has no form of description, meaning that accessibility services will not be aware of the purpose of this component. What we’ll do here is utilise the <code>onClickLabel</code> of the <code>clickable</code> modifier so that we can provide a description based on the current <code>isPasswordHidden</code> state. We’ll need to start here by adding two new string resources to our <code>strings.xml</code> resources:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_show_password&quot;</span>&gt;Show Password&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_hide_password&quot;</span>&gt;Hide Password&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With these in place, we can now apply a label to our <code>click</code> modifier. We’ll utilise the <code>stringResource</code> composable function here to provide a string resource based on the current value of our state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.clickable(
		onClickLabel <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
			stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.cd_show_password)
			} <span class="syntax-all syntax-keyword">else</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.cd_hide_password)
		) {
			isPasswordHidden <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!is</span>PasswordHidden
		},
	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
		<span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Visibility</span>
	} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">VisibilityOff</span>,
		contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>With this description applied, we now have a completed <code>Icon</code> composable that can be slotted into the <code>trailingIcon</code> block of our <code>TextField</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PasswordInput</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> isPasswordHidden by remember {
        mutableStateOf(<span class="syntax-all syntax-constant">true</span>)
    }
    <span class="syntax-all syntax-entity">TextField</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> password <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
        singleLine <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
        onValueChange <span class="syntax-all syntax-keyword">=</span> {
            onPasswordChanged(it)
        },
        leadingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Lock</span>, 
				contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
			)
        },
        trailingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Icon</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.clickable(
                    onClickLabel <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
                        stringResource(id <span class="syntax-all syntax-keyword">=</span> 
							<span class="syntax-all syntax-entity">R</span>.string.cd_show_password)
                    } <span class="syntax-all syntax-keyword">else</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
							<span class="syntax-all syntax-entity">R</span>.string.cd_hide_password)
                ) {
                    isPasswordHidden <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!is</span>PasswordHidden
                },
                imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
                    <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Visibility</span>
                } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">VisibilityOff</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
            )
        },
        label <span class="syntax-all syntax-keyword">=</span> { 
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_password)) 
		}
    )
}</code></pre>

<p>While we’ve implemented the functionality to now toggle this state flag, it’s not being used yet to affect the visibility of the password field content. For these scenarios, the TextField contains a <code>visualTransformation</code> property that can be used to provide a class that can provide a transformation to the input content. Compose comes with a password transformation out of the box in the form of the <code>PasswordVisualTransformation</code> class, which can be provided for the <code>visualTransformation</code> property.</p>

<p>Here we’re going to want to provide the <code>PasswordVisualTransformation</code> when the password should be masked, and <code>VisualTransformation.None</code> otherwise.</p>

<pre><code class="code-highlighted code-kt">visualTransformation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
	<span class="syntax-all syntax-entity">PasswordVisualTransformation</span>()
} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">VisualTransformation</span>.<span class="syntax-all syntax-entity">None</span></code></pre>

<p>We can then slot this into our <code>TextField</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PasswordInput</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> isPasswordHidden by remember {
        mutableStateOf(<span class="syntax-all syntax-constant">true</span>)
    }
    <span class="syntax-all syntax-entity">TextField</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> password <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
        singleLine <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
        onValueChange <span class="syntax-all syntax-keyword">=</span> {
            onPasswordChanged(it)
        },
        leadingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Lock</span>, 
				contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
			)
        },
        trailingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Icon</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.clickable(
                    onClickLabel <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
                        stringResource(id <span class="syntax-all syntax-keyword">=</span> 
							<span class="syntax-all syntax-entity">R</span>.string.cd_show_password)
                    } <span class="syntax-all syntax-keyword">else</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
							<span class="syntax-all syntax-entity">R</span>.string.cd_hide_password)
                ) {
                    isPasswordHidden <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!is</span>PasswordHidden
                },
                imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isPasswordHidden) {
                    <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Visibility</span>
                } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">VisibilityOff</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
            )
        },
        label <span class="syntax-all syntax-keyword">=</span> { 
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_password)) 
		}
    )
}</code></pre>

<p>When toggling this, we will now be able to see the password content flipping from visible to masked.</p>

<figure><img src="paa.png"/></figure>

<p>Now that our password input is complete, we can go ahead and compose it within our UI. Before we go ahead and compose it inside of our <code>AuthenticationForm</code>, we need to ensure there is access to both a <code>password</code> and <code>onPasswordChanged</code> reference that the composable can use. We’re going to be passing this from our state, so we’ll need to first add these as arguments to our <code>AuthenticationForm</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Along with then passing this into our <code>AuthenticationForm</code> function at the point where it is being composed. For the <code>password</code> we can pass the password reference from within our screen state, while for the <code>onPasswordChanged</code> we’ll need to trigger an <code>AuthenticationEvent</code> by using our <code>handleEvent</code> lambda. When calling this, we’ll utilise the <code>PasswordChanged</code> event type - instantiating a reference by providing the email address that is passed through the callback.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationContent</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	...

	<span class="syntax-all syntax-entity">AuthenticationForm</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
		authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationState.authenticationMode,
		email <span class="syntax-all syntax-keyword">=</span> authenticationState.email,
		password <span class="syntax-all syntax-keyword">=</span> authenticationState.password,
    	onEmailChanged <span class="syntax-all syntax-keyword">=</span> {
			handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span>(it))
		},
		onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {
       	 	handleEvent(
				<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">PasswordChanged</span>(it))
        }
	)

	...
}</code></pre>

<p>Hopping back over to our <code>AuthenticationForm</code> composable, we can then compose our <code>PasswordInput</code> and pass in the required <code>password</code> and <code>onPasswordChanged</code> references that are now accessible from the authentication form. Here we’ll also add a <code>Spacer</code> composable so that there is some visual space between the email and password input fields.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
    ) {
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">32</span>.dp))
        <span class="syntax-all syntax-entity">AuthenticationTitle</span>(
			authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode)

        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">40</span>.dp))
        <span class="syntax-all syntax-entity">Card</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">32</span>.dp),
            elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
        ) {
            <span class="syntax-all syntax-entity">Column</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
                horizontalAlignment <span class="syntax-all syntax-keyword">=</span> 		
					<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
            ) {
                <span class="syntax-all syntax-entity">EmailInput</span>(
					modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
					email <span class="syntax-all syntax-keyword">=</span> email <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>, 
					onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged
				)
				<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
				<span class="syntax-all syntax-entity">PasswordInput</span>(
                    password <span class="syntax-all syntax-keyword">=</span> password <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
                    onPasswordChanged <span class="syntax-all syntax-keyword">=</span> onPasswordChanged
                )
            }
        }
    }
}</code></pre>

<p>We’re going to make a small tweak here to customise how the <code>PasswordInput</code> is composed within our UI. When creating the composable, we added support for an optional modifier. We’re going to utilise this argument so that we can force the password input field to fill the available width, which is the width of the parent <code>Column</code>. For this, we’ll utilise the <code>fillMaxWidth</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PasswordInput</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	password <span class="syntax-all syntax-keyword">=</span> password <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
	onPasswordChanged <span class="syntax-all syntax-keyword">=</span> onPasswordChanged
)</code></pre>

<p>With this in place, the password input field for our authentication form is now being composed within our UI - the content of this is then composed based on the current <code>password</code> that is within our state, which in turn is then updated via the use of our <code>onPasswordChanged</code> lambda function.</p>

<figure><img src="paaaa.png"/></figure>

<hr />

<h2>Handling Keyboard Actions</h2>

<p>When interacting with multiple input fields, you can provide a good user experience by allowing the fields to be navigated through by using buttons that are provided on the keyboard. In Android development these have always been referred to as IME actions, something that we still have access to in Jetpack Compose under the name of Keyboard Options. In our authentication screen we’re going to want to utilise some of these options to allow:</p>

<ul>
	<li>Customisation of the keyboard depending on the expected input content</li>
	<li>Navigation from the email address field to the password field</li>
	<li>Submission of the form when the password field is in focus</li>
</ul>

<p>These options together will allow the user to navigate and submit the form, seamlessly completing the authentication flow without needing to specifically interact with the UI components via touch. To add these functionalities we’ll start by customising the options provided by the email address Text Field. For this, we’ll use the Keyboard options class to specify the keyboard type that is to be used for the email input field. This means that if supported, our keyboard will be laid out specifically for email input (showing the ‘@‘ symbol and clipboard options).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  keyboardOptions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardOptions</span>(
    keyboardType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardType</span>.<span class="syntax-all syntax-entity">Email</span>
  )
)</code></pre>

<p>Once the input of the email address has been completed, the user is going to want to continue to the next input field for password entry. At this point we’re going to want to allow this to be done using the keyboard, so we’ll add an IME action to our keyboard options in the form of the Next action.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  keyboardOptions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardOptions</span>(
    imeAction <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ImeAction</span>.<span class="syntax-all syntax-entity">Next</span>,
    keyboardType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardType</span>.<span class="syntax-all syntax-entity">Email</span>
  )
)</code></pre>

<p>We’ll be able to see now that the previously shown ‘return’ icon has now been replaced with a ‘next’ icon.</p>

<figure><img src="1-9.png"/></figure>

<p>With this now displayed within the keyboard, we’re going to want to add some form of handling so that the interaction with the IME action triggers an event for the user. For this, we’re going to utilise the keyboardActions property of our <code>TextField</code> composable, providing an instance of the KeyboardActions class to handle the required IME action. This class allows us to provide function handlers for any required keyboard actions, which in turn will be triggered when the corresponding <code>imeAction</code> is interacted with. When the <code>onNext</code> action is interacted with, we’re going to want to change the current focus on the screen - taking this from the currently focused email address text field, requesting focus on the password text field.</p>

<p>To implement this behaviour we’re going to need to utilise the <code>FocusRequester</code> class. This can be assigned to a composer via a modifier, and then used elsewhere to request the focus on the given composable. We’ll start here by defining a reference to a <code>FocusRequester</code> for our password text field.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">AuthenticationTitle</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode
)
<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">40</span>.dp))
<span class="syntax-all syntax-keyword">val</span> passwordFocusRequester <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FocusRequester</span>()
<span class="syntax-all syntax-entity">Card</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.fillMaxWidth()
    	.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">32</span>.dp),
	elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
) { ... }</code></pre>

<p>With this defined, we’re now going to need to assign it to our password text field. This can be done using the <code>focusRequester</code> modifier, which allows for the <code>FocusRequester</code> reference to be used to request focus for the composable that it is assigned to.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  modifier <span class="syntax-all syntax-keyword">=</span> modifier.focusRequester(passwordFocusRequester)
)</code></pre>

<p>With this <code>FocusRequester</code> now in place we’re going to need to trigger the focus request, this is going to happen when the user interacts with the next IME action that we’ve enabled via the keyboard options. While we’ve provided this option, we haven’t provided any form of handler for it - this is done using the <code>keyboardActions</code> property of the <code>TextField</code>. This property takes a <code>KeyboardActions</code> instance, used to provide handlers for each of the available IME actions. In our case for the email address text field, we’re just going to provide an implementation for the onNext action. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  keyboardActions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardActions</span>(
    onNext <span class="syntax-all syntax-keyword">=</span> {
      
    }
  )
)</code></pre>

<p>At this point though, we don’t have anything that we can trigger from within this <code>onNext</code> block. We could pass the focus requester reference into the <code>EmailInput</code> composable, but it’ll make for a cleaner (and more testable) composable if we pass this event up to the parent composable. For this, we’ll add a new argument-less lambda argument to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInput</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onNextClicked</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Within the <code>onNext</code> block of our <code>KeyboardActions</code> instance we’re going to trigger the <code>onNextClicked</code> lambda.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  keyboardActions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardActions</span>(
    onNext <span class="syntax-all syntax-keyword">=</span> {
      onNextClicked()
    }
  )
)</code></pre>

<p>We’re now going to need to hop over to the parent composable and implement this required <code>onNextClicked</code> argument. Within this implementation, we’re then going to use our <code>FocusRequester</code> to trigger the <code>resuestFocus()</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">EmailInput</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	email <span class="syntax-all syntax-keyword">=</span> email,
	onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged
) {
	passwordFocusRequester.requestFocus()
}</code></pre>

<p>When this function call is triggered, the focus will be requested for our password <code>TextField</code>, which is the composable that our <code>FocusRequester</code> is attached to. If the request is successful, this <code>TextField</code> will come into focus, allowing the user to move between the Email Address and Password text fields without needing to manually interact with either of the composables.</p>

<h3>Supporting form submissions via IME actions</h3>

<p>As well as using IME actions to navigate between input fields, there is a range of other events which can be handled. For example, we can also use them to submit forms that the user has entered data into - this is done in the form of the <strong>Done</strong> IME Action. This can be handled in a very similar way to the Next action that we just handled, instead of providing the <code>ImeAction.Done</code> action type to our <code>KeyboardOptions</code> - assigning this to our <code>PasswordInput</code> <code>TextField</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  keyboardOptions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardOptions</span>(
    imeAction <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ImeAction</span>.<span class="syntax-all syntax-entity">Done</span>
  )
)</code></pre>

<p>We’ll be able to see now that the previously shown ‘return’ icon has now been replaced with a ‘done’ icon.</p>

<figure><img src="2-7.png"/></figure>

<p>We then again need to provide a KeyboardActions implementation to our textfield, this time implementing the onDone handler. In most cases the password field will be visited after the email address field, meaning that the form will be complete and the user can move forward to authenticate their credentials. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  keyboardActions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardActions</span>(
    onDone <span class="syntax-all syntax-keyword">=</span> {
		
    }
  )
)</code></pre>

<p>At this point though, we don’t have anything that we can trigger from within this <code>onDone</code> block. For this, we’ll add a new argument-less lambda argument to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PasswordInput</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onDoneClicked</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With that in mind, within this handler, we’ll use our <code>onDoneClicked()</code> function to trigger the callback.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  keyboardActions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardActions</span>(
    onDone <span class="syntax-all syntax-keyword">=</span> {
		onDoneClicked()
      handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">Authenticate</span>)
    }
  )
)</code></pre>

<p>We’re now going to need to hop up to the parent composable and implement this required <code>onDoneClicked</code> argument. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PasswordInput</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
		.focusRequester(passwordFocusRequester),
	password <span class="syntax-all syntax-keyword">=</span> password,
	onPasswordChanged <span class="syntax-all syntax-keyword">=</span> onPasswordChanged,
	onDoneClicked <span class="syntax-all syntax-keyword">=</span> {

	}
)</code></pre>

<p>Even though we’ve now implemented this callback, we want to trigger the authentication flow but we don’t have any way of triggering that yet. To be able to achieve this, we’ll need to add an argument to our <code>AuthenticationForm</code> composable - this is going to work in the same way as the email + password change handlers.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onAuthenticate</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We’ll then also need to hop up again into the <code>AuthenticationContent</code> composable so that we can satisfy this new required argument. At this point within the <code>AuthenticationContent.kt</code> file, we have access to the <code>handleEvent</code> function - we’re now going to utilise this to trigger the <code>Authenticate</code> event.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span>
<span class="syntax-all syntax-entity">AuthenticationForm</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
	email <span class="syntax-all syntax-keyword">=</span> authenticationState.email,
	password <span class="syntax-all syntax-keyword">=</span> authenticationState.password,
	authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationState.authenticationMode,
	onEmailChanged <span class="syntax-all syntax-keyword">=</span> {
    	handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span>(it))
    },
	onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {
    	handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">PasswordChanged</span>(it))
	},
	onAuthenticate <span class="syntax-all syntax-keyword">=</span> {
    	handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">Authenticate</span>)
	}
)</code></pre>

<p>Hopping back down into the <code>AuthenticationForm.kt</code> file, we can now utilise the <code>onAuthenticate</code> function that is passed into our <code>AuthenticationForm</code> composable. Here we can directly pass this to our <code>PasswordInput</code> composable, this is because the function signatures match - so there’s no need for us to re-implement the callback.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PasswordInput</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
		.focusRequester(passwordFocusRequester),
	password <span class="syntax-all syntax-keyword">=</span> password,
	onPasswordChanged <span class="syntax-all syntax-keyword">=</span> onPasswordChanged,
	onDoneClicked <span class="syntax-all syntax-keyword">=</span> onAuthenticate
)</code></pre>

<p>Now, when the IME Action for the password field is pressed, the authentication flow will be triggered. One final thing we can do here for the password field is provide a keyboard type to our Keyboard Options instance. Similar to how we did for the Email Address text field, this will allow the keyboard to be customised based on the type of content that is being entered.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextField</span>(
  …,
  keyboardOptions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardOptions</span>(
    imeAction <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ImeAction</span>.<span class="syntax-all syntax-entity">Done</span>,
    keyboardType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">KeyboardType</span>.<span class="syntax-all syntax-entity">Password</span>
  )
)</code></pre>

<p>When compared the email input type that we defined for our email address text field, we can see here now that the keys available on the keyboard differ slightly, focusing on numbers and letters, removing the use of some special characters and clipboard options.</p>

<figure><img src="3-7.png"/></figure>

<hr />

<h2>Password Requirements</h2>

<figure><img src="req.png"/></figure>

<p>At this point, our user can enter their credentials into our authentication form. When we defined some of the business logic for our state, we defined an enum, <code>PasswordRequirements</code>. Within our state class, we also defined a list of these <code>PasswordRequirements</code>, allowing us to enforce certain requirements on the entered password. To recap, these requirements were:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PasswordRequirements</span> {
    <span class="syntax-all syntax-entity">CAPITAL_LETTER</span>, <span class="syntax-all syntax-entity">NUMBER</span>, <span class="syntax-all syntax-entity">EIGHT_CHARACTERS</span>
}</code></pre>

<p>This means that the password must contain a capital letter, a number and be at least 8 characters long. While we have these requirements defined, we need to let the user know about them - so we’re going to create a composable that displays the requirements during sign-up, marking the requirements visually as satisfied when they have been met.</p>

<h3>Creating the Requirement Composable</h3>

<p>We’re going to start here by looking at the composable that will be used to represent each of the requirements that we’ve stated in our enum.</p>

<figure><img src="Requirement%20Row.png"/></figure>

<p>For this composable, we’re going to display a simple UI component that will display a label for the requirement, along with an icon that will indicate if this requirement has been satisfied. We’ll start by creating a new composable function that takes our default modifier as an argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>We mentioned above about the two requirements for this composable function - the message to be displayed, along with whether the requirement is currently satisfied. We’ll add more two arguments - a string resource that will be used for the label of our requirement composable, along with a boolean flag to support the satisfied status.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">satisfied</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
)</code></pre>

<p>With these arguments in place, we can start to build out the content of our composable. Here we’ll add a <code>Row</code> composable so that we can layout the children horizontally next to one another, along with adding some modifiers to customise the behaviour + display of content. We’ll chain from the <code>modifier</code> that is passed into the composable function, using the <code>padding</code> modifier to add some padding to our composable. We’ll also use the <code>verticalAlignment</code> argument to align the children in the vertical center - because we’re showing an icon with a text label to the side of it, we want these to be aligned on the Y axis which can be achieved via the use of <code>Alignment.CenterVertically</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">satisfied</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">6</span>.dp),
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        
    }
}</code></pre>

<p>We’ll now go ahead and add an <code>Icon</code> composable which will be used to show a <code>Check</code> icon using the <code>Icons.Default.Check</code> icon from the compose package. We’ll use the <code>size</code> modifier to fix this size to <code>12.dp</code>, along with setting <code>null</code> as the content description. While we will be using this to signify the current status of the requirement, we’re going to focus on the accessibility of this component after the foundations are in place.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">satisfied</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">6</span>.dp),
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        <span class="syntax-all syntax-entity">Icon</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">12</span>.dp),
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Check</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
        )
    }
}</code></pre>

<p>💡 It’s important to remember that null should only be used in cases where a description is not applicable for the composable. This could be either because the composable is purely decorative, or because you are providing a description some other way - such as through the parent composable when merging semantics.</p>

<p>With our icon now in place, let’s add the label that will describe what the requirement is. For this, we’ll use the <code>Text</code> composable and assign the <code>message</code> from the composable function arguments.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">satisfied</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">6</span>.dp),
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        <span class="syntax-all syntax-entity">Icon</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">12</span>.dp),
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Check</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
        )
        <span class="syntax-all syntax-entity">Text</span>(
			text <span class="syntax-all syntax-keyword">=</span> message
		)
    }
}</code></pre>

<p>Currently, we’ll have something that looks like this composed:</p>

<figure><img src="1-10.png"/></figure>

<p>We can improve the appearance of this slightly by making two small tweaks. We’ll first add a <code>Spacer</code> composable between the <code>Icon</code> and <code>Text</code> to create some visual space (using the <code>width</code> modifier to set the width of this as <code>8dp</code>). Next, we’ll override the default <code>fontSize</code> of the <code>Text</code> composable - the text size is currently quite big in the screenshot above, so we’ll use <code>12sp</code> so that this feels a bit more in style with the icon. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">satisfied</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">6</span>.dp),
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        <span class="syntax-all syntax-entity">Icon</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">12</span>.dp),
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Check</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">8</span>.dp))
        <span class="syntax-all syntax-entity">Text</span>(
			text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> message), 
			fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
		)
    }
}</code></pre>

<p>💡 When modifying the fontSize, it’s important to not make the font too small - it still needs to remain readable for users. It can be helpful in these cases to use the typography values from the theme to help prevent these issues from occurring.</p>

<p>We can see now, that things look a little bit better here.</p>

<figure><img src="2-8.png"/></figure>

<p>Currently, we have this <code>satisfied</code> flag within our composable, but we’re not doing anything with it. We’re going to utilise this here to visually represent the status of the requirement - which we’ll do by using a color for the icon and text based on whether the requirement is satisfied. Here we’ll use the theme of our application to create a color reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> tint <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (satisfied) {
    <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary
} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.4f</span>)</code></pre>

<p>We use the <code>primary</code> color in our satisfied scenario, as this will stand out to the user during the authentication process. For the case where the password does not meet the requirements, we <code>copy</code> the <code>onSurface</code> color from our theme, modifying the <code>alpha</code> value so that the color appears slightly faded out in our UI. Using this color reference, we can then apply this to the <code>Icon</code> using the <code>tint</code> argument, along with applying it to the label using the <code>color</code> argument on the <code>Text</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">satisfied</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
) {
    <span class="syntax-all syntax-keyword">val</span> tint <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (satisfied) {
        <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface
    } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.4f</span>)
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">6</span>.dp),
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        <span class="syntax-all syntax-entity">Icon</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">12</span>.dp),
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Check</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
            tint <span class="syntax-all syntax-keyword">=</span> tint
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">8</span>.dp))
        <span class="syntax-all syntax-entity">Text</span>(
			text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> message), 
			fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp, 
			color <span class="syntax-all syntax-keyword">=</span> tint
		)
    }
}</code></pre>

<p>With this in place, we now have a composable that will display a requirement, along with theming it to represent the current state of the satisfied flag.</p>

<figure><img src="3-8.png"/></figure>

<h3>Improving the requirement accessibility</h3>

<p>While we have the above composable function in place to compose a requirement, we can improve things here when it comes to the use of accessibility services. Currently, the label of the requirement will be read - but we are relying on a color representation to signify whether the requirement is satisfied or not. This isn’t very accessible, so we’ll apply some modifications to improve things here. What we’ll do is add a description to the requirement, so that when the accessibility service is describing the element, it can be described whether or not the requirement is currently satisfied.</p>

<p>We’ll start here by adding two new string resources to our <code>strings.xml</code> resource file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;password_requirement_satisfied&quot;</span>&gt;
	%s, satisfied
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;password_requirement_needed&quot;</span>&gt;
	%s, needed
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We use <code>%s</code> as a placeholder for a string that we will be replacing it with, this will be the label for the requirement. This means that the accessibility services will describe this as “At least 8 characters, satisfied” or “At least 8 characters, needed”. Within our <code>Requirement</code> composable we can now build our description by accessing this resource via the use of the <code>stringResource</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">satisfied</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
) {
    <span class="syntax-all syntax-keyword">val</span> requirementStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (satisfied) {
        stringResource(id <span class="syntax-all syntax-keyword">=</span>
			<span class="syntax-all syntax-entity">R</span>.string.password_requirement_satisfied, message)
    } <span class="syntax-all syntax-keyword">else</span> {
        stringResource(id <span class="syntax-all syntax-keyword">=</span> 
			<span class="syntax-all syntax-entity">R</span>.string.password_requirement_not_satisfied, message)
    }
}</code></pre>

<p>You’ll notice here that we pass the <code>message</code> argument from our composable function as an argument to the <code>stringResource</code> function. This is because we are using the <code>%s</code> placeholder, so any arguments that are provided here will be used as the replacement. With this in place, we can now go ahead and apply the <code>semantics</code> modifier to our <code>Row</code> composable. When doing this we’ll want to set the <code>mergeDescendants</code> flag as true (as we don’t need the child composables to be described individually), along with setting the <code>text</code> semantics as the <code>requirementStatus</code> that we generated above. This property requires the <code>AnnotatedString</code> type, so we’ll instantiate an instance by providing our <code>requirementStatus</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">6</span>.dp)
		.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) {
			text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>(requirementStatus)
		},
	verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
)</code></pre>

<p>Because we’re now setting the <code>semantics</code> for our <code>Row</code> and merging the content of the container, we can go ahead and clear the semantics on the child <code>Text</code> composable, using the <code>clearAndSetSemantics</code> modifier to do so. This will avoid any descriptions from being duplicated with the semantics tree.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.clearAndSetSemantics { },
	text <span class="syntax-all syntax-keyword">=</span> message, 
	fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp, 
	color <span class="syntax-all syntax-keyword">=</span> tint
)</code></pre>

<p>With this in place, we now have an updated composable function that has improved accessibility support.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Requirement</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">satisfied</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
) {
    <span class="syntax-all syntax-keyword">val</span> tint <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (satisfied) {
    	<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary
	} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.4f</span>)
    <span class="syntax-all syntax-keyword">val</span> requirementStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (satisfied) {
        stringResource(id <span class="syntax-all syntax-keyword">=</span>
			<span class="syntax-all syntax-entity">R</span>.string.password_requirement_satisfied, message)
    } <span class="syntax-all syntax-keyword">else</span> {
        stringResource(id <span class="syntax-all syntax-keyword">=</span> 
			<span class="syntax-all syntax-entity">R</span>.string.password_requirement_not_satisfied, message)
    }
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">6</span>.dp)
			.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) {
                text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>(requirementStatus)
            },
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        <span class="syntax-all syntax-entity">Icon</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">12</span>.dp),
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Check</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
            tint <span class="syntax-all syntax-keyword">=</span> tint
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">8</span>.dp))
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.clearAndSetSemantics { },
			text <span class="syntax-all syntax-keyword">=</span> message, 
			fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp, 
			color <span class="syntax-all syntax-keyword">=</span> tint
		)
    }
}</code></pre>

<h3>Building the Requirement items</h3>

<p>At this point, we now have a <code>Requirement</code> composable function, but we’re not building these within our UI. We’ll start here by defining a new composable function, <code>PasswordRequirements</code>, that takes a list of satisfied requirements - we have this value within our state, so this will simply be provided from there when the time comes to implementing that.</p>

<p>Within this function, we’ll also compose a <code>Column</code>, as we’re going to be showing a vertical list of the requirement composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PasswordRequirements</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">satisfiedRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;
) {
	<span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

	}
}</code></pre>

<p>Composing the requirements is a very minimal process. We previously defined the <code>PasswordRequirements</code> enum, with each value having a label property in the form of a string resource. That means that within this composable we can simply loop through the values of the <code>PasswordRequirements</code> enum, composing a <code>Requirement</code> using the current item in the loop. Here we’ll use the <code>label</code> property to retrieve a string that can be passed for the <code>message</code> argument of the <code>Requirement</code>, along with using the <code>PasswordRequirements</code> reference to check whether the requirement is currently satisfied.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PasswordRequirements</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">satisfiedRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;
) {
    <span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier
	) {
        <span class="syntax-all syntax-entity">PasswordRequirements</span>.values().forEach { requirement <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-entity">Requirement</span>(
                message <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> requirement.label),
                satisfied <span class="syntax-all syntax-keyword">=</span> satisfiedRequirements.contains(
                    requirement
                )
            )
        }
    }
}</code></pre>

<p>With this, we can now compose a collection of requirements and their current satisfied status.</p>

<figure><img src="4-5.png"/></figure>

<h3>Composing the Requirement items</h3>

<p>With the <code>PasswordRequirements</code> composable now in place, we’re going to want to slot this into our UI. However, we’re only going to want to show this to the user when they are signing up - a user who has signed in will know their password and have a valid password, so this validation within the UI does not make too much sense. We could simply compose this based on our <code>AuthenticationMode</code> reference within our screen state, but instead, we’re going to utilise the <code>AnimatedVisibility</code> composable to animate our composable in and out, based on its visible flag. This means we could define, an<code>AnimatedVisibility</code> composable, setting the visible flag using an assertion against the <code>AuthenticationMode.SIGN_UP</code> value, and provide our <code>PasswordRequirements</code> composable as the content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span>
<span class="syntax-all syntax-entity">AnimatedVisibility</span>(
	visible <span class="syntax-all syntax-keyword">=</span> authenticationMode <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>
) {
	<span class="syntax-all syntax-entity">PasswordRequirements</span>(...)
}</code></pre>

<p>This would mean that when the current <code>AuthenticationMode</code> within our state is not equal to <code>SIGN_UP</code>, the <code>PasswordRequirements</code> would animated out of view - animating into view when that state is toggled by the user (something that we have not implemented yet!).</p>

<p>While the above would work, we need to compose it within our UI. For the <code>AuthenticationForm</code> composable function, we already have access to an <code>AuthenticationMode</code> reference - we’ll just need to add a new argument to the function in the form of <code>List&lt;PasswordRequirements&gt;</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">//AuthenticationForm.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">completedPasswordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We’ll then also need to hop over to our <code>AuthenticationContent.kt</code> file to modify the composition of our <code>AuthenticationForm</code> composable. We’ll need to pass a value for the <code>completedPasswordRequirements</code> - the state reference that we are using for the other arguments here has the current requirements within it, so we’ll simply need to pass that here.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span>
<span class="syntax-all syntax-entity">AuthenticationForm</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
	email <span class="syntax-all syntax-keyword">=</span> authenticationState.email,
	password <span class="syntax-all syntax-keyword">=</span> authenticationState.password,
	completedPasswordRequirements <span class="syntax-all syntax-keyword">=</span> authenticationState.passwordRequirements,
    authenticationMode <span class="syntax-all syntax-keyword">=</span>
		authenticationState.authenticationMode,
    onEmailChanged <span class="syntax-all syntax-keyword">=</span> {
    	handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span>(it))
    },
	onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {
   		handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">PasswordChanged</span>(it))
    }
)</code></pre>

<p>Heading back over to our <code>AuthenticationForm</code> composable, we can now compose our <code>AnimatedVisibility</code> and <code>PasswordRequirements</code> composables. Here we’ll also add a <code>Spacer</code> composable so that there is some visual space between UI components.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">completedPasswordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
		horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
	) {
		<span class="syntax-all syntax-entity">EmailInput</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			email <span class="syntax-all syntax-keyword">=</span> email, 
			onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged
		) {
			passwordFocusRequester.requestFocus()
    	}
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
		<span class="syntax-all syntax-entity">PasswordInput</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
				.focusRequester(passwordFocusRequester),
            password <span class="syntax-all syntax-keyword">=</span> password,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> onPasswordChanged,
            onSubmitForm <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

        <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
            visible <span class="syntax-all syntax-keyword">=</span> authenticationMode <span class="syntax-all syntax-keyword">==</span>
            	<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>
        ) {
        	<span class="syntax-all syntax-entity">PasswordRequirements</span>(completedPasswordRequirements)
        }
}</code></pre>

<p>With this in place, we now have our <code>PasswordRequirements</code> composed within our authentication UI. When signing up, entering a password will now modify the requirements UI to display the currently satisfied requirements. </p>

<figure><img src="123.png"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</figure>

<hr />

<h2>Triggering the Authentication flow</h2>

<figure><img src="flow.png"/></figure>

<p>In our UI the user can now enter their email address and password, but they can’t yet trigger the authentication flow to allow them to proceed in our app. To make this possible, we’re now going to add a button that allows them to perform this authentication flow using the credentials that they have entered into the form. While this is possible using the IME action that we added in the last section, a button to trigger this flow would be expected by a lot of users. We’ll start here by creating a new composable function, <code>AuthenticationButton</code> with a default <code>Modifier</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationButton.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationButton</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>Next, we’ll add a <code>Button</code> composable, this requires two of its properties to be provided - an <code>onClick</code> callback handler and a composable that represents the body of the Button.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationButton</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Button</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        
    }
}</code></pre>

<p>As it is, this <code>Button</code> isn’t too much use to us as it’s not showing or triggering anything. To change this we’ll add a composable for the body of the button, this will represent either a “Sign in” or “Sign up” message, depending on the current authenticationMode from our authentication state reference. We’ll need to start by adding a couple of string resources for the button text:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;action_sign_up&quot;</span>&gt;Sign Up&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;action_sign_in&quot;</span>&gt;Sign In&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>So that we know what one of these strings to show within our button, the composable function is going to need to know what <code>AuthenticationMode</code> is currently selected. For this, we’re going to need to pass this into our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationButton</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
)</code></pre>

<p>Next, we’ll use an if statement check to handle what the message should be depending on the state, then set this as the content of a <code>Text</code> composable within the body of our <code>Button</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationButton</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
) {
    <span class="syntax-all syntax-entity">Button</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> stringResource(
                <span class="syntax-all syntax-keyword">if</span> (authenticationMode <span class="syntax-all syntax-keyword">==</span>
					<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>) {
                    <span class="syntax-all syntax-entity">R</span>.string.action_sign_in
                } <span class="syntax-all syntax-keyword">else</span> {
                    <span class="syntax-all syntax-entity">R</span>.string.action_sign_up
                }
            )
        )
    }
}</code></pre>

<p>With this Text in place, we’ll now be able to see a button on-screen whose body represents the current authentication mode that is set within our state.</p>

<figure><img src="1-11.png"/></figure>

<p>At this point, we can now think about handling the <code>onClick</code> trigger from our Button. What we want to do here is trigger an event that will start the authentication flow - similar to how else we have handled events in this project, we’re going to allow the parent composable to handle this event for us. With this in mind, we’ll add a lambda function argument to our composable function, <code>onAuthenticate</code>. We’ll then want to trigger this lambda within the <code>onClick</code> argument of our <code>Button</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationButton</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
    <span class="syntax-all syntax-parameter">onAuthenticate</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Button</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
		onClick <span class="syntax-all syntax-keyword">=</span> {
            onAuthenticate()
        }
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> stringResource(
                <span class="syntax-all syntax-keyword">if</span> (authenticationMode <span class="syntax-all syntax-keyword">==</span>
					<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>) {
                    <span class="syntax-all syntax-entity">R</span>.string.action_sign_in
                } <span class="syntax-all syntax-keyword">else</span> {
                    <span class="syntax-all syntax-entity">R</span>.string.action_sign_up
                }
            )
        )
    }
}</code></pre>

<p>Now when our Button is pressed, the authentication flow will be triggered and the credentials from our TextFields will be used during this process. However, these fields might not always contain valid data - we have an <code>enableAuthentication</code> property within our authentication state reference. While this only checks if both the email address and password are not empty, this helps to avoid the flow being triggered when data might not have been entered yet. We can handle this via the Button by disabling the button from being interacted with when the form content is not valid. For this we’ll use the enabled property of the <code>Button</code>, assigning the<code>enableAuthentication</code> value to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationButton</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">enableAuthentication</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onAuthenticate</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Button</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        onClick <span class="syntax-all syntax-keyword">=</span> {
            onAuthenticate()
        },
        enabled <span class="syntax-all syntax-keyword">=</span> enableAuthentication
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> stringResource(
                <span class="syntax-all syntax-keyword">if</span> (authenticationMode <span class="syntax-all syntax-keyword">==</span>
					<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>) {
                    <span class="syntax-all syntax-entity">R</span>.string.action_sign_in
                } <span class="syntax-all syntax-keyword">else</span> {
                    <span class="syntax-all syntax-entity">R</span>.string.action_sign_up
                }
            )
        )
    }
}</code></pre>

<figure><img src="2-9.png"/></figure>

<p>Now that our button composable is implemented, we can go ahead and compose it within our <code>AuthenticationForm</code> composable. We’ll need to start by adding a new argument to our <code>AuthenticationForm</code> composable, this will be <code>enableAuthentication</code> in the form of a <code>Boolean</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">completedPasswordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;,
	<span class="syntax-all syntax-parameter">enableAuthentication</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We’ll then also need to hop over to our <code>AuthenticationContent.kt</code> file to modify the composition of our <code>AuthenticationForm</code> composable. We’ll need to pass a value for the <code>enableAuthentication </code> - our state reference that we are using for the other arguments here has the current enabled state within it, so we’ll simply need to pass that here.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span>
<span class="syntax-all syntax-entity">AuthenticationForm</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
	email <span class="syntax-all syntax-keyword">=</span> authenticationState.email,
	password <span class="syntax-all syntax-keyword">=</span> authenticationState.password,
	completedPasswordRequirements <span class="syntax-all syntax-keyword">=</span> authenticationState.passwordRequirements,
    authenticationMode <span class="syntax-all syntax-keyword">=</span>
		authenticationState.authenticationMode,
	enableAuthentication <span class="syntax-all syntax-keyword">=</span> authenticationState.isFormValid(),
    onEmailChanged <span class="syntax-all syntax-keyword">=</span> {
    	handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span>(it))
    },
	onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {
   		handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">PasswordChanged</span>(it))
    },
	onAuthenticate <span class="syntax-all syntax-keyword">=</span> {
        handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">Authenticate</span>)
    }
)</code></pre>

<p>Heading back over to our <code>AuthenticationForm</code> composable, we can now compose our <code>AuthenticationButton</code>. Here we’ll also add a <code>Spacer</code> composable so that there is some visual space between UI components.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">completedPasswordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
		horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
	) {
		<span class="syntax-all syntax-entity">EmailInput</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			email <span class="syntax-all syntax-keyword">=</span> email, 
			onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged
		) {
			passwordFocusRequester.requestFocus()
    	}
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
		<span class="syntax-all syntax-entity">PasswordInput</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
				.focusRequester(passwordFocusRequester),
            password <span class="syntax-all syntax-keyword">=</span> password,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> onPasswordChanged,
            onSubmitForm <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

        <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
            visible <span class="syntax-all syntax-keyword">=</span> authenticationMode <span class="syntax-all syntax-keyword">==</span>
            	<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>
        ) {
        	<span class="syntax-all syntax-entity">PasswordRequirements</span>(completedPasswordRequirements)
        }

		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

        <span class="syntax-all syntax-entity">AuthenticationButton</span>(
        	enableAuthentication <span class="syntax-all syntax-keyword">=</span> enableAuthentication,
            authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode,
            onAuthenticate <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )
	}
}</code></pre>

<p>With this in place, our <code>AuthenticationButton</code> is now being composed inside of our authentication form - this now allows the user to trigger the authentication flow.</p>

<figure><img src="3-9.png"/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</figure>

<hr />

<h2>Toggling the Authentication mode</h2>

<figure><img src="another.png"/></figure>

<p>With all of the above in place, our user can perform authentication using the provided fields. However, the UI only currently supports the default authentication type - which is currently configured to be sign in. This means that if the user does not currently have an account, they won’t be able to create one using our authentication form. In this section we’re going to go ahead and define a Button that allows the user to toggle between sign up and sign in, recomposing our authentication form to reflect the current mode. We’ll start here by creating a new composable function, <code>ToggleAuthenticationMode </code> with a default <code>Modifier</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>With this composable function in place, we can build out the content required to display our toggle button. We’re going to start by defining the use of a <code>Surface</code>, which act as the container for our toggle composable. The <code>Surface</code> composable will compose the provided body inside of a <code>Box</code> composable. It will also theme itself use the <code>surface</code> color from the application theme, which is what we want to be applied to our settings item in terms of styling. This saves us from using a <code>Box</code> composable and applying a collection of styling ourselves when this component already exists to do it for us. When composing this, we’ll apply the modifier from the argument of our composable function, along with overriding the default <code>elevation</code> of the service with the value of <code>8dp</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
    ) {
        
    }
}</code></pre>

<p>Next, we’re going to add a button to our <code>Surface</code>, and for this, we will use the <code>TextButton</code> composable. This is a composable offered by the compose material package which allows us to compose a flat button that displays some composable content for its body. When composing a <code>TextButton</code> we will need to provide an <code>onClick</code> handler and some content body to be displayed within the composable button </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
    ) {
        <span class="syntax-all syntax-entity">TextButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {

            }
		) {
            
        }
    }
}</code></pre>

<p>Now that we have the composable defined, we need to go ahead and populate these properties of the composable. Before we add this composable, we’ll go ahead and add some additional resources to be used for the body of the composables.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;action_need_account&quot;</span>&gt;
	Need an account?
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;action_already_have_account&quot;</span>&gt;
	Already have an account?
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Next, we’ll use the content property of the <code>TextButton</code> so that we can see some form of visual result on our screen. Now we can add a Text composable to the body of our <code>TextButton</code>, this will display the content of a string resource, depending on the current authentication mode represented by our state. Before we can do this though, we’ll need to know the <code>AuthenticationMode</code> which should be used when composing this composable. We’ll add this as an argument for our composable function so that it can be passed in from the parent.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
)</code></pre>

<p>With this in place, we can now utilise this to compose the button content. Inside of our button, we’re going to compose a <code>Text</code> composable, setting the content based on the provided <code>AuthenticationMode</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
    ) {
        <span class="syntax-all syntax-entity">TextButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {

            }
		) {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(
                    <span class="syntax-all syntax-keyword">if</span> (authenticationMode <span class="syntax-all syntax-keyword">==</span> 	
						<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>) {
                        <span class="syntax-all syntax-entity">R</span>.string.action_need_account
                    } <span class="syntax-all syntax-keyword">else</span> {
                        <span class="syntax-all syntax-entity">R</span>.string.action_already_have_account
                    }
                )
            )
        }
    }
}</code></pre>

<p>Finally, we use need to handle the <code>onClick</code> callback for our <code>TextButton</code>. When the button is clicked we want to trigger an event that will change the authentication mode for the state of our screen. - this will be an event in the form of <code>ToggleAuthenticationMode</code>, which we created in an earlier section. Again we’ll want to pass this event up to the parent, so we’ll need to add a new lambda argument to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">toggleAuthentication</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>When this event is triggered, our ViewModel will flip the value of our authentication mode, allowing us to switch between the sign in and sign up state. So this will occur, we’ll go ahead and trigger this within the <code>onClick</code> handler for our <code>TextButton</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
    <span class="syntax-all syntax-parameter">toggleAuthentication</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
    ) {
        <span class="syntax-all syntax-entity">TextButton</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface)
                .padding(<span class="syntax-all syntax-constant">8</span>.dp),
            onClick <span class="syntax-all syntax-keyword">=</span> {
                toggleAuthentication()
            }
		) {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(
                    <span class="syntax-all syntax-keyword">if</span> (authenticationMode <span class="syntax-all syntax-keyword">==</span> 
						<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>) {
                        <span class="syntax-all syntax-entity">R</span>.string.action_need_account
                    } <span class="syntax-all syntax-keyword">else</span> {
                        <span class="syntax-all syntax-entity">R</span>.string.action_already_have_account
                    }
                )
            )
        }
    }
}</code></pre>

<p>Within our UI, this toggle button was pushed right to the bottom of the screen - this isn’t something that can be configured within the properties of the parent Column container. </p>

<figure><img src="11-1.png"/></figure>

<h3>Composing the Toggle Button</h3>

<p>Now that our button is implemented, we can go ahead and compose it within our <code>AuthenticationForm</code> composable. We’ll need to start by adding a new argument to our <code>AuthenticationForm</code> composable, this will be <code>onToggleMode </code> in the form of a lambda function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">completedPasswordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;,
	<span class="syntax-all syntax-parameter">enableAuthentication</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onToggleMode</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We’ll then also need to hop over to our <code>AuthenticationContent.kt</code> file to modify the composition of our <code>AuthenticationForm</code> composable. We’ll need to pass an argument for the <code>onToggleMode</code> - for this, we’ll implement a lambda function that will be used to trigger <code>handleEvent</code>. For this call, we’re going to need to pass an <code>AuthenticationEvent</code>, which we’ll do so in the form of the <code>ToggleAuthenticationMode</code> type. When this is triggered and handled by our ViewModel, the current <code>AuthenticationMode</code> will be toggled to the opposite value and emitted to our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span>
<span class="syntax-all syntax-entity">AuthenticationForm</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
	email <span class="syntax-all syntax-keyword">=</span> authenticationState.email,
	password <span class="syntax-all syntax-keyword">=</span> authenticationState.password,
	completedPasswordRequirements <span class="syntax-all syntax-keyword">=</span> authenticationState.passwordRequirements,
    authenticationMode <span class="syntax-all syntax-keyword">=</span>
		authenticationState.authenticationMode,
	enableAuthentication <span class="syntax-all syntax-keyword">=</span> authenticationState.isFormValid(),
    onEmailChanged <span class="syntax-all syntax-keyword">=</span> {
    	handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span>(it))
    },
	onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {
   		handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">PasswordChanged</span>(it))
    },
	onAuthenticate <span class="syntax-all syntax-keyword">=</span> {
        handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">Authenticate</span>)
    },
	onToggleMode <span class="syntax-all syntax-keyword">=</span> {
        handleEvent(
			<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>)
	}
)</code></pre>

<p>Heading back over to our <code>AuthenticationForm</code> composable, we can now compose our <code>AuthenticationButton</code> using the existing <code>authenticationMode</code> reference, along with the now provided <code>onToggleMode</code> lambda function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">completedPasswordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onToggleMode</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
		horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
	) {
		<span class="syntax-all syntax-entity">EmailInput</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			email <span class="syntax-all syntax-keyword">=</span> email, 
			onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged
		) {
			passwordFocusRequester.requestFocus()
    	}
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
		<span class="syntax-all syntax-entity">PasswordInput</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
				.focusRequester(passwordFocusRequester),
            password <span class="syntax-all syntax-keyword">=</span> password,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> onPasswordChanged,
            onSubmitForm <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

        <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
            visible <span class="syntax-all syntax-keyword">=</span> authenticationMode <span class="syntax-all syntax-keyword">==</span>
            	<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>
        ) {
        	<span class="syntax-all syntax-entity">PasswordRequirements</span>(completedPasswordRequirements)
        }

		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

        <span class="syntax-all syntax-entity">AuthenticationButton</span>(
        	enableAuthentication <span class="syntax-all syntax-keyword">=</span> enableAuthentication,
            authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode,
            onAuthenticate <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )

        <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode,
            toggleAuthentication <span class="syntax-all syntax-keyword">=</span> {
                onToggleMode()
            }
        )
	}
}</code></pre>

<p>We’ll notice here now that our <code>ToggleAuthenticationMode</code> composable is pressed against the bottom of our <code>AuthenticationButton</code> composable.</p>

<figure><img src="GG.png"/></figure>

<p>As per the design, we want the <code>ToggleAuthenticationMode</code> to be pushed against the bottom of the parent composable. Between these buttons we essentially want a large amount of white space - this white spice needs to fill the available space between these two buttons, which in effect will push our toggle button to the bottom of our UI. For this, we’re still going to use the Spacer composable for creating space between these two composables, with the addition of the weight modifier. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))</code></pre>

<p>Applying a weight of <strong>1f</strong> to this Spacer will cause it to take up all of the available height to it within the Column - which in this case will be all of the space between the Authenticate and toggle buttons. We are not applying any weighting to any other composables so that the remaining weight here does not need to be distributed between multiple composables. If we were to assign some weighting to one of those buttons also, we would see a different result as the weight would become distributed. But because we are only assigning weight here to the Spacer composable, it takes the available space for itself.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationForm</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationMode</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>,
	<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">password</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">completedPasswordRequirements</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">PasswordRequirements</span>&gt;,
    <span class="syntax-all syntax-parameter">onEmailChanged</span><span class="syntax-all syntax-keyword">:</span> (email<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onPasswordChanged</span><span class="syntax-all syntax-keyword">:</span> (password<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onToggleMode</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
		horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
	) {
		<span class="syntax-all syntax-entity">EmailInput</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			email <span class="syntax-all syntax-keyword">=</span> email, 
			onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged
		) {
			passwordFocusRequester.requestFocus()
    	}
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
		<span class="syntax-all syntax-entity">PasswordInput</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
				.focusRequester(passwordFocusRequester),
            password <span class="syntax-all syntax-keyword">=</span> password,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> onPasswordChanged,
            onSubmitForm <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

        <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
            visible <span class="syntax-all syntax-keyword">=</span> authenticationMode <span class="syntax-all syntax-keyword">==</span>
            	<span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>
        ) {
        	<span class="syntax-all syntax-entity">PasswordRequirements</span>(completedPasswordRequirements)
        }

		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

        <span class="syntax-all syntax-entity">AuthenticationButton</span>(
        	enableAuthentication <span class="syntax-all syntax-keyword">=</span> enableAuthentication,
            authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode,
            onAuthenticate <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )

		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))

        <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            authenticationMode <span class="syntax-all syntax-keyword">=</span> authenticationMode,
            toggleAuthentication <span class="syntax-all syntax-keyword">=</span> {
                onToggleMode()
            }
        )
	}
}</code></pre>

<p>With this change, we can now see the toggle button is pushed to the bottom of the parent composable, via the usage of the <code>Spacer</code> composable with its assigned <code>weight</code>.</p>

<figure><img src="ff.png"/></figure>

<p>With these composables now added, our authentication form is functionally complete - offering a way for users to both sign up and sign in to our application.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<hr />

<h2>Displaying Authentication Errors</h2>

<figure><img src="dialog.png"/></figure>

<p>With everything we’ve done previously in this section, the user can enter some credentials and perform either a sign-in or sign-up operation. While this operation can succeed and allow the user to continue into our application, sometimes that request may fail. In these cases, we’ll want to reflect this state to the user so they know something has gone wrong. Our authentication state has an error property within it, so we’ll be able to use this property to display an alert dialog to the user.</p>

<p>Within our <code>AuthenticationState</code> class there is an <code>error</code> property, which is used to depict that an error has occurred during the authentication process. While this <code>error</code> might be set during the authentication flow, we’re not currently utilising this within our UI to communicate this to the user. To handle this scenario, we’re going to create a new composable, <code>AuthenticationErrorDialog</code>, which is going to take this <code>error</code> value and compose it within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationErrorDialog.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)</code></pre>

<p>Within this composable function, we’re then going to compose an <code>AlertDialog</code>. There are two <code>AlertDialog</code> composable functions available, we’re going to use the one with the following set of arguments.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">dismissError</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">AlertDialog</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            
        },
        confirmButton <span class="syntax-all syntax-keyword">=</span> {

        },
        title <span class="syntax-all syntax-keyword">=</span> {
            
        },
        text <span class="syntax-all syntax-keyword">=</span> {
            
        }
    )
}</code></pre>

<p>As we can see here, there are a collection of arguments that we need to provide to the composable function:</p>

<ul>
	<li><strong>modifier</strong>: this is optional, but allows us to provide constraints to be applied to the composable</li>
	<li><strong>onDismissRequest</strong>: triggered when the dialog is requested to be dismissed, which we’ll need to use to trigger an update to our state so that the dialog is not composed</li>
	<li><strong>confirmButton</strong>: a composable that represents the button used to confirm the request of the dialog, with the intention to dismiss it</li>
	<li><strong>title</strong>: the composable to be used as the title of the dialog</li>
	<li><strong>text</strong>: the composable to be used for the content body of the dialog</li>
</ul>

<p>With that in mind, let’s start building out the composables for each of these arguments. We’ll start with the title, which we’ll need to start by adding a new string to our <code>strings.xml</code> resource file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;error_title&quot;</span>&gt;Whoops&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Then using the <code>stringResource</code> composable function, we’ll compose a <code>Text</code> composable providing this string for the <code>text</code> argument. Because we’re working with a title here, we’ll override the default <code>fontSize</code> of the composable and assign a value of <code>18sp</code> - this is so that is styled larger than the message of the dialog.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationErrorDialog.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
) {
    <span class="syntax-all syntax-entity">AlertDialog</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            
        },
        confirmButton <span class="syntax-all syntax-keyword">=</span> {
            
        },
        title <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.error_title),
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
            )
        },
        text <span class="syntax-all syntax-keyword">=</span> {
            
        }
    )
}</code></pre>

<p>At this point, we can see this text being used for the title of our dialog.</p>

<figure><img src="1-12.png"/></figure>

<p>Next, we’ll use another <code>Text</code> composable, but this time for the <code>text</code> argument of the <code>AlertDialog</code> composable. Here we will simply provide the <code>error</code> that is passed to our composable function for the <code>text</code> argument of the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationErrorDialog.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
) {
    <span class="syntax-all syntax-entity">AlertDialog</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
        	
        },
        confirmButton <span class="syntax-all syntax-keyword">=</span> {
            
        },
        title <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.error_title),
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
            )
        },
        text <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> error
            )
        }
    )
}</code></pre>

<p>With this in place, we can now see the title of our <code>AlertDialog</code> being accompanied by our error message.</p>

<figure><img src="2-10.png"/></figure>

<p>Next, we need to compose the button that will be used to dismiss the <code>AlertDialog</code> - this will be provided using the <code>button</code> argument of our composable. We’ll first start by composing a <code>TextButton</code> to be used for this action. This allows us to compose a flat button that is visually represented as some text. The difference with this, when compared to a <code>Text</code> composable, is that the <code>TextButton</code> has the expected touch target sizing of an intractable component, making it accessible to all of our users.</p>

<p>There are two required arguments for the <code>TextButton</code> - the <code>onClick</code> callback and the <code>content</code>, which is used to provide the composable body of our button.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextButton</span>(
	onClick <span class="syntax-all syntax-keyword">=</span> {
		
	}
) {
	
}</code></pre>

<p>We’ll start by composing the body of our button, for which we’ll need to add a new resource to our <code>strings.xml</code> file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;error_action&quot;</span>&gt;OK&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then use this to compose a <code>Text</code> composable for the <code>content</code> of our button.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">TextButton</span>(
	onClick <span class="syntax-all syntax-keyword">=</span> {
		
	}
) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.error_action))
}</code></pre>

<p>Next up we’ll need to add some action to our <code>onClick</code> callback. When our button is clicked we’re simply going to want to dismiss the dialog, so we’ll need to communicate this action back up to the parent so that our state can be updated and in turn, the dialog will no longer be composed. For this, we’ll need to add a new lambda argument to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">dismissError</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With this lambda in place, we can now trigger this from within the <code>onClick</code> of our <code>TextButton</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationErrorDialog.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">dismissError</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">AlertDialog</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            
        },
        confirmButton <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">TextButton</span>(
				onClick <span class="syntax-all syntax-keyword">=</span> {
					dismissError()
				}
			) {
				<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.error_action))
			}
        },
        title <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.error_title),
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
            )
        },
        text <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> error
            )
        }
    )
}</code></pre>

<p>At this point, we’ll now have a visually complete error dialog that displays the title, message and actions to the user.</p>

<figure><img src="3-10.png"/></figure>

<p>The last thing to do here is to add some implementation to the <code>onDismissRequest</code> lambda body of the <code>AlertDialog</code>. In the previous step, we added the <code>dismissError</code> argument to our composable function, so we’ll now want to trigger this within the <code>onDismissRequest</code> lambda.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationErrorDialog.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">error</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
	<span class="syntax-all syntax-parameter">dismissError</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">AlertDialog</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            dismissError()
        },
        buttons <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Box</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .fillMaxWidth(),
                contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterEnd</span>
            ) {
                <span class="syntax-all syntax-entity">TextButton</span>(
                    onClick <span class="syntax-all syntax-keyword">=</span> {
                        dismissError()
                    }
                ) {
                    <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.error_action))
                }
            }
        },
        title <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.error_title),
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
            )
        },
        text <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> error
            )
        }
    )
}</code></pre>

<p>With the composable in place, we’ll now want to compose this within our UI. One thing to note here is that we want to conditionally compose this, so it will only be composed when there is an error present within our state. When performing composition, we can wrap the composition of the <code>AuthenticationErrorDialog</code> within a kotlin <code>let</code> block, allowing us to assert the nullability of the <code>error</code> property. This way the block will only be run if <code>error</code> is not null, so our composable will only ever be composed if it should be.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span>
authenticationState.error?.<span class="syntax-all syntax-constant">let</span> { error <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
		...
	)
}</code></pre>

<p>We can slot this into our <code>AuthenticationContent</code> composable, providing the <code>error</code> from our authentication state for the <code>error</code> argument, along with implementing the <code>dismissError</code> lambda. Within this lambda we’ll want to utilise the <code>handleEvent</code> lambda that is provided to our composable function, using the <code>ErrorDismissed</code> <code>AuthenticationError</code> to trigger our state being updated and removing the error (and in turn, the alert dialog will no longer be composed).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationContent.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AuthenticationContent</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">authenticationState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AuthenticationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-keyword">if</span> (authenticationState.isLoading) {
            <span class="syntax-all syntax-entity">CircularProgressIndicator</span>()
        } <span class="syntax-all syntax-keyword">else</span> {
            <span class="syntax-all syntax-entity">AuthenticationForm</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                email <span class="syntax-all syntax-keyword">=</span> authenticationState.email,
                password <span class="syntax-all syntax-keyword">=</span> authenticationState.password,
                completedPasswordRequirements <span class="syntax-all syntax-keyword">=</span> 
					authenticationState.passwordRequirements,
                authenticationMode <span class="syntax-all syntax-keyword">=</span> 
					authenticationState.authenticationMode,
                enableAuthentication <span class="syntax-all syntax-keyword">=</span> 
					authenticationState.isFormValid(),
                onEmailChanged <span class="syntax-all syntax-keyword">=</span> {
            		handleEvent(
						<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">EmailChanged</span>(it))
                },
                onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(
						<span class="syntax-all syntax-entity">AuthenticationEvent</span>
							.<span class="syntax-all syntax-entity">PasswordChanged</span>(it))
                },
                onAuthenticate <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(
						<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">Authenticate</span>)
                },
                onToggleMode <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(<span class="syntax-all syntax-entity">AuthenticationEvent</span>
						.<span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>)
                }
            )
			authenticationState.error?.<span class="syntax-all syntax-constant">let</span> { error <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
                    error <span class="syntax-all syntax-keyword">=</span> error,
                    dismissError <span class="syntax-all syntax-keyword">=</span> {
                        handleEvent(
							<span class="syntax-all syntax-entity">AuthenticationEvent</span>.<span class="syntax-all syntax-entity">ErrorDismissed</span>)
                    }
                )
            }
		}
    }
}</code></pre>

<p>At this point we now have an <code>AlertDialog</code> that will be composed within our UI whenever the state represents an error state, allowing us to communicate any authentication errors to the user.</p>

<figure><img src="ggggg.png"/></figure>

<hr />

<h2>Wrapping Up</h2>

<figure><img src="complete.png"/></figure>

<p>Throughout this project, we’ve now fully implemented our authentication feature - allowing our users to sign-up or sign-in to our application, with the ability to toggle between the two authentication modes. With this toggling, we’ve been able to explore the composition of different states and components within our UI, on top of the management of state when it comes to our authentication form.</p>

<figure><img src="fff.png"/></figure>

<p>With all of this in place, we’ll want to ensure these components remain functional within our app. In the next chapter, we’re going to explore writing automated UI tests for these composables.</p>

<h1>Testing the Authentication UI</h1>

<p>Now that we’ve built our Authentication screen, we’re going to take a look at how we can write tests for our composables. We’re going to be writing some instrumentation tests using the compose ui-test-junit package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>)
debugImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to add mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered whenever expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:3.12.4&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependant on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		exclude <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/AL2.0&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/LGPL2.1&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
	}
}</code></pre>

<hr />

<h2>Setting up the test class</h2>

<p>We’ll next start by creating a new class, <strong>AuthenticationTest</strong> - this class will be used to contain the different tests that we’re going to write.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the ComposeContentTestRule class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@get:Rule
</span><span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched in, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside of.</p>

<hr />

<h2>Testing the Authentication Composable</h2>

<p>At the root of our feature is the <code>Authentication</code> composable. What makes this different from our lower level composables (such as each UI component composable), is that this composable allows us to interact with elements to trigger state updates and recomposition of our UI. This means that with the tests for the <code>Authentication</code> composable we can assert not only that the expected UI components are displayed, but also that interactions with them result in the expected state changes.</p>

<h3>Testing for Authentication Mode changes</h3>

<p>With that in mind, we’re going to start with some tests to ensure that the expected state is composed when the UI is interacted with. Within the <code>Authentication</code> composable the user can toggle between the sign-in + sign-up mode, so we’ll start with some tests that assert the compositions that are dependant on these different modes.</p>

<p>To start with, the title of the authentication screen is depending on the authentication mode represented within our state. So here, we’re going to write some tests to assert that the content of the title correctly reflects the state of our screen. By default our screen is in the <strong>sign in</strong> state, so we’re going to write a test to assert that this is the case.</p>

<p>To write this first test we’ll use the <strong>@Test</strong> annotation and create a new function to test that the Sign In title is displayed by default within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_In_Title_Displayed_By_Default</span>() {

}</code></pre>

<p>Inside of this test, we’re going to need to start by setting the composable content that is to be displayed on screen for us to assert against. Here we’ll use the test rule that we previously defined, along with its <code>setContent</code> function. This function takes a composable function as an argument, allowing us to define what is to be composed on screen for our tests. Because we’re wanting to test the Authentication Composable that we defined in the previous sections of this chapter, we’ll go ahead and pass the <code>Authentication</code> composable function for this composable argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_In_Title_Displayed_By_Default</span>() {
    composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Authentication</span>()
	}
}</code></pre>

<p>While we aren’t yet performing any assertions, running this test will launch an activity that displays the content of our Authentication composable. With this now being displayed, we can next perform the required assertions to ensure that the Sign In title is being displayed within our composable UI. We’ll do this by utilising the <code>onNodeWithText</code> function from our test rule reference.</p>

<p>The <code>onNodeWithText</code> function can be used to locate a composable that is displaying the text that we have provided to the function. Composables will be located in the form of a semantic node - because our composables are represented via semantics, in our tests we are going to be locating nodes within our semantic tree. In this case, this is done using the <code>onNodeWithText</code> function, which will return us with a <code>SemanticsNodeInteraction</code> reference to perform assertions against. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_In_Title_Displayed_By_Default</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Authentication</span>()
	}

	composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(
                <span class="syntax-all syntax-entity">R</span>.string.label_sign_in_to_account)
    )
}</code></pre>

<p>For this test we want to assert that this node is being displayed within our composed UI, so we’re going to go ahead and utilise the <code>assertIsDisplayed</code> function. This is one of the assertions available on the <code>SemanticsNodeInteraction</code> class, allowing us to assert whether this node is being displayed on the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_In_Title_Displayed_By_Default</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Authentication</span>()
	}

	composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(
                <span class="syntax-all syntax-entity">R</span>.string.label_sign_in_to_account)
    ).assertIsDisplayed()
}</code></pre>

<p>If you run this test within your IDE, you’ll not only see the UI spin up inside of the connected device / emulator, but the tests should also be passing due to the required string being composed within the UI.</p>

<p>Alongside the <strong>Sign In</strong> title being displayed by the default Sign In authentication mode, the <strong>Need Account</strong> account should also be composed within our UI. For these tests, we’re going to be able to reuse a lot of the same code, with the key difference here being that we need to assert the composition of the <code>action_need_account</code> string as opposed to the sign in title.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Need_Account_Displayed_By_Default</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Authentication</span>()
	}

	composeTestRule
		.onNodeWithText(
        	<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.action_need_account)
        )
		.assertIsDisplayed()
}</code></pre>

<p>With these two tests in place, we are now able to assert that the expected composables for the Sign In Authentication Mode are being composed. But what happens if the user toggles the Authentication Mode? In this scenario, we know that toggling to the Sign Up mode will change the title and toggle messages - so we’re going to write some tests to assert these recompositions are triggered when this toggle occurs.</p>

<p>For this, we’re going to start by testing that the title is changed to the <strong>Sign Up</strong> title when the Authentication Mode toggle is clicked. Just like the last test, we’ll start by setting the content to be composed inside of our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_Up_Title_Displayed_After_Toggled</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }
}</code></pre>

<p>Now that we have some form of state being composed into our UI, we’re going to want to trigger the title change - this will be done by clicking the Authentication Mode toggle button, which switches our screen from the sign-in to sign-up state. For this interaction we’re going to use the <code>performClick</code> function, this is a gesture action that is available on the <code>SemanticsNodeInteraction</code> class, allowing us to perform a click gesture on the specified node.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_Up_Title_Displayed_After_Toggled</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule
		.onNodeWithText(
        	<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.action_need_account)
    	).performClick()
}</code></pre>

<p>Once this interaction has taken place, it is expected that the authentication mode will be toggled. When this occurs, the title of the screen should switch to represent the <strong>Sign Up</strong> mode. So with this test, we want to assert that the expected <strong>Sign Up</strong> title is composed. Here we’ll match the assertion that we used for the title in the previous test, except this time we’ll check for our <code>R.string.label_sign_up_for_account</code> String resource.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_Up_Title_Displayed_After_Toggled</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule
		.onNodeWithText(
        	<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.action_need_account)
    	).performClick()

    composeTestRule
		.onNodeWithText(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
                	<span class="syntax-all syntax-entity">R</span>.string.label_sign_up_for_account)
    	).assertIsDisplayed()
}</code></pre>

<p>With this test in place, we’re now able to assert that our title is recomposed accordingly when the authentication mode is toggled. When this toggle occurs, we will also expect the authentication button to be recomposed to reflect the <strong>Sign Up</strong> action, as opposed to <strong>Sign In</strong>. For this, we’re going to start with a test that looks very similar to the previous - we’ll need to compose our <code>Authentication</code> composable, followed by using the <code>performClick</code> function to interact with the button used to toggle the authentication mode.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_Up_Button_Displayed_After_Toggle</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule
		.onNodeWithText(
       		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.action_need_account)
    	).performClick()
}</code></pre>

<p>Now, this is clicked, our authentication button should be showing the <strong>Sign Up</strong> action. We’re going to want to assert this to ensure this is the case, so we’ll need to start by adding a tag to the authentication button composable. We’ll create a new object, <code>Tags</code>, and define a new tag that can be assigned to our authentication button. We’re also going to be interacting with the authentication toggle across a couple of tests, so we’ll add a tag for that too.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">//Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;authenticate_button&quot;</span>
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_AUTHENTICATION_TOGGLE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;authentication_mode_toggle&quot;</span>
}</code></pre>

<p>With these tags defined we can now use the <code>testTag</code> function to assign this tag to our <code>Button</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">//AuthenticationButton.kt
</span>
<span class="syntax-all syntax-entity">Button</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>),
	...
)</code></pre>

<p>We’ll also do the same for the <code>ToggleAuthenticationMode</code> <code>Button</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ToggleAuthenticationMode.kt
</span>
<span class="syntax-all syntax-entity">TextButton</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATION_TOGGLE</span>),
	...
)</code></pre>

<p>With these tags in place, it can now be used to locate a node within our composable hierarchy using the <code>onNodeWithTag</code> function. On this node, we can then use the <code>assertTextEquals</code> function to assert that the text of this composable is equal to the content of the <code>action_sign_up</code> resource.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_Up_Button_Displayed_After_Toggle</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule.onNodeWithTag(
       	<span class="syntax-all syntax-entity">TAG_AUTHENTICATION_TOGGLE</span>
    ).performClick()

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>
    ).assertTextEquals(
       	<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(<span class="syntax-all syntax-entity">R</span>.string.action_sign_up)
    )
}</code></pre>

<p>With this test in place, we can now be certain that when the authentication mode is toggled, the content displayed within the authentication button no longer represents the sign in action, but instead the sign up action.</p>

<p>Aside from the title, we’re going to want to check that our authentication toggle now displays the content that reflects the change authentication mode. For this, we’re going to again interact with the toggle button to toggle the authentication mode, and then we’ll want to assert that the text of that authentication button represents the expected value.</p>

<p>Here we’ll set up a test that will compose our <code>Authentication</code> composable, followed by utilising our <code>TAG_AUTHENTICATION_TOGGLE</code> tag to again locate the node that represents the toggle button. We can then use this reference to perform actions and assertions. </p>

<p>Because we’re going to be performing multiple interactions on this node, we’ll use the kotlin <code>apply</code> function to chain multiple operations. We’ll start by using the <code>performClick</code> function to perform a click action on the button, when this is clicked the authentication mode will be flipped from sign in to sign up. When this occurs, the button should display the content of our <code>action_already_have_account</code> resource. We’ll use the <code>assertTextEquals</code> function to assert that this is the case.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Already_Have_Account_Displayed_After_Toggle</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_AUTHENTICATION_TOGGLE</span>
    ).<span class="syntax-all syntax-constant">apply</span> {
        performClick()
        assertTextEquals(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.action_already_have_account)
        )
    }
}</code></pre>

<p>If this test passes, it means that the authentication toggle button is being successfully recomposed with the corresponding state for the sign-up mode that has been switched to. Otherwise, it means the composable has not been composed with the expected state.</p>

<p>The title and authentication button are dynamic components in the sense that any composition should take into account the authentication mode. Now we have these tests, we’re able to assert that the content of these composables correctly reflects the current authentication mode within our state.</p>

<h3>Testing the Authentication Button</h3>

<p>Aside from adapting to the authentication mode, the Authentication button is also composed based on other parts of our state. Based on the current content that is input into the email and password text fields, the authentication button will be composed with an <code>enabled</code> state. This means that if the email or password in our state is empty, then the authentication button will be disabled.</p>

<p>By default, our authentication button should be disabled, as there will be no content in either of the <code>email</code> or <code>password</code> properties of our state. Similar to the previous tests we’ve written for our <code>Authentication</code> composable, we’re going to create a new test that composes our <code>Authentication</code> composable, followed by using the test rule to locate a node using our previously defined <code>TAG_AUTHENTICATE_BUTTON</code> tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authentication_Button_Disabled_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule
		.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>)
}</code></pre>

<p>If this node has been located, then we’re going to need to perform an assertion to check that the button is disabled - this is because there the <code>email</code> and <code>password</code> state properties are currently empty. To perform this assertion we’re going to use the <code>assertIsNotEnabled</code> function. This <code>SemanticsMatcher</code> will check that the semantics for the location node has the <code>SemanticsProperties.Disabled</code> property, meaning that the composable is disabled.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authentication_Button_Disabled_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule
		.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>)
		.assertIsNotEnabled()
}</code></pre>

<p>With this small test, we’ll now be able to assert that by default, the authentication button is disabled. On the flip side, when those input fields <strong>do have content</strong>, we want to assert that the Authentication button is enabled. We’ll start writing a new test here to assert this condition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authentication_Button_Enabled_With_Valid_Content</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }
}</code></pre>

<p>While we could use the Authentication state to preload values to be used for the email and password fields, I wanted to simulate user behaviour here - so we’re going to use the <code>performTextInput</code> function to type some text into the specified text field. Before we can interact with our text fields in such a way, we’re going to need to add tags for them so that the nodes can be located from our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_INPUT_EMAIL</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;input_email&quot;</span>
<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_INPUT_PASSWORD</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;input_password&quot;</span></code></pre>

<p>We’ll then assign these tags to each of the email and password input fields using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// EmailInput.kt
</span>
<span class="syntax-all syntax-entity">TextField</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_INPUT_EMAIL</span>),
    ...
)

<span class="syntax-all syntax-comment">// PasswordInput.kt
</span>
<span class="syntax-all syntax-entity">TextField</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_INPUT_PASSWORD</span>),
    ...
)</code></pre>

<p>With these tags in place, we can now utilise the <strong>performTextInput</strong> function to input a provided string into the corresponding nodes.</p>

<pre><code class="code-highlighted code-kt">composeTestRule.onNodeWithTag(
    <span class="syntax-all syntax-entity">TAG_INPUT_EMAIL</span>
).performTextInput(<span class="syntax-all syntax-string">&quot;contact@compose.academy&quot;</span>)

composeTestRule.onNodeWithTag(
    <span class="syntax-all syntax-entity">TAG_INPUT_PASSWORD</span>
).performTextInput(<span class="syntax-all syntax-string">&quot;password&quot;</span>)</code></pre>

<p>After our state has been composed, we’ll use both the email and password input fields to perform text input - giving both of these fields valid content that would allow the user to authenticate against. Once these calls are in place, we can again locate the Authentication Button using its tag but this time assert that it is enabled using the <code>assertIsEnabled</code> function. We previously used the <code>assertIsNotEnabled</code> function, the key difference here is that <code>assertIsEnabled</code> is checking that the <code>SemanticsProperties.Disabled</code> semantic property is not present on the specific composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authentication_Button_Enabled_With_Valid_Content</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_INPUT_EMAIL</span>
    ).performTextInput(<span class="syntax-all syntax-string">&quot;contact@compose.academy&quot;</span>)

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_INPUT_PASSWORD</span>
    ).performTextInput(<span class="syntax-all syntax-string">&quot;password&quot;</span>)

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>
    ).assertIsEnabled()
}</code></pre>

<p>Because the email and password fields have valid content, the authentication button, in this case, should be enabled - which our test should now be asserting for us. </p>

<p>Some further testing here could include removing text from the input fields and asserting that our authentication button is disabled from recomposition. At this point, the initial test for the disabled state, followed by the enable state serves as a minimal requirement for our testing - but feel free to explore further coverage here!</p>

<h3>Testing authentication errors</h3>

<p>Now that we’ve performed assertions on the content that is used to authenticate the user, we can look at the next stages in the application flow. While the user might be successfully authenticated and move to the next screen, that isn’t always going to be the case - to cover these scenarios, we added a dialog composable to be displayed when an error occurs during authentication.</p>

<p>To assert that this dialog is displayed in the correct scenarios, we’re going to go ahead and start by testing that the dialog is not displayed by default. This will allow us to ensure that users are not going to be shown the error dialog when an error hasn’t happened.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Error_Alert_Not_Displayed_By_Default</span>() {

}</code></pre>

<p>So that we can try to locate the node that represents our alert dialog, we’re going to define another tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_ERROR_ALERT</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;error_alert&quot;</span></code></pre>

<p>We’ll then assign this tag to our AlertDialog composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">AlertDialog</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_ERROR_ALERT</span>),
	...
)</code></pre>

<p>With this tag in place, we can now attempt to locate the node and then perform assertions against it. To do this we’ll use the <code>onNodeWithTag</code> function, followed by using <code>assertDoesNotExist</code> to assert that a node with this tag does not exist - meaning that the error dialog does not currently exist within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Error_Alert_Not_Displayed_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_ERROR_ALERT</span>
    ).assertDoesNotExist()
}</code></pre>

<p>Now that we know our alert dialog is not showing when an error doesn’t exist, we’re going to want to test the flip side of this and assert that the error dialog is displayed when an error <strong>has</strong> occurred. We’ll start here by defining a new test function to represent this test case.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Error_Alert_Displayed_After_Error</span>() {

}</code></pre>

<p>Next, we need to compose our state so that the error dialog is displayed - we’ll do this by composing our <code>AuthenticationContent</code> and providing an <code>AuthenticationState</code> reference that has an error value assigned to it.</p>

<pre><code class="code-highlighted code-kt">composeTestRule.setContent {
	<span class="syntax-all syntax-entity">AuthenticationContent</span>(
        <span class="syntax-all syntax-entity">AuthenticationState</span>(
            error <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Some error&quot;</span>
        )
    ) { }
}</code></pre>

<p>Because our state now has an error value, an alert dialog will be composed within our UI. However, we’re going to want to finalise our test and assert that this is the case. We’ll wrap up this test by locating the alert dialog using the tag we previously assigned to the <code>AlertDialog</code> composable, followed by using the <code>assertIsDisplayed</code> function to verify that the alert dialog has been composed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Error_Alert_Displayed_After_Error</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationContent</span>(
            <span class="syntax-all syntax-entity">AuthenticationState</span>(
                error <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Some error&quot;</span>
            )
        ) { }
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_ERROR_ALERT</span>
    ).assertIsDisplayed()
}</code></pre>

<h3>Testing the loading state</h3>

<p>When the Authentication Button is clicked, the authentication process is triggered - in this scenario we would likely be making a network request, displaying a progress dialog on-screen in the process. During these state changes, we show and hide a large amount of the UI components, so we want to be sure that these state changes result in the expected UI conditions. We’ll write a couple more tests to ensure that these changes behave as expected.</p>

<p>So that we can perform assertions against the progress indicator, we’ll define a new tag and assign it to our <code>CircularProgressIndicator</code> composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PROGRESS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;progress&quot;</span>
}

<span class="syntax-all syntax-entity">CircularProgressIndicator</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_PROGRESS</span>)
)</code></pre>

<p>We’ll then go ahead and add a simple first test that asserts our progress indicator is not composed of the default state of our UI. Here we use the <code>onNodeWithTag</code> function to locate our node using the specified tag, followed by asserting that the node does not exist using the <code>assertDoesNotExist</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Progress_Not_Displayed_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_PROGRESS</span>
    ).assertDoesNotExist()
}</code></pre>

<p>Now we’ve asserted that our progress indicator is not composed with the default authentication state, we can now write a test to ensure that the loading state is reflected in our composed UI. For this we’ll go ahead and compose our <code>AuthenticationContent</code>, providing a reference to the <code>AuthenticationState</code> class with the <code>isLoading</code> flag marked as true.</p>

<p>With this in place, we can continue to locate the node that represents our loading indicator, followed by performing the assertion that it is displayed within our composed UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Progress_Displayed_While_Loading</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationContent</span>(
            <span class="syntax-all syntax-entity">AuthenticationState</span>(isLoading <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>)
        ) { }
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_PROGRESS</span>
    ).assertIsDisplayed()
}</code></pre>

<p>After our operation has finished loading, we’ve hardcoded our ViewModel to set an error state. When this happens, our UI should hide the progress indicator and display the authentication form to the user. For us to assert that this is the case, we’ll need to trigger the authentication process from our UI. To save us entering text into the textfields at runtime, we’ll compose our test UI with some pre-loaded state for the email address and password values.</p>

<p>Once that’s done, we next need to perform a click interaction on our Authentication Button - this will trigger the authentication process and set the error state from our ViewModel. When this happens, our progress indicator should no longer exist in our UI. To ensure that this is the case, we’ll add an assertion by using the <code>assertDoesNotExist</code> function to check that the progress indicator does not exist within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Progress_Not_Displayed_After_Loading</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationContent</span>(
            authenticationState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationState</span>(
                email <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;contact@compose.academy&quot;</span>,
                password <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password&quot;</span>
            )
        ) { }
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>
    ).performClick()

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_PROGRESS</span>
    ).assertDoesNotExist()
}</code></pre>

<p>Once we reach this state of our progress indicator not being displayed (because the loading process has been completed), we’re going to want to ensure that the content of our UI has been composed again - this is the authentication form, allowing users to attempt re-authentication. If this didn’t display again within the UI, things would be quite broken for the users - so we’ll write a test to assert that this is the case.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Displayed_After_Loading</span>()</code></pre>

<p>Before we can perform assertions against the content area of our UI, we’re going to need to define a new tag and assign it to the parent of our content area.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CONTENT</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;content&quot;</span>
}</code></pre>

<p>We’ll then need to set this tag on the corresponding composable within our <code>AuthenticationForm</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// AuthenticationForm.kt
</span>
<span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>),
	horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
)</code></pre>

<p>While we could perform assertions against the individual children that already have tags assigned to them, this approach allows us to refer to the content area as a whole. Similar to the previous test, we can perform the authentication flow, followed by performing the assertion that the content area exists within our UI. </p>

<p>Because there has been an error state loaded at this point, there will be an alert dialog composed within our UI. For this reason, we use the <code>exists</code> check instead of a <code>displayed</code> check, this is because the alert dialog will be covered a good chunk of the content UI so we cannot always guarantee that the <code>displayed</code> assertion would be satisfied.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Displayed_After_Loading</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Authentication</span>()
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_INPUT_EMAIL</span>
    ).performTextInput(<span class="syntax-all syntax-string">&quot;contact@compose.academy&quot;</span>)

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_INPUT_PASSWORD</span>
    ).performTextInput(<span class="syntax-all syntax-string">&quot;password&quot;</span>)

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>
    ).performClick()

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_CONTENT</span>
    ).assertExists()
}</code></pre>

<hr />

<h2>Testing the Authentication Title</h2>

<p>Now that we have tests in place that performs assertions against our <code>Authentication</code> composable, we’re going to focus on writing some fine-grained tests for the individual composable functions that represent our individual setting items. This allows us to focus on performing assertions on the behaviour of the composable function itself, without the concern of our global state. We’ll start here by creating a new test class, <code>AuthenticationTitleTest</code>, configuring our <code>ComposeContentTestRule</code> ready for use.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationTitleTest</span> {

	<span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’re going to start here by writing a test to assert that the composable correctly displays the title corresponding title for the <code>AuthenticationMode</code> that is provided to it. The <code>AuthenticationTitle</code> contains the logic that depicts which string resource is used based on the <code>AuthenticationMode</code> that is provided to it. For this reason, we’ll want to write these tests to ensure this logic is working as expected.</p>

<p>Here we’ll create a new test function, <code>Sign_In_Title_Displayed</code>, where we will assert that the Sign In title is composed when the <code>AuthenticationMode.SIGN_IN</code> is provided for the <code>authenticationMode</code> argument. We’ll start here by composing an <code>AuthenticationTitle</code>, passing the Sign In mode for the <code>authenticationMode</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_In_Title_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationTitle</span>(
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>
        )
    }
}</code></pre>

<p>When the <code>AuthenticationTitle</code> is composed for the <code>SIGN_IN</code> <code>AuthenticationMode</code>, it is expected that the <code>label_sign_in_to_account</code> will be displayed. We’ll need to perform an assertion for this in our tests, so we’ll go ahead and use the <code>onNodeWithText</code> function on our test rule to locate a node that has the text contained within our <code>label_sign_in_to_account</code> resource. We’ll then use the <code>assertIsDisplayed</code> function to perform the assertion that this composable is displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_In_Title_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationTitle</span>(
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>
        )
    }
    composeTestRule
        .onNodeWithText(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
                	<span class="syntax-all syntax-entity">R</span>.string.label_sign_in_to_account)
        )
        .assertIsDisplayed()
}</code></pre>

<p>If this test fails, it means that the expected title is not being composed for the <code>SIGN_IN</code> <code>AuthenticationMode</code>. On the flip side, we’ll also want to assert that the expected text content is composed for the <code>SIGN_UP</code> <code>AuthenticationMode</code>. This test is going to look the same as the previous, except this time we’ll pass in <code>AuthenticationMode.SIGN_UP</code> when composing the <code>AuthenticationTitle</code>, as well as using the <code>label_sign_up_for_account</code> resource when performing our assertion.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_Up_Title_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationTitle</span>(
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>
        )
    }
    composeTestRule
        .onNodeWithText(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.label_sign_up_for_account)
        )
        .assertIsDisplayed()
}</code></pre>

<p>With these tests in place, we can now be sure that the <code>AuthenticationTitle</code> is using the expected string resource during composition, based on the <code>AuthenticationMode</code> that is provided to it.</p>

<hr />

<h2>Testing the Authentication Button</h2>

<p>Alongside the <code>AuthenticationTitle</code> being composed based on the <code>AuthenticationMode</code> that is provided to it, the <code>AuthenticationButton</code> also behaves in the same way - we’ll also want to write some tests to assert this composition also. We’ll start by creating a new <code>AuthenticationButtonTest</code> class, setting up the compose rule in the process.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationButtonTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    
}</code></pre>

<p>Next, we’ll write the first test within this test class, which will be used to assert that the Sign In action is displayed within the button when expected. For this we’ll need to compose the <code>AuthenticationButton</code>, passing the <code>AuthenticationMode.SIGN_IN</code> value for the <code>authenticationMode</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_In_Action_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationButton</span>(
            enableAuthentication <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>,
            onAuthenticate <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Now that the <code>AuthenticationButton</code> is going to be composed in our test, we can perform the required assertions. We already have the <code>TAG_AUTHENTICATE_BUTTON</code> tag assigned to our composable from some previous tests that we wrote, so we can use this to locate the required node. Once we’ve done that, the <code>assertTextEquals</code> can then be used to assert that the expected text of the retrieved node matches the value that we provide. Here we’ll provide the string value for our <code>action_sign_in</code> resource, which represents the “Sign In” value that is expected to be displayed when the <code>AuthenticationMode.SIGN_IN</code> is provided to the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_In_Action_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationButton</span>(
            enableAuthentication <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>,
            onAuthenticate <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>)
        .assertTextEquals(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(<span class="syntax-all syntax-entity">R</span>.string.action_sign_in)
        )
}</code></pre>

<p>We’ll also want to assert that the <code>action_sign_up</code> string is displayed when the <code>AuthenticationMode.SIGN_UP</code> is passed to the composable. We’ll write a corresponding test here which will mostly match the previous test we wrote, except we’ll pass <code>AuthenticationMode.SIGN_UP</code> for the <code>authenticationMode</code> argument, along with using the <code>action_sign_up</code> string resource when performing the <code>assertTextEquals</code> assertion.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Sign_Up_Action_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationButton</span>(
            enableAuthentication <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>,
            onAuthenticate <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>)
        .assertTextEquals(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
                	<span class="syntax-all syntax-entity">R</span>.string.action_sign_up)
        )
}</code></pre>

<p>Alongside the <code>AuthenticationMode</code> based assertions that we’ve performed above, the <code>AuthenticationButton</code> also takes an <code>onAuthenticate</code> argument. When this lambda is invoked by our <code>AuthenticationButton</code>, the parent composable will use this to trigger the authentication mode - if this broke, users would not be able to perform authentication within our app. For this reason, we’re going to write a test to assert that the lambda is invoked when expected. Here we’re going to pass in a <code>mock</code> lambda function for the <code>onAuthenticate</code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based off of composable events.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authenticate_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onAuthenticate<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationButton</span>(
            enableAuthentication <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>,
            onAuthenticate <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )
    }
}</code></pre>

<p>With the <code>AuthenticationButton</code> being composed, we’ll now be able to retrieve the node that represents this authentication button using the <code>TAG_AUTHENTICATE_BUTTON</code> tag. We’ll then use the <code>performClick</code> function to perform a click action on this node. When this click action is triggered, this is the point that we would expect the <code>onAuthenticate</code> to be invoked so that the parent composable can handle the authentication event. We can verify this within our test by using mockito and its <code>verify</code> function to assert that the lambda has been invoked. If this is the case, the test will succeed - otherwise, the lambda not being triggered will mean that our verification will not be satisfied and the test will fail.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Authenticate_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onAuthenticate<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationButton</span>(
            enableAuthentication <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>,
            onAuthenticate <span class="syntax-all syntax-keyword">=</span> onAuthenticate
        )
    }

	composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATE_BUTTON</span>)
        .performClick()

    verify(onAuthenticate).invoke()
}</code></pre>

<p>The <code>AuthenticationButton</code> composable also takes an <code>enableAuthentication</code>argument. It could also be beneficial to write some tests to assert the composition based on the value of this argument - we already have some tests for the <code>Authentication</code> composable that involved the enabled state, so we won’t cover that here!</p>

<hr />

<h2>Testing the Authentication Mode Toggle</h2>

<p>So far we’ve been writing tests for various composables that utilise the <code>AuthenticationMode</code> from our state object. The button that is used to toggle this value also takes an <code>AuthenticationMode</code> reference, this is also so that it can be composed to display the corresponding content for the provided <code>AuthenticationMode</code>. After setting up a test class with a corresponding test rule, we’ll create a test function that will be used to assert the <code>action_need_account</code> resource text is displayed within our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationModeToggleTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

	<span class="syntax-all syntax-keyword">@Test
</span>	<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Need_Account_Action_Displayed</span>() {

	}
    
}</code></pre>

<p>Within this test we’ll need to start by composing a <code>ToggleAuthenticationMode</code>, providing the <code>authenticationMode</code> argument in the form of the <code>AuthenticationMode.SIGN_IN</code> value. When this <code>SIGN_IN</code> value is provided, we expect that the corresponding content is displayed inside the button - this is in the form of the <code>action_need_account</code> resource. After locating the node for this composable using the <code>onNodeWithTag(TAG_AUTHENTICATION_TOGGLE)</code> function call, we can assert that this expected text is displayed via the use of the <code>assertTextEquals</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Need_Account_Action_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_IN</span>,
            toggleAuthentication <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
		.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATION_TOGGLE</span>)
        .assertTextEquals(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.action_need_account)
        )
}</code></pre>

<p>We’ll next flip this around so that we can assert that the expected <code>action_already_have_account</code> value is displayed when the <code>AuthenticationMode.SIGN_UP</code> value is provided for the <code>authenticationMode</code> argument. Our test here is going to look the same as above, aside from the tweak to the <code>authenticationMode</code> argument that we pass, along with the <code>action_already_have_account</code> value that is now being provided to the <code>assertTextEquals</code> function call.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Already_Have_Account_Action_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>,
            toggleAuthentication <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATION_TOGGLE</span>)
        .assertTextEquals(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
                	<span class="syntax-all syntax-entity">R</span>.string.action_already_have_account)
        )
}</code></pre>

<p>With this test in place, we can now be certain that the passing tests mean the provided <code>authenticationMode</code> value is going to display the expected text inside of our composable. Whenever the user clicks the button that is displaying this text, the lambda function that is provided to the composable should be triggered - this is the <code>toggleAuthentication</code> lambda. If this for some reason was not being triggered, the user would not be able to switch to the sign-up mode - so if a user does not currently have an account, they wouldn’t be able to create one. To ensure this remains functional, let’s write a quick test to assert that this event does occur.</p>

<p>Within this next test, we’re going to pass in a <code>mock</code> lambda function for the <code>toggleAuthentication </code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based off of composable events.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Toggle_Authentication_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> toggleAuthentication<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>,
            toggleAuthentication <span class="syntax-all syntax-keyword">=</span> toggleAuthentication
        )
    }
}</code></pre>

<p>With the <code>ToggleAuthenticationMode</code> being composed, we’ll now be able to use the retrieve the node that represents this toggle button using the <code>TAG_AUTHENTICATION_TOGGLE</code> tag. We’ll then use the <code>performClick</code> function to perform a click action on this node. When this click action is triggered, this is the point that we would expect the <code>toggleAuthentication</code> to be invoked so that the parent composable can handle the authentication event. We can verify this within our test by using mockito and its <code>verify</code> function to assert that the lambda has been invoked. If this is the case, the test will succeed - otherwise, the lambda not being triggered will mean that our verification will not be satisfied and the test will fail.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Toggle_Authentication_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> toggleAuthentication<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ToggleAuthenticationMode</span>(
            authenticationMode <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AuthenticationMode</span>.<span class="syntax-all syntax-entity">SIGN_UP</span>,
            toggleAuthentication <span class="syntax-all syntax-keyword">=</span> toggleAuthentication
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_AUTHENTICATION_TOGGLE</span>)
        .performClick()

    verify(toggleAuthentication).invoke()
}</code></pre>

<hr />

<h2>Testing the Email Address Input</h2>

<p>When it comes to the <code>EmailInput</code> composable, an <code>email</code> argument is used to provide the content that is to be displayed inside of the text field. This is a very important part of the authentication flow, so we’ll want to write a test to ensure that this provided value is displayed inside of our composable. To do this we’ll need to start by setting up a new test class, <code>EmailInputTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">EmailInputTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    
}</code></pre>

<p>We’ll start here by creating a new test, composing the <code>EmailInput</code> composable. We’ll provide empty implementations for the <code>onEmailChanged</code> and <code>onFocusRequested</code> arguments, but will need to provide a string value for the <code>email</code> argument. We’ll create a string variable reference here, providing this to our <code>EmailInput</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Email_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> email <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;contact@compose.academy&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailInput</span>(
            email <span class="syntax-all syntax-keyword">=</span> email,
            onEmailChanged <span class="syntax-all syntax-keyword">=</span> { },
            onNextClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Next, we’ll need to assert that this <code>email</code> value is displayed inside of our composable. In a previous test, we defined the <code>TAG_INPUT_EMAIL</code> tag, so we’ll use this here to locate the node that represents our email text field. Once this node has been located we can utilise the <code>assertTextEquals</code> function to assert that the text semantic value of the node matches our provided <code>email</code> variable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Email_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> email <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;contact@compose.academy&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailInput</span>(
            email <span class="syntax-all syntax-keyword">=</span> email,
            onEmailChanged <span class="syntax-all syntax-keyword">=</span> {  },
            onNextClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_INPUT_EMAIL</span>)
        .assertTextEquals(email)
}</code></pre>

<p>With this test in place, we can now be certain that a passing test means the provided <code>email</code> value is going to be displayed inside of our composable. When the user enters content into the text field to update this <code>email</code> value that is coming from our state, the lambda function that is provided to the composable is triggered - this is the <code>onEmailChanged</code> lambda. If this for some reason was not being triggered, the user would be unable to enter their email address into the text field. To ensure this remains function, let’s write a quick test to assert that this event does occur.</p>

<p>As before, we’ll need to compose the <code>EmailInput</code> composable to perform our assertions against. We’ll need to provide a string value for the <code>email</code> argument - we’ll create a variable reference for this so that we can assert the lambda is triggered with the expected value. We’re also going to pass in a <code>mock</code> lambda function for the <code>onEmailChanged</code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based off of composable events.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Email_Changed_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onEmailChanged<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> email <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;contact@compose.academy&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailInput</span>(
            email <span class="syntax-all syntax-keyword">=</span> email,
            onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged,
            onNextClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>While we have provided this lambda to our composable, we now need to trigger it so that we can verify the expected behaviour. To trigger this lambda we need to enter some text into the input field, which we can do so using the <code>performTextInput</code> on a specified node. We’re going to append some text onto the existing input, which we’ll store in a variable reference, <code>appendedText</code> so that we can use this during the assertion. Here we’ll locate the input field node using our existing tag, followed by inputting this content using the <code>performTextInput</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> appendedText <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;.jetpack&quot;</span>
composeTestRule
	.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_INPUT_EMAIL</span>)
	.performTextInput(appendedText)</code></pre>

<p>With this in place, we can now add the check to verify that the lambda function is called as expected. When this is triggered, we would expect that the <code>email</code> value returned here would represent the existing content with the addition of the <code>appendedText</code> value. We can verify this within our test by using mockito and its <code>verify</code> function to assert that the lambda has been invoked with the existing value in the input field (<code>email</code>) appended with the value of <code>appendedText</code>. If this is the case, the test will succeed - otherwise, the lambda not being triggered will mean that our verification will not be satisfied and the test will fail.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Email_Changed_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onEmailChanged<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> email <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;contact@compose.academy&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailInput</span>(
            email <span class="syntax-all syntax-keyword">=</span> email,
            onEmailChanged <span class="syntax-all syntax-keyword">=</span> onEmailChanged,
            onNextClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    <span class="syntax-all syntax-keyword">val</span> appendedText <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;.jetpack&quot;</span>
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_INPUT_EMAIL</span>)
        .performTextInput(appendedText)

    verify(onEmailChanged).invoke(email <span class="syntax-all syntax-keyword">+</span> appendedText)
}</code></pre>

<hr />

<h2>Testing the Password Input</h2>

<p>When it comes to the <code>PasswordInput</code> composable, a <code>password</code> argument is used to provide the content that is to be displayed inside of the text field. This is a very important part of the authentication flow, so we’ll want to write a test to ensure that this provided value is displayed inside of our composable. To do this we’ll need to start by setting up a new test class, <code>PasswordInputTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PasswordInputTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    
}</code></pre>

<p>We’ll start here by creating a new test, composing the <code>PasswordInput </code> composable. We’ll provide empty implementations for the <code>onPasswordChanged</code> and <code>onDoneClicked</code> arguments, but will need to provide a string value for the <code>password</code> argument. We’ll create a string variable reference here, providing this to our <code>PasswordInput</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> password <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password123&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordInput</span>(
            password <span class="syntax-all syntax-keyword">=</span> password,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {  },
            onDoneClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Next, we’ll need to assert that this <code>password</code> value is in fact displayed inside of our composable. In a previous test, we defined the <code>TAG_INPUT_PASSWORD</code> tag, so we’ll use this here to locate the node that represents our password text field. Once this node has been located we can utilise the <code>assertTextEquals</code> function to assert that the text semantic value of the node matches our provided <code>password</code> variable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> password <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password123&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordInput</span>(
            password <span class="syntax-all syntax-keyword">=</span> password,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {  },
            onDoneClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_INPUT_PASSWORD</span>)
        .assertTextEquals(password)
}</code></pre>

<p>With this test in place, we can now be certain that a passing test means the provided <code>password</code> value is going to be displayed inside of our composable. When the user enters content into the text field to update this <code>password</code> value that is coming from our state, the lambda function that is provided to the composable is triggered - this is the <code>onPasswordChanged</code> lambda. If this for some reason was not being triggered, the user would be unable to enter their password into the text field. To ensure this remains function, let’s write a quick test to assert that this event does occur.</p>

<p>As before, we’ll need to compose the <code>PasswordInput</code> composable to perform our assertions against. We’ll need to provide a string value for the <code>password</code> argument - we’ll create a variable reference for this so that we can assert the lambda is triggered with the expected value. We’re also going to pass in a <code>mock</code> lambda function for the <code>onPasswordChanged</code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based off of composable events.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Changed_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onEmailChanged<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> password <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password123&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordInput</span>(
            password <span class="syntax-all syntax-keyword">=</span> password,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {  },
            onDoneClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>While we have provided this lambda to our composable, we now need to trigger it so that we can verify the expected behaviour. To trigger this lambda we need to enter some text into the input field, which we can do so using the <code>performTextInput</code> on a specified node. We’re going to append some text onto the existing input, which we’ll store in a variable reference, <code>appendedText</code> so that we can use this during the assertion. Here we’ll locate the input field node using our existing tag, followed by inputting this content using the <code>performTextInput</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> passwordText <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;456&quot;</span>
composeTestRule
    .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_INPUT_PASSWORD</span>)
    .performTextInput(passwordText)</code></pre>

<p>With this in place, we can now add the check to verify that the lambda function is called as expected. When this is triggered, we would expect that the <code>password</code> value returned here would represent the existing content with the addition of the <code>appendedText</code> value. We can verify this within our test by using mockito and its <code>verify</code> function to assert that the lambda has been invoked with the existing value in the input field (<code>password</code>) appended with the value of <code>appendedText</code>. If this is the case, the test will succeed - otherwise, the lambda not being triggered will mean that our verification will not be satisfied and the test will fail.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Changed_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onEmailChanged<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> password <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password123&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordInput</span>(
            password <span class="syntax-all syntax-keyword">=</span> password,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {  },
            onDoneClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    <span class="syntax-all syntax-keyword">val</span> passwordText <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;456&quot;</span>
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_INPUT_PASSWORD</span>)
        .performTextInput(passwordText)

    verify(onEmailChanged).invoke(password <span class="syntax-all syntax-keyword">+</span> passwordText)
}</code></pre>

<p>When it comes to the <code>PasswordInput</code> composable, we implemented the ability to toggle the visibility of the password using a visibility toggle button. We’re going to write a test to assert that the state of this is reflected correctly, based on the internal state of the function that is being used to manage the password visibility.</p>

<p>When it comes to testing this, we’ll just write a single test to check that the visibility toggle composable reflects the expected state. We’ll need to start here by adding a new tag to our <code>Tags</code> object so that we can locate and interact with the visibility composable. We’ll end this tag with an underscore so that we can append the current boolean value of the toggle to the tag, meaning that we can locate the tag based on the enabled state of the toggle.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PASSWORD_HIDDEN</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password_hidden_&quot;</span>
}</code></pre>

<p>Next, we’ll need to assign this tag our composable using the <code>testTag</code> function. When doing this we’ll also append the current value of our <code>isPasswordHidden</code> state, so that we can locate the node using this value. We do this as if the value is not aligned as expected, then the node won’t be found and the tests will fail.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PasswordInput.kt
</span>
trailingIcon <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">Icon</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_PASSWORD_HIDDEN</span> <span class="syntax-all syntax-keyword">+</span> isPasswordHidden),
		...
    )
}</code></pre>

<p>With this in place, we can now start working on the test. Here we’ll begin by composing the <code>PasswordInput</code> with a string value for the <code>password</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Toggled_Reflects_state</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordInput</span>(
            password <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password123&quot;</span>,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {  },
            onDoneClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>We’ll then want to locate the visibility toggle composable. By default the visibility flag will be <strong>true</strong>, signifying that the password is hidden. Here we’re going to locate the node with the value of true appended to the tag, click on it and then assert that the tag with the value of false appended to the tag is displayed. Here we’re going to start by locating the node for the hidden state of our visibility toggle composable - we’ll need this so that we can perform a click interaction on the composable. Here we’ll use the <code>TAG_PASSWORD_HIDDEN</code> tag, appending the value of <strong>true</strong> on the end to match the expected condition of the state for the password visibility.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Toggled_Reflects_state</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordInput</span>(
            password <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password123&quot;</span>,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {  },
            onDoneClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PASSWORD_HIDDEN</span> <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-string">&quot;true&quot;</span>)
        .performClick()
}</code></pre>

<p>With this in place, we are not performing a click interaction on the composable, this means that now the composable state should have recomposed the visibility toggle composable. This means that now, a node with the <code>TAG_PASSWORD_HIDDEN</code> tag for the visible state of the password should be visible. We can assert this here using the <code>assertIsDisplayed</code> function on the located node.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Toggled_Reflects_state</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordInput</span>(
            password <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;password123&quot;</span>,
            onPasswordChanged <span class="syntax-all syntax-keyword">=</span> {  },
            onDoneClicked <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PASSWORD_HIDDEN</span> <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-string">&quot;true&quot;</span>)
        .performClick()

    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PASSWORD_HIDDEN</span> <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-string">&quot;false&quot;</span>)
        .assertIsDisplayed()
}</code></pre>

<p>While we could have a separate test here to assert that the true condition is displayed, this test covers both scenarios. This is because the first <code>onNodeWithTag</code> call will fail the test if the node is not found - this will mean that the tag for the hidden state of the visibility toggle would not currently be being displayed on the screen. Because this test requires the hidden state of the visibility toggle to perform the <code>assertIsDisplayed</code> assertion, we cover both scenarios in a single test.</p>

<hr />

<h2>Testing the Password Requirements</h2>

<p>While we’re verifying the entry of a password from the tests above, our user is still required to enter a password that meets the minimum requirements that are defined within our ViewModel. These requirements are communicated to the user via the <code>PasswordRequirements</code> composable, with the composable containing logic to depict the message to be displayed based on the provided requirement statuses. So here, we’ll write some tests here to verify that this composable is operating as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PasswordRequirementsTest.kt
</span>
<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PasswordRequirementsTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    
}</code></pre>

<p>We’re first going to write a test to assert that each of the password requirements is displayed as expected. To keep things simple here and avoid needing to write multiple test conditions, we’re going to write a test that will assign random password requirements as satisfied. This way we can assert that expected requirements are displayed as both satisfied and unsatisfied.</p>

<p>We’re going to start here by retrieving the list of available requirements from our <code>PasswordRequirement</code> type, along with getting a random item from this list to be used as the satisfied requirement.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> requirements <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PasswordRequirement</span>.values().toList()
<span class="syntax-all syntax-keyword">val</span> satisfiedRequirement <span class="syntax-all syntax-keyword">=</span> requirements[(<span class="syntax-all syntax-constant">0</span> until requirements.count()).random()]</code></pre>

<p>We could use a random number of satisfied requirements to vary the number between tests, but we’ll use a single one here to keep things simple for examples sake. We’ll next compose a <code>PasswordRequirements</code>, providing a list for the <code>satisfiedRequirements</code> argument that consists of the random requirement that we retrieved above, <code>satisfiedRequirement</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Requirements_Displayed_As_Not_Satisfied</span>() {
    <span class="syntax-all syntax-keyword">val</span> requirements <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PasswordRequirement</span>.values().toList()
	<span class="syntax-all syntax-keyword">val</span> satisfiedRequirement <span class="syntax-all syntax-keyword">=</span> requirements[(<span class="syntax-all syntax-constant">0</span> until requirements.count()).random()]

	composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordRequirements</span>(
            satisfiedRequirements <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(satisfied)
        )
    }
}</code></pre>

<p>When the <code>PasswordRequirements</code> is composed, it should be the case that the requirements are composed based on the satisfied requirements that are provided. To test this we’re going to need to start by looping through each of the available <code>PasswordRequirement</code> values: </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PasswordRequirement</span>.values().forEach {
        
}</code></pre>

<p>Next, we’ll use each of their labels, along with the provided <code>satisfiedRequirement</code> to build the string that we’re going to assert for. The <code>PasswordRequirements</code> composable is formatting two different string representations based on the satisfied state of each. If a requirement is marked as satisfied, then the <code>password_requirement_satisfied</code> resource is used to build a string for that requirement, otherwise the <code>password_requirement_needed</code> is used. Here for each of the requirements in the loop, we’re going to retrieve the string for the label of the requirement, along with building a string based on whether the requirement in the loop matches the <code>satisfiedRequirement</code> that we configured earlier in the test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PasswordRequirement</span>.values().forEach { requirement <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> requirement <span class="syntax-all syntax-keyword">=</span>
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(it.label)

	<span class="syntax-all syntax-keyword">val</span> result <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (requirement <span class="syntax-all syntax-keyword">==</span> satisfiedRequirement) {
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(
				<span class="syntax-all syntax-entity">R</span>.string.password_requirement_satisfied, 
					requirement)
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(
				<span class="syntax-all syntax-entity">R</span>.string.password_requirement_needed, 
					requirement)
    }
}</code></pre>

<p>Now, this string is being built, we can use this to locate a node and perform an assertion to ensure that it is being displayed within the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PasswordRequirement</span>.values().forEach { requirement <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> requirement <span class="syntax-all syntax-keyword">=</span>
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(it.label)
	<span class="syntax-all syntax-keyword">val</span> result <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (requirement <span class="syntax-all syntax-keyword">==</span> satisfiedRequirement) {
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(
				<span class="syntax-all syntax-entity">R</span>.string.password_requirement_satisfied, 
					requirement)
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.context.getString(
				<span class="syntax-all syntax-entity">R</span>.string.password_requirement_needed, 
					requirement)
    }

    composeTestRule
        .onNodeWithText(result)
        .assertIsDisplayed()
}</code></pre>

<p>With this loop, our test is now looping through each of the available<code>PasswordRequirement</code> values and asserting that the expected requirement message is displayed within the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Password_Requirements_Displayed_With_State</span>() {

    <span class="syntax-all syntax-keyword">val</span> requirements <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PasswordRequirement</span>.values().toList()
    <span class="syntax-all syntax-keyword">val</span> satisfied <span class="syntax-all syntax-keyword">=</span> requirements[(<span class="syntax-all syntax-constant">0</span> until <span class="syntax-all syntax-constant">3</span>).random()]

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PasswordRequirements</span>(
            satisfiedRequirements <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(satisfied)
        )
    }
    <span class="syntax-all syntax-entity">PasswordRequirement</span>.values().forEach {
        <span class="syntax-all syntax-keyword">val</span> requirement <span class="syntax-all syntax-keyword">=</span>
			<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(it.label)
        <span class="syntax-all syntax-keyword">val</span> result <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (it <span class="syntax-all syntax-keyword">==</span> satisfied) {
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.password_requirement_satisfied, 
					requirement)
        } <span class="syntax-all syntax-keyword">else</span> {
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(
					<span class="syntax-all syntax-entity">R</span>.string.password_requirement_needed, 
					requirement)
        }

        composeTestRule
            .onNodeWithText(result)
            .assertIsDisplayed()
    }
}</code></pre>

<hr />

<h2>Testing the Error Dialog</h2>

<p>Within our collection of composables for the authentication screen, we also have the <code>AuthenticationErrorDialog</code> that is used to display errors to the user. While this only features two arguments that are used to display and dismiss the error, these are key to the operation of the dialog, so we’ll add some tests to assert that these operate as expected. These tests will live inside of a new test class, <code>AuthenticationErrorDialogTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">AuthenticationErrorDialogTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    
}</code></pre>

<p>We’ll start here by writing a test that will be used to assert that the provided <code>error</code> message is displayed within our dialog as expected. Here we’ll need to define a new test that will be used to house this test logic, composing an <code>AuthenticationErrorDialog</code> that will be composed using the provided <code>error</code> reference. With this composition in place, we can then use our text rule to assert that there is a node displayed that has the exact text being provided via the <code>error</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Error_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> error <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;This is an error&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
            error <span class="syntax-all syntax-keyword">=</span> error,
            dismissError <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithText(error)
        .assertTextEquals(error)
}</code></pre>

<p>When it comes to dismissing the dialog, the <code>AuthenticationErrorDialog</code> composable takes a <code>dismissError</code> argument that is used to notify the parent composable that dismissal has been requested and our state needs to be updated. If this was broken for some reason, then the user wouldn’t be able to dismiss the dialog and be unable to perform authentication.</p>

<p>Similar to other tests that we’ve written for these composables, we’re going to use mockito to provide a mock implementation of our <code>dismissError</code>, followed by verifying that the lambda has been invoked when expected. After composing this <code>AuthenticationErrorDialog</code> and providing the required arguments, we can trigger the dismissal by clicking the node the has the <code>error_action</code> string resource assigned to it. When this is clicked, it is expected that the dismissal lambda will be triggered. So here we’ll use the <code>verify</code> function from mockito to verify that the <code>dismissError</code> lambda has been triggered as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dismiss_triggered_from_action</span>() {
    <span class="syntax-all syntax-keyword">val</span> dismissError<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">AuthenticationErrorDialog</span>(
            error <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;This is an error&quot;</span>,
            dismissError <span class="syntax-all syntax-keyword">=</span> dismissError
        )
    }
    composeTestRule
        .onNodeWithText(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.context.getString(<span class="syntax-all syntax-entity">R</span>.string.error_action)
        )
        .performClick()

    verify(dismissError).invoke()
}</code></pre>

<hr />

<p>With all of these tests in place, we’ve covered a lot of different cases that help to ensure our UI is working as expected. We’ve not only tested that composables are being composed based on the information that they are provided with, but also that they triggered the expected callbacks and trigger state manipulations within our composables. While the tests here aren’t extensive, we’ve been able to learn not only what options are available to us while testing composables, but also the approaches that we can take when doing so.</p>

<h1>Building a Home Screen</h1>

<p>In any application, there will be some form of dashboard at the root of the app, somewhere that your users may end up at when launching the app or return there after completing any kind of task. Whether you call it the root of your application, dashboard or Home Screen (or some other name!) - this is a core location that enables users to reach different destinations around your app. </p>

<p>When we start to talk about different destinations, we also need to think about how these destinations are represented within an app - how are they represented as destinations, how are they laid out and how are they navigated between. Jetpack Compose features a range of different Composables and functionality that allows for seamless integration of those requirements, which we’ll be using to build a simple App skeleton consisting of a Home Screen with several navigable destinations.</p>

<figure><img src="nav.png"/></figure>

<p>In this chapter, we’ll be building the above flow - allowing the user to navigate between root-level destinations using the Bottom Bar, alongside navigating into destinations from the navigation drawer. This glow will result in a composable structure represented like so:</p>

<figure><img src="intro-2.png"/></figure>

<p>At a first glance, this screen might look quite minimal, but there is a collection of things going on that allow us to provide these different navigation routes. With this in mind, we’ll need to:</p>

<ul>
	<li>Create a root Scaffold that acts as the base of our application</li>
	<li>Add a Bottom Navigation Bar which can be used to navigate to root level destinations inside of our app, when the device is in portrait mode</li>
	<li>Add a Navigation Rail which can be used to navigate to root level destinations inside of our app, when the device is in landscape mode</li>
	<li> Add a Navigation drawer that can be used to navigate to non-root destinations inside of our app</li>
	<li>Use the Compose navigation component to navigate between these different destinations</li>
	<li>Create nested navigation graphs to separate our destinations into feature sets</li>
</ul>

<p>While we won’t be building out the visuals of the different content areas that make up our sample UI, we’ll be learning about how we can build out a central location in our app as well as how to move between the different destinations that the app consists of. Alongside working with some key composables (such as the Scaffold and Bottom Navigation), this allows us to get some experience with the Compose navigation components and the different ways of handling navigation.</p>

<h1>Creating the Home Scaffold</h1>

<figure><img src="2-11.png"/></figure>

<p>Before we can start building out the different destinations that can be navigated between, we’re going to look at setting up the Scaffold of our Home Screen. The Scaffold is a top-level container that is intended to provide a screen with a material structure, providing ways to layout different material components into their corresponding positions within a screen. A <code>Scaffold</code> isn’t a mandatory component, but it can allow you to implement a standard appearance for navigational components without the need to implement this kind of layout for yourself. For examples sake, we can see that the scaffold composable function contains an argument for a range of composables. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Scaffold</span>(
  <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
  <span class="syntax-all syntax-parameter">scaffoldState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ScaffoldState</span> <span class="syntax-all syntax-keyword">=</span> rememberScaffoldState(),
  <span class="syntax-all syntax-parameter">topBar</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> {},
  <span class="syntax-all syntax-parameter">bottomBar</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> {},
  <span class="syntax-all syntax-parameter">floatingActionButton</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> {},
  <span class="syntax-all syntax-parameter">drawerContent</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> (<span class="syntax-all syntax-entity">ColumnScope</span>.() <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>)? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
  <span class="syntax-all syntax-parameter">content</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> (<span class="syntax-all syntax-entity">PaddingValues</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
  ...
)</code></pre>

<p>These will then be used to layout the content of our Material layout. While we’re going to be using this Scaffold throughout the different screens that we’re building, we’re going to start by adding this to the top-level destination of our exercise. It’s important to note that the Scaffold is an optional implementation detail - while it provides a frictionless way to add these Material components to a screen, you can still achieve similar layouts without using the Scaffold. The Scaffold can currently introduce limitations if you’re looking to perform certain animations or custom transitions, but that might change as Compose matures. Either way, the Scaffold is a great way to reduce the complexity of implementing Material style screens.</p>

<p>With this in mind, we’ll start by defining a top-level composable that is going to be used to house our screen scaffold, providing a default <code>modifier</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Home.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Home</span>(<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>)</code></pre>

<p>While you won’t see anything visual just yet, you’ll want to compose this <code>Home</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Home</code> when running the project.</p>

<p>With this in place, we’re next going to implement the Scaffold for the Home Screen of our app. This will involve using the Scaffold composable function, along with providing a reference to a <code>ScaffoldState</code> - this class will hold a reference to the state of our drawer implementation, along with the snackbar host. These are both things that we will be configuring later on in this section, so for now we’ll remember a scaffold state that does not build on either of these concepts. For this, we can utilise the <code>rememberScaffoldState</code> function to create <strong>and</strong> remember this for us, allowing the scaffold state to be persisted across recompositions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberScaffoldState()
<span class="syntax-all syntax-entity">Scaffold</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
	scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState
) {
  <span class="syntax-all syntax-comment">// add scaffold content
</span>}</code></pre>

<p>💡 There are many remember functions in the jetpack compose APIs. These are all used to create and remember the desired class, allowing you to avoid redefining this logic every time you are looking to implement such behaviour in your project.</p>

<p>You’ll notice here that we have provided an empty block for the <strong>content</strong> argument of the Scaffold composable. This argument takes the content for the body of our scaffold in the form of a composable, this is essentially the main content of your screen - which we will be adding further in this section. However, this is a required argument so for now we’ll provide an empty block without any composable content.</p>

<hr />

<h2>Composing the Top App Bar</h2>

<figure><img src="3-11.png"/></figure>

<p>With our Scaffold in place, we can start building out the different component sections that we want to support within our UI. For this we’re going to start by providing a Top Bar to be shown at the top of our screen, doing so in the form of the <code>TopAppBar</code> composable. This composable function takes a collection of arguments, with the only required on being the <code>title</code>. For now, this is all that we’re going to utilise within our <code>TopAppBar</code>, so we’ll go ahead and add the composable along with a simple title in the form of a <code>Text</code> composable.</p>

<p>And then adding the composable implementation, referencing this string resource when building out the text for our title composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Home</span>(<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>) {
	<span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberScaffoldState()
	<span class="syntax-all syntax-entity">Scaffold</span>(
  		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
  		topBar <span class="syntax-all syntax-keyword">=</span> {
    		<span class="syntax-all syntax-entity">TopAppBar</span>(
      			title <span class="syntax-all syntax-keyword">=</span> {
        			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Home&quot;</span>)
      			}
    		)
  		}
	) {

	}
}</code></pre>

<p>With this top bar in place, we’ll be able to it composed within our UI, containing the title that we’ve included above.</p>

<figure><img src="1-13.png"/></figure>

<hr />

<h2>Composing the Floating Action Button</h2>

<figure><img src="4-6.png"/></figure>

<p>Now that we’ve got the foundations of our Scaffold in place, we’re going to add the next component to our layout - this time utilising the <code>floatingActionButton</code> argument from the Scaffold function. For this, we’ll go ahead and utilise the <code>FloatingActionButton</code> composable, providing placeholders for its two requirement arguments - <code>onClick</code> and <code>content</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
  ...,
  floatingActionButton <span class="syntax-all syntax-keyword">=</span> {
    <span class="syntax-all syntax-entity">FloatingActionButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
      <span class="syntax-all syntax-comment">// handle FAB click
</span>    }) {
      <span class="syntax-all syntax-comment">// add content for the FAB
</span>    }
  }
) {
  ...
}</code></pre>

<p>For now, we’re not going to do anything when the button is clicked, that’ll come later once we start implementing the navigation for our screen. However, we are going to add some content to be displayed inside of the button in the form of an Icon. This <code>Icon</code> composable is going to need to be provided with the icon that we want to display, along with a content description that describes the intent of that icon. We’ll start here by adding a new content description for this to our string resource file - because our button doesn’t contain any text, this helps to ensure that our button remains accessible for those using screen readers.</p>

<pre><code class="code-highlighted code-xml">// strings.xml
&lt;<span class="syntax-all syntax-tag">resources</span>&gt;
    &lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_create_item&quot;</span>&gt;Create a new item&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;/<span class="syntax-all syntax-tag">resources</span>&gt;</code></pre>

<p>Next, we will need to add the implementation for the Icon of our button. Here we’ll use the Icon composable function, using the Compose material icons package to provide an Icon in the form of ‘+’, along with adding our string resource for the content description to be used for this icon.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
  ...,
  floatingActionButton <span class="syntax-all syntax-keyword">=</span> {
    <span class="syntax-all syntax-entity">FloatingActionButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
      <span class="syntax-all syntax-comment">// handle FAB click
</span>    }) {
      <span class="syntax-all syntax-entity">Icon</span>(
        imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Add</span>,
        contentDescription <span class="syntax-all syntax-keyword">=</span>
          stringResource(<span class="syntax-all syntax-entity">R</span>.string.cd_create_item)
      )
    }
  }
) {
  ...
}</code></pre>

<p>With all of the above in place, we have a minimal Scaffold implementation. While this will be currently showing a blank content area, we have a <code>TopAppBar</code> displaying the title of our screen, along with a <code>FloatingActionButton</code> that would be used to take the user to some form of content creation screen within our app.</p>

<figure><img src="2-12.png"/></figure>

<h1>Creating the Navigation Destinations</h1>

<p>Now that we’ve got our <code>Scaffold</code> created, we can start thinking about building out the navigation features of our screen. Overall we’re going to be building three different points of navigation for this screen - the <strong>bottom navigation bar</strong>, the <strong>navigation drawer</strong> and the <strong>floating action button navigation path</strong>. For each of the pieces inside of these navigation areas, we’re going to need to define the destinations that are supported. Because each of the destinations in these areas is going to require both a <strong>path</strong> and <strong>icon</strong>, we’ll create a way of enforcing these details using a sealed class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Destination.kt
</span><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Destination</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">path</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">icon</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ImageVector?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {

}</code></pre>

<p>This sealed class now means that we can declare all of the different destinations that are supported by the navigation of our app, keeping the details of those destinations grouped into their corresponding Destination type.</p>

<p>To see what this would look like, let’s begin by adding a destination for the <strong>Home</strong> destination of our app - this is going to be the first screen of our application where the bottom bar is displayed. Because this does not have the specific concept of a navigation destination, this destination will be used for when we want to navigate to the Home Screen of our app, as opposed to a specific destination within the Home Screen. Because of this, we won’t need to provide an icon here - instead, just a path in the form of “home”.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Destination</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">path</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">icon</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ImageVector?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {

    <span class="syntax-all syntax-keyword">object</span> Home <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(&quot;home&quot;)

}</code></pre>

<p>With this concept of “home” in place, we can now go ahead and add the individual destinations for each of these home destinations. At the point of the Home in our app, the user is going to move between the <strong>Feed</strong>, <strong>Contacts</strong> and <strong>Calendar</strong> destinations from our bottom bar. For these items, we’ll also be adding icons, as these destinations are going to be displaying icons at the places they can be triggered from.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Destination</span>(
	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">path</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">icon</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ImageVector?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {

    <span class="syntax-all syntax-keyword">object</span> Home <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(&quot;home&quot;)

    <span class="syntax-all syntax-keyword">object</span> Feed <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(&quot;feed&quot;, <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-constant">List</span>)

    <span class="syntax-all syntax-keyword">object</span> Contacts <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	  &quot;contacts&quot;, 
	  <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Person</span>
	)

    <span class="syntax-all syntax-keyword">object</span> Calendar <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	  &quot;calendar&quot;, 
	  <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">DateRange</span>
	)
}</code></pre>

<p>Here, we’ve added a new destination object for each of these destinations within the <strong>Home</strong> of our app. Alongside adding a path in the form of a string value, we’ve added an icon for each one of these destinations. With these in place, we’re now ready to start looking at implementing the navigation for our project.</p>

<h1>Creating a Content Area</h1>

<p>With our Destinations in place, we’re going to look at creating a composable that will be used to show some placeholder content for each destination. When it comes to each destination, we won’t be focusing on creating a whole screen of content, instead just a plain composable that gives us something to navigate to. If you wish to extend this further and create content for each destination, go for it! With this in mind, let’s get started - we’re going to begin by creating a new composable function, <code>ContentArea</code>. This is going to take a default <code>Modifier</code> argument, along with a reference to a <code>Destination</code> - this will be the current destination that is being shown on screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ContentArea</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>
)</code></pre>

<p>As per the design, we’re going to simply display the icon for the destination, along with the title beneath it. Because we are vertically stacking composables, we’re going to utilise the <code>Column</code> composable. When composing this we’re going to pass the <code>modifier</code> from our function arguments, as well as configuring the <code>verticalArrangement</code> and <code>horizontalAlignment</code> arguments so that our content is aligned within the center of the column.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ContentArea</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>,
      	horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
    ) {
		
    }
}</code></pre>

<p>Next, we’re going to add the icon and text children to the <code>Column</code> composable. Within our <code>Destination</code> reference, the <code>icon</code> property is nullable - so we’re only going to want to compose an icon if one is available. We’ll do this by wrapping the composition of our <code>Icon</code> composable in a <code>let</code> block to give us some null safety. If there is an icon available, then the <code>Icon</code> will be composed using the provided data from our <code>Destination</code> reference, along with a supporting <code>Spacer</code> composable to create some visual spacing beneath it.</p>

<pre><code class="code-highlighted code-kt">destination.icon?.<span class="syntax-all syntax-constant">let</span> { icon <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-entity">Icon</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">80</span>.dp),
       	imageVector <span class="syntax-all syntax-keyword">=</span> icon,
        contentDescription <span class="syntax-all syntax-keyword">=</span> destination.title
   	)
    <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
}</code></pre>

<p>Outside of this <code>let</code> block, we then want to compose a <code>Text</code> composable, using the <code>title</code> property from our <code>Destination</code> reference. We’ll also override the default sizing for this to <code>18sp</code>.</p>

<pre><code class="code-highlighted code-kt">destination.icon?.<span class="syntax-all syntax-constant">let</span> { icon <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-entity">Icon</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">80</span>.dp),
       	imageVector <span class="syntax-all syntax-keyword">=</span> icon,
        contentDescription <span class="syntax-all syntax-keyword">=</span> destination.title
   	)
    <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
}
            
<span class="syntax-all syntax-entity">Text</span>(
    text <span class="syntax-all syntax-keyword">=</span> destination.title,
    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
)</code></pre>

<p>With this in place, we now have a simple <code>ContentArea</code> composable that allows us to move forward with implementing navigation within our project.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ContentArea</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>,
      	horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
    ) {
		destination.icon?.<span class="syntax-all syntax-constant">let</span> { icon <span class="syntax-all syntax-keyword">-&gt;</span>
			<span class="syntax-all syntax-entity">Icon</span>(
               	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">80</span>.dp),
               	imageVector <span class="syntax-all syntax-keyword">=</span> icon,
               	contentDescription <span class="syntax-all syntax-keyword">=</span> destination.title
           	)
           	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
		}
            
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> destination.title,
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.sp
        )
    }
}</code></pre>

<figure><img src="3-12.png"/></figure>

<hr />

<h1>Creating the Navigation Graph</h1>

<figure><img src="5-6.png"/></figure>

<p>Now that we have our navigation destinations defined, we can start looking at implementing the navigation based on those destinations. So here we’re going to build a navigation graph that will support us in adding navigation to our app. For this we’re going to utilise the compose navigation component - this is an official android package that allows us to define a navigation graph for our app. This greatly simplifies the implementation of moving between different composables, allowing us to focus on building great apps for our users. We’re going to start here by adding a dependency for this package. </p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.navigation:navigation-compose:2.4.0-beta02&quot;</span></code></pre>

<p>Before we start defining this graph, we’re going to create a new composable function, <code>Navigation</code>. This allows us to separate our navigation logic from our base composable, keeping all of this contained in a single place.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Navigation.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) </code></pre>

<p>With our project synced, we will now have access to the classes that are required to add composable navigation into our app. Within our <code>Navigation</code> composable we’re going to declare a <code>NavHost</code> composable - as per the documentation, this composable provides a place in the Compose hierarchy for self-contained navigation to occur. This means that this host is going to be responsible for defining the navigation graph, its destinations and the content that should be composed for each of them. We’re going to start by adding a reference to this composable within our <code>Navigation</code>, passing the provided modifier argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">NavHost</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    )
}</code></pre>

<p>You’ll notice here though that the IDE will be complaining - this is because we are missing three required arguments - the <strong>navController</strong>, <strong>startDestination</strong> and <strong>builder</strong>. We’ll start here by looking at the required <strong>navController</strong>, this requires a <code>NavHostController</code> reference. This is a class that is used to control the navigation of our app - so if the user performs an action that should trigger a navigation event then we will use this controller to instruct our navigation graph accordingly. We’re aren’t going to be performing actions on the <code>NavHostController</code> within this function, this is all going to be done within the parent composable - but we do need a reference to it here. So what we’ll do is add a constructor argument for the <code>NavHostController</code> and then pass this directly to the <code>navController</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>
) {
    <span class="syntax-all syntax-entity">NavHost</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        navController <span class="syntax-all syntax-keyword">=</span> navController
    )
}</code></pre>

<p>Alongside providing the NavHostController we also need to define the <strong>startDestination</strong> of our graph - this is going to be the destination that we want the graph to be started at, in other words, the first composable that is going to be displayed. When defining the <strong>startDestination</strong>, this value will need to match the path of the composable that you are wishing to reference. For this, we will go ahead and use the path of the Home Destination that we previously defined. Our graph is going to be starting at the <code>Feed</code> destination, so we’ll use this to provide the <code>path</code> property of this destination to the <code>startDestination</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">NavHost</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
  	navController <span class="syntax-all syntax-keyword">=</span> navController, 
  	startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path
) {
     
}</code></pre>

<p>With our start destination in place, we can now go ahead and add the destinations to our graph. These destinations are to be defined within the <code>NavGraphBuilder</code> block of the NavHost composable, for which we’ll use the composable extension function. This function allows us to provide a collection of different arguments, each of which is specific to the destination that I being defined.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">fun</span> NavGraphBuilder.<span class="syntax-all syntax-entity">composable</span>(
    <span class="syntax-all syntax-parameter">route</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">arguments</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">NamedNavArgument</span>&gt; <span class="syntax-all syntax-keyword">=</span> emptyList(),
    <span class="syntax-all syntax-parameter">deepLinks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">NavDeepLink</span>&gt; <span class="syntax-all syntax-keyword">=</span> emptyList(),
    <span class="syntax-all syntax-parameter">content</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> (<span class="syntax-all syntax-entity">NavBackStackEntry</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Currently, we’re only going to be defining the required argument of this function, the <strong>route</strong>. We’ll start by doing this for the first destination of our bottom navigation, the Feed. Here we’ll utilise the <strong>composable</strong> extension function, providing a reference to the path of our <strong>Feed</strong> destination that we previously defined. We won’t define anything for the composable content of this destination yet, for now, we just want to get the foundations of our graph in place.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">NavHost</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
  	navController <span class="syntax-all syntax-keyword">=</span> navController, 
  	startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path
) {
        
  composable(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) { }
     
}</code></pre>

<p>Now that we have the <strong>Feed</strong> destination defined, we’ll go ahead and do the same for the other destinations in our bottom navigation - the <strong>Contacts</strong> and <strong>Calendar</strong> destinations.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">NavHost</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
  	navController <span class="syntax-all syntax-keyword">=</span> navController, 
  	startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path
) {
        
  composable(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) { }

  composable(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>.path) { }

  composable(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.path) { }
     
}</code></pre>

<p>With the above in place, we now have the Navigation Graph defined for our bottom navigation bar, with each of the required destinations defined within our graph. At this point though, none of them will be navigating to any composables. In the last chapter we created a <code>ContentArea</code> composable to render some basic UI for a given <code>Destination</code> - we’ll use this here to allow navigation between composables. For each of our <code>NavGraphBuilder.composable</code> declarations, we’re going to compose a <code>ContentArea</code>. When composing this we will need to provide a reference to a given <code>Destination</code>, along with a modifier to declare how this show be composed within our UI. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">NavHost</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> modifier,
	navController <span class="syntax-all syntax-keyword">=</span> navController,
	startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path
) {
  	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) {
		<span class="syntax-all syntax-entity">ContentArea</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>
		)
    }
    composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>.path) {
        <span class="syntax-all syntax-entity">ContentArea</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
		)
    }
    composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.path) {
        <span class="syntax-all syntax-entity">ContentArea</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
		)
    }
}</code></pre>

<p>💡Remember, it’s good to allow parent composables to control how the child composable is being composed in terms of layout constraints. This keeps layout logic outside of our child composables, allowing them to be reusable across different scenarios in our application.</p>

<p>With the above in place, we now have a complete <code>Navigation</code> composable that defines the graph for our navigation, allowing us to support navigation between different composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>
) {
    <span class="syntax-all syntax-entity">NavHost</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        navController <span class="syntax-all syntax-keyword">=</span> navController,
		startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path
    ) {
    	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) {
			<span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>)
        }
        composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>.path) {
            <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>)
        }
        composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.path) {
            <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>)
        }
    }
}</code></pre>

<p>Hopping back over to our <code>Home</code> composable, we can now compose this <code>Navigation</code> within the <code>content</code> of our <code>Scaffold</code>. We’ll first need to </p>

<p>obtain a reference to a <code>NavHostController</code>, as this is a required argument for our <code>Navigation</code> composable. For this we can use the <code>rememberNavController()</code> function that is provided by compose navigation package. This will create an instance of a <code>NavHostController</code> and persist it across recompositions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> navController <span class="syntax-all syntax-keyword">=</span> rememberNavController()</code></pre>

<p>We can then use this reference to compose our <code>Navigation</code> within the <code>Scaffold</code> content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Home</span>(<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>) {
	<span class="syntax-all syntax-keyword">val</span> navController <span class="syntax-all syntax-keyword">=</span> rememberNavController()
	<span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberScaffoldState()
	<span class="syntax-all syntax-entity">Scaffold</span>(
  		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
  		topBar <span class="syntax-all syntax-keyword">=</span> {
    		<span class="syntax-all syntax-entity">TopAppBar</span>(
      			title <span class="syntax-all syntax-keyword">=</span> {
        			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Home&quot;</span>)
      			}
    		)
  		}
	) {
		<span class="syntax-all syntax-entity">Navigation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            navController <span class="syntax-all syntax-keyword">=</span> navController
        )
	}
}</code></pre>

<p>When viewing this composable, you should now be able to see the start destination of our navigation graph, the Feed.</p>

<figure><img src="4-7.png"/></figure>

<h1>Creating a Bottom Navigation Bar</h1>

<figure><img src="6-4.png"/></figure>

<p>Now that we have our navigation graph defined, a natural next step is to create the UI component that can be used to trigger those navigation events for our graph. We’re going to create a new composable function, <code>BottomNavigationBar</code>, that will need a couple of different arguments applied to it:</p>

<ul>
	<li><strong>modifier</strong>: the modifier used by the parent composable to control how the bottom navigation bar is composed</li>
	<li><strong>currentDestination</strong>: the currently selected destination in the navigation graph. This is so that we can highlight that item within the bottom navigation bar</li>
	<li><strong>onNavigate</strong>: a lambda function that will allow us to pass navigation events up to the parent composable so that they can be handled accordingly</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>💡 The Bottom Navigation Bar allows for top-level navigation via a horizontal navigation bar to be shown at the bottom of a screen. This should be used to display between 3 and 5 navigation items.</p>

<p>We’ll start by composing a <code>BottomNavigation</code> - this is a composable from the compose material APIs that allows us to compose a collection of navigation items for the user to move between different destinations of our app. When composing this, we’ll pass the modifier argument from our composable function, because the <code>BottomNavigation</code> is going to be the top-level composable in our function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">BottomNavigation</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        
    }
}</code></pre>

<figure><img src="bar.png"/></figure>

<p>When it comes to the navigation items within our bottom navigation, we’re going to want to show one for each of the destinations that are currently defined in the navigation graph. We’ll create a list of these <code>Destination</code> references and then use the Kotlin <code>forEach</code> operator to allow us to loop through these and compose a navigation item for each one.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">BottomNavigation</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> modifier
) {
    <span class="syntax-all syntax-constant">listOf</span>(
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
    ).forEach {
            
    }
}</code></pre>

<p>When it comes to the navigation item that we’re going to be displaying in this bottom bar, we’ll be composing this with the use of the <code>BottomNavigationItem</code> composable. This is again from the compose material APIs, allowing us to display an item for a destination within our bottom bar. Let’s start building our <code>BottomNavigationItem</code> piece by piece, starting with the required <code>selected</code> argument. This argument tells the item whether it is the currently selected destination, allowing the composable to be styled accordingly. We’ll provide this <code>selected</code> flag by using the <code>currentDestination</code>that is being passed into the composable function - comparing the <code>path</code> property of this with the <code>path</code> of the destination within our <code>forEach</code> loop.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">BottomNavigationItem</span>(
	selected <span class="syntax-all syntax-keyword">=</span> currentDestination.path <span class="syntax-all syntax-keyword">==</span> it.path
)</code></pre>

<p>Next up we’ll add the implementation for another required argument, the <code>icon</code>. For this, we’ll take a similar approach as when we created the <code>ContentArea</code> composable - composing an <code>Icon</code> if there is an icon available for the given <code>Destination</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">BottomNavigationItem</span>(
	selected <span class="syntax-all syntax-keyword">=</span> currentDestination.path <span class="syntax-all syntax-keyword">==</span> it.path,
    icon <span class="syntax-all syntax-keyword">=</span> {
        it.icon?.<span class="syntax-all syntax-constant">let</span> { image <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> image, 
				contentDescription <span class="syntax-all syntax-keyword">=</span> it.path
			)
        }
    }
)</code></pre>

<p>💡 We check for the null status of the icon here as our Destination class has a nullable icon value. While we should expect an icon here, we lean into conditional composition to allow for situations where that might not be the case.</p>

<p>The final required argument is <code>onClick</code> - this requires us to implement a lambda function that will be used to handle click events on the navigation item. When creating our composable function, <code>BottomNavigationBar</code>, we defined an <code>onNavigate</code> lambda that is provided to our composable. Here we’ll simply want to trigger this lambda, pass the destination that we are currently composing the <code>BottomNavigationItem</code> for.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">BottomNavigationItem</span>(
	selected <span class="syntax-all syntax-keyword">=</span> currentDestination.path <span class="syntax-all syntax-keyword">==</span> it.path,
    icon <span class="syntax-all syntax-keyword">=</span> {
        it.icon?.<span class="syntax-all syntax-constant">let</span> { image <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> image, 
				contentDescription <span class="syntax-all syntax-keyword">=</span> it.path
			)
        }
    },
	onClick <span class="syntax-all syntax-keyword">=</span> {
        onNavigate(it)
    }
)</code></pre>

<p>We’ll wrap up the composition of our <code>BottomNavigationItem</code> by implementing one of its optional arguments, <code>label</code>. For this we’ll simply compose a <code>Text</code>, using the title of the destination that we are currently composing the <code>BottomNavigationItem</code> for.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">BottomNavigationItem</span>(
	selected <span class="syntax-all syntax-keyword">=</span> currentDestination.path <span class="syntax-all syntax-keyword">==</span> it.path,
    icon <span class="syntax-all syntax-keyword">=</span> {
        it.icon?.<span class="syntax-all syntax-constant">let</span> { image <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> image, 
				contentDescription <span class="syntax-all syntax-keyword">=</span> it.path
			)
        }
    },
	onClick <span class="syntax-all syntax-keyword">=</span> {
        onNavigate(it)
    },
    label <span class="syntax-all syntax-keyword">=</span> {
        <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> it.title)
    }
)</code></pre>

<p>With this in place, we now have our <code>BottomNavigationBar</code> composable implemented and ready to use.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">BottomNavigation</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-constant">listOf</span>(
            <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
            <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
        ).forEach {
            <span class="syntax-all syntax-entity">BottomNavigationItem</span>(
                selected <span class="syntax-all syntax-keyword">=</span> currentDestination.path <span class="syntax-all syntax-keyword">==</span> it.path,
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    onNavigate(it)
                },
                icon <span class="syntax-all syntax-keyword">=</span> {
                    it.icon?.<span class="syntax-all syntax-constant">let</span> { image <span class="syntax-all syntax-keyword">-&gt;</span>
                        <span class="syntax-all syntax-entity">Icon</span>(
							imageVector <span class="syntax-all syntax-keyword">=</span> image, 
							contentDescription <span class="syntax-all syntax-keyword">=</span> it.path
						)
                    }
                },
                label <span class="syntax-all syntax-keyword">=</span> {
                    <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> it.title)
                }
            )
        }
    }
}</code></pre>

<p>As we can see, we haven’t been required to do too much customisation here, giving us a <code>BottomNavigation</code> implementation that should look a little something like so:</p>

<figure><img src="2-13.png"/></figure>

<hr />

<h2>Composing the Bottom Navigation Bar</h2>

<p>Now that we have this <code>BottomNavigationBar</code> composable, we’re going to want to compose it in our UI so that it can be used to navigate across the destinations of our app. However, our <code>BottomNavigationBar</code> composable requires a <code>Destination</code> to be passed to it, so that it knows the currently selected destination in the graph. At this point within our <code>Home</code> composable, we don’t have a reference to this. To be able to provide this to our bottom navigation, we’re going to need some way to observe the current destination of the graph as composable state - that will allow us to perform recompositions whenever the navigation graph is interacted with.</p>

<p>For this scenario, we can utilise the <code>currentBackStackEntryAsState</code> <code>NavController</code> extension function - this allows us to retrieve a <code>NavBackStackEntry</code> instance in the form of composable state, allowing us to trigger recompositions whenever this changes.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> navBackStackEntry <span class="syntax-all syntax-keyword">=</span> navController.currentBackStackEntryAsState()</code></pre>

<p>This <code>navBackStackEntry</code> is now a piece of state within our <code>Home</code> composable, meaning that we can recompose parts of our UI as required. This reference will reflect the current destination of our navigation graph, in the form of a <code>NavBackStackEntry</code>. The only thing is that our <code>BottomNavigationBar</code> requires the <code>Destination</code> type that we have defined in our project.</p>

<p>When it comes to a <code>NavBackStackEntry</code>, we have access to the <code>route</code> of the destination, this will match what we’ve defined in each of the supported <code>Destination</code> types. This means that we can use this string route to map to an instance of a <code>Destination</code>. Hopping back over to our <code>Destination</code> class we can add a new <code>fromString</code> function to its companion object, allowing us to take a provided route and return the corresponding <code>Destination</code> for it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Destination.kt
</span><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Destination</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">path</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">icon</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ImageVector?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">isRootDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
) {

    <span class="syntax-all syntax-keyword">companion</span> <span class="syntax-all syntax-keyword">object</span> {

        <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">fromString</span>(<span class="syntax-all syntax-parameter">route</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span> {
            <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-keyword">when</span> (route) {
                <span class="syntax-all syntax-entity">Feed</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Feed</span>
                <span class="syntax-all syntax-entity">Calendar</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Calendar</span>
                <span class="syntax-all syntax-entity">Contacts</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Contacts</span>
                <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Home</span>
            }
        }
    }
}</code></pre>

<p>With that in place, we can now take the current <code>NavBackStackEntry</code> and use it to build a <code>Destination</code>. The <code>route</code> within a <code>NavBackStackEntry</code> is nullable, so we’ll need to provide a default for this in these scenarios.</p>

<pre><code class="code-highlighted code-kt">navBackStackEntry.value?.destination?.route?.<span class="syntax-all syntax-constant">let</span> {
	<span class="syntax-all syntax-entity">Destination</span>.fromString(it)
} <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-constant">run</span> {
	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>
}</code></pre>

<p>The only thing here now is that we need this <code>Destination</code> calculation to adhere to two pieces of behaviour:</p>

<ul>
	<li>We need it to represent composable state, allowing us to recompose UI components whenever their value is changed</li>
	<li>We need it to be recalculated whenever the current <code>NavBackStackEntry</code> is changed</li>
</ul>

<p>To achieve this, we’re going to utilise the <code>derivedStateOf</code> function, this will allow us to create a state object based on the calculation of our <code>Destination</code>. The internals of <code>derivedStateOf</code> allows our result to be cached, meaning that the value will not be recalculated across compositions unless the value of the <code>navBackStackEntry</code> reference changes.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> currentDestination by derivedStateOf {
	navBackStackEntry.value?.destination?.route?.<span class="syntax-all syntax-constant">let</span> {
      	<span class="syntax-all syntax-entity">Destination</span>.fromString(it)
   	} <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-constant">run</span> {
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>
    }
}</code></pre>

<p>With this defined, we can now plug this new piece of state into our <code>Home</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Home</span>(<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>) {
	<span class="syntax-all syntax-keyword">val</span> navController <span class="syntax-all syntax-keyword">=</span> rememberNavController()
	<span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberScaffoldState()
	<span class="syntax-all syntax-keyword">val</span> navBackStackEntry <span class="syntax-all syntax-keyword">=</span> navController.currentBackStackEntryAsState()

	<span class="syntax-all syntax-keyword">val</span> currentDestination by remember(navBackStackEntry) {
		derivedStateOf {
			navBackStackEntry.value?.destination?.route?.<span class="syntax-all syntax-constant">let</span> {
        		<span class="syntax-all syntax-entity">Destination</span>.fromString(it)
    		} <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-constant">run</span> {
            	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>
        	}
    	}
	}

	<span class="syntax-all syntax-entity">Scaffold</span>(
  		...
	) {
		<span class="syntax-all syntax-entity">Navigation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            navController <span class="syntax-all syntax-keyword">=</span> navController
        )
	}
}</code></pre>

<p>With this in place, we now have what is required to compose our <code>BottomNavigationBar</code>, which we will provide for the composition of the <code>Scaffold</code> <code>bottomBar</code> argument - passing the <code>currentDestination</code> state that we defined above. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Home</span>(<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>) {
	<span class="syntax-all syntax-keyword">val</span> navController <span class="syntax-all syntax-keyword">=</span> rememberNavController()
	<span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberScaffoldState()
	<span class="syntax-all syntax-keyword">val</span> navBackStackEntry <span class="syntax-all syntax-keyword">=</span> navController.currentBackStackEntryAsState()

	<span class="syntax-all syntax-keyword">val</span> currentDestination by remember(navBackStackEntry) {
		derivedStateOf {
			navBackStackEntry.value?.destination?.route?.<span class="syntax-all syntax-constant">let</span> {
        		<span class="syntax-all syntax-entity">Destination</span>.fromString(it)
    		} <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-constant">run</span> {
            	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>
        	}
    	}
	}

	<span class="syntax-all syntax-entity">Scaffold</span>(
  		...
		bottomBar <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">BottomNavigationBar</span>(
				currentDestination <span class="syntax-all syntax-keyword">=</span> currentDestination,
				onNavigate <span class="syntax-all syntax-keyword">=</span> {
					
                }
            )
		}
	) {
		<span class="syntax-all syntax-entity">Navigation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            navController <span class="syntax-all syntax-keyword">=</span> navController
        )
	}
}</code></pre>

<p>With our <code>BottomNavigationBar</code>, we can see that above we have implemented the lambda function, but we’re not currently doing anything in this block. Here we’ll need to handle the navigation event, allowing this trigger to be communicated with our navigation graph. We can trigger this using the <code>navigate</code> function on our <code>navController</code> reference, providing the path of the<code>Destination</code> that we receive from the <code>onNavigate</code> lambda.</p>

<pre><code class="code-highlighted code-kt">navController.navigate(it.path)</code></pre>

<p>However, when navigating via bottom navigation, we can do a few further things to improve this. The <code>navigate</code> function also takes a <code>builder</code> argument that allows us to provide some configuration for the navigation that is taking place. We’ll start here by utilising <code>popUpTo</code>, which will pop the back stack up until a defined destination, which allows us to avoid building up a large collection of entries within our back stack. When it comes to this, we can access the start destination from our graph via the use of the <code>findStartDestination()</code> function, passing its <code>id</code> to the <code>popUpTo</code> function. This means that when navigation is performed, all back stack entries will be cleared.</p>

<pre><code class="code-highlighted code-kt">navController.navigate(it.path) {
	popUpTo(navController.graph.findStartDestination().id) {
		saveState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	}
}</code></pre>

<p>Next we will set the <code>launchSingleTop</code> flag to <strong>true</strong>. This means that each destination can only have one back stack entry, this avoids duplicate copies existing in our back stack should a destination be reselected.</p>

<pre><code class="code-highlighted code-kt">navController.navigate(it.path) {
	popUpTo(navController.graph.findStartDestination().id) {
		saveState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	}
	launchSingleTop <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
}</code></pre>

<p>Finally, we’ll set the <code>restoreState</code> flag to <strong>true</strong> - this means that if a previously selected item is reselected, its state will be restored.</p>

<pre><code class="code-highlighted code-kt">navController.navigate(it.path) {
	popUpTo(navController.graph.findStartDestination().id) {
		saveState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	}
	launchSingleTop <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	restoreState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
}</code></pre>

<p>With this all defined, we can now plug this navigation logic into the <code>onNavigate</code> lambda of our <code>BottomNavigationBar</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Home</span>(<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>) {
	<span class="syntax-all syntax-keyword">val</span> navController <span class="syntax-all syntax-keyword">=</span> rememberNavController()
	<span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberScaffoldState()
	<span class="syntax-all syntax-keyword">val</span> navBackStackEntry <span class="syntax-all syntax-keyword">=</span> navController.currentBackStackEntryAsState()

	<span class="syntax-all syntax-keyword">val</span> currentDestination by remember(navBackStackEntry) {
		derivedStateOf {
			navBackStackEntry.value?.destination?.route?.<span class="syntax-all syntax-constant">let</span> {
        		<span class="syntax-all syntax-entity">Destination</span>.fromString(it)
    		} <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-constant">run</span> {
            	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>
        	}
    	}
	}

	<span class="syntax-all syntax-entity">Scaffold</span>(
  		...
		bottomBar <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">BottomNavigationBar</span>(
				currentDestination <span class="syntax-all syntax-keyword">=</span> currentDestination,
				onNavigate <span class="syntax-all syntax-keyword">=</span> {
					navController.navigate(it.path) {
						popUpTo(
							navController.graph
								.findStartDestination().id
						) {
							saveState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
						}
                        launchSingleTop <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                        restoreState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                    }
                }
            )
		}
	) {
		<span class="syntax-all syntax-entity">Navigation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            navController <span class="syntax-all syntax-keyword">=</span> navController
        )
	}
}</code></pre>

<p>With this composition in place, at this point, we will be able to use the bottom navigation bar to navigate between the three destinations that are defined in our navigation graph.</p>

<figure><img src="4-8.png"/></figure>

<h1>Displaying Snackbars</h1>

<p>Now that our <code>Scaffold</code> is in place and functional, let’s take a look at what else can be done with the <code>Scaffold</code>. We’ll start here by exploring the use of Snackbars - these are floating bars that can be used to display short messages within our UI. These can be pretty handy to implement in applications, so let’s take a look at how we can compose these within our UI.</p>

<p>Hopping back over to our <code>Home</code> composable, we’re going to configure our <code>Scaffold</code> so that we can show a Snackbar from within one of our navigation destinations. We’ll add an action to our <code>TopAppBar</code> that when clicked displays a Snackbar within the <code>Scaffold</code>. We’ll start here by adding a composable block for the <code>actions</code> argument of the <code>TopAppBar</code> composable. As an example of how we can also configure this to only show for certain destinations, we’ll also configure this so that we only show this menu item when the current destination is not <code>Feed</code>. This means that we can continually compose the <code>actions</code> based on the <code>currentDestination</code> state that we previously defined.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Home.kt
</span>topBar <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">TopAppBar</span>(
		title <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title)
		},
		actions <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
				
            }
        }
	)
}</code></pre>

<p>The <code>actions</code> argument takes a composable conformed to the <code>RowScope</code> - this means that the composables you provide will be presented in a horizontal stack. We’re only going to provide a single action here, which we’ll do so in the form of an <code>IconButton</code>.</p>

<pre><code class="code-highlighted code-kt">topBar <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">TopAppBar</span>(
		title <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title)
		},
		 actions <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
				<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {

                }) {
                    
                }
            }
        }
	)
}</code></pre>

<p>💡 The Icon button has the expected touch targets already applied to it, making it a more accessible component over an Icon that has an assigned clickable modifier.</p>

<p>Inside of this <code>IconButton</code> we’re going to display an <code>Icon</code> for a visual representation of our action. We’ll first define a content description for this within our <code>strings.xml</code> file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_more_information&quot;</span>&gt;
	More information
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Followed by composing an <code>Icon</code> using the <code>Icons.Default.Info</code> icon from the material icons package, passing the string representation for the resource that we just defined.</p>

<pre><code class="code-highlighted code-kt">topBar <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">TopAppBar</span>(
		title <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title)
		},
		 actions <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
				<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {

                }) {
                    <span class="syntax-all syntax-entity">Icon</span>(
                        imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Info</span>,
                        contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
							id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
                    )
                }
            }
        }
	)
}</code></pre>

<p>With this in place, we now have a menu item that is displayed when either the <code>Calendar</code> or <code>Contacts</code> destinations are displayed. With this in place, we can now use this to trigger the display of a snackbar.</p>

<p>When it comes to showing Snackbars, we can display these through the <code>ScaffoldState</code> that we are providing to our <code>Scaffold</code> composable. The <code>ScaffoldState </code> contains a <code>SnackbarHostState</code> reference, whose <code>showSnackbar</code> function we can use to display Snackbars within our <code>Scaffold</code>. The only thing is that this is a <code>suspending</code> function, meaning that it needs to be launched within a coroutine. When it comes to launching coroutines within composables, we’re going to need somewhere to launch those coroutines - this will take the form of a <code>CoroutineScope</code>, which we can achieve via the <code>rememberCoroutineScope</code> function. As per the documentation, this function will:</p>

<blockquote>
<p>Return a CoroutineScope bound to this point in the composition using the optional CoroutineContext provided by getContext.</p>
</blockquote>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> coroutineScope <span class="syntax-all syntax-keyword">=</span> rememberCoroutineScope()</code></pre>

<p>We can then utilise this scope to launch our suspending function.</p>

<pre><code class="code-highlighted code-kt">coroutineScope.launch {
	scaffoldState.snackbarHostState.showSnackbar(...)
}</code></pre>

<p>The above code isn’t going to quite work yet, as we need to provide a string to be displayed inside of our Snackbar. For this we’ll add a new string resource to our <code>strings.xml</code> file that simply indicates that the requested feature is not available yet.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;not_available_yet&quot;</span>&gt;Not available yet&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’ll then retrieve this resource using the <code>stringResource</code> composable, followed by passing the retrieved string to our <code>showSnackbar</code> function call.</p>

<pre><code class="code-highlighted code-kt">topBar <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-keyword">val</span> snackbarMessage <span class="syntax-all syntax-keyword">=</span> stringResource(
		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.not_available_yet)
	<span class="syntax-all syntax-entity">TopAppBar</span>(
		title <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title)
		},
		 actions <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
				<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                    coroutineScope.launch {
                    	scaffoldState.snackbarHostState
							.showSnackbar(snackbarMessage)
                    }
                }) {
                    <span class="syntax-all syntax-entity">Icon</span>(
                        imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Info</span>,
                        contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
							id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
                    )
                }
            }
        }
	)
}</code></pre>

<p>At this point, we’ll now be able to see an action within our <code>TopAppBar</code>, which when clicked will display a Snackbar within our <code>Scaffold</code>.</p>

<h1>Creating the Drawer Navigation Graph</h1>

<figure><img src="navv.png"/></figure>

<p>For the next UI addition, we’re going to add a navigation drawer to our UI. This will allow users to pull out a navigation drawer from the side of a scaffold, followed by performing navigation to a destination within our graph. The only thing at this point is that we only have 3 destinations in our graph, and those are currently being navigated to via the bottom navigation. In this chapter, we’re going to add some more destinations to our graph so that we can support navigation from our drawer. </p>

<p>When it comes to navigation, we previously defined all of our composable destinations in a single navigation graph.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Navigation.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>
) {
    <span class="syntax-all syntax-entity">NavHost</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        navController <span class="syntax-all syntax-keyword">=</span> navController,
		startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path
    ) {
    	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) {
			<span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>)
        }
        composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>.path) {
            <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>)
        }
        composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.path) {
            <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>)
        }
    }
}</code></pre>

<p>The <code>NavHost</code> also supports nested navigation graphs, which allows us to group sets of related destinations together. This not only means we can perform navigation to a feature as a whole, but it also breaks our navigation graph up into a more understandable structure. To see this in action, let’s take our previously defined navigation graph and place it inside of a nested graph.</p>

<p>For this, we need to use the <code>NavGraphBuilder</code> extension function, <code>navigation</code>. This function takes 3 arguments:</p>

<ul>
	<li><strong>startDestination</strong>: the starting destination for the nested graph. This needs to be one of the destinations contained within the nested graph.</li>
	<li><strong>route</strong>: the route used to navigate to the nested graph.</li>
	<li><strong>builder</strong>: the <code>NavGraphBuilder</code> that represents the destinations of the nested graph.</li>
</ul>

<p>We’ll start by wrapping our existing destinations using this <code>navigation</code> function.</p>

<pre><code class="code-highlighted code-kt">navigation(
	startDestination <span class="syntax-all syntax-keyword">=</span> ...,
	route <span class="syntax-all syntax-keyword">=</span> ...
) {
	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) {
    	<span class="syntax-all syntax-entity">ContentArea</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>
        )
    }
	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>.path) {
		<span class="syntax-all syntax-entity">ContentArea</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
		)
	}
	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.path) {
		<span class="syntax-all syntax-entity">ContentArea</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
		)
    }
}</code></pre>

<p>Even though we’ve provided the destinations here for the <code>builder</code> argument of the function, you’ll notice here that we need to provide values for the <code>startDestination</code> and <code>route</code> arguments. When we previously defined the graph for our <code>NavHost</code>, we set the <code>Destination.Feed</code> as the starting destination for our graph. We’re going to do the same here and set this as the starting destination for our nested graph. </p>

<p>We’ll also need to provide a <code>route</code> for our nested graph, this is so that our nested graph can be navigated to. We’re going to need to add a new <code>Destination</code> type to our destination class, which we’ll call <code>Home</code>. This will be used for the root level destinations within our scaffold - the feed, calendar and contacts.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Home <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(&quot;home&quot;)</code></pre>

<p>With this in place, we can now provide the <code>path</code> of this as the <code>route</code> of our nested graph.</p>

<pre><code class="code-highlighted code-kt">navigation(
	startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path,
	route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.path
) {
	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) {
    	<span class="syntax-all syntax-entity">ContentArea</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>
        )
    }
	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>.path) {
		<span class="syntax-all syntax-entity">ContentArea</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
		)
	}
	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.path) {
		<span class="syntax-all syntax-entity">ContentArea</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
		)
    }
}</code></pre>

<p>Now that the <code>Feed</code> destination is within a nested graph, we need to update the <code>startDestination</code> of our <code>NavHost</code> to reflect a top-level destination route. For this, we’ll use the <code>Home</code> destination that we set as the route of our nested navigation graph. We were previously using the <code>Feed</code> as the <code>startDestination</code> of our <code>NavHost</code>, using this <code>Home</code> destination will have the same effect as we are now referencing the nested navigation graph which in turn has the <code>Feed</code> as its starting destination.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>
) {
    <span class="syntax-all syntax-entity">NavHost</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        navController <span class="syntax-all syntax-keyword">=</span> navController,
        startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.path
    ) {
        navigation(
            startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path,
            route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.path
        ) {
            composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) {
                <span class="syntax-all syntax-entity">ContentArea</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                    destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>
                )
            }
            composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>.path) {
                <span class="syntax-all syntax-entity">ContentArea</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                    destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
                )
            }
            composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.path) {
                <span class="syntax-all syntax-entity">ContentArea</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                    destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
                )
            }
        }
    }
}</code></pre>

<p>With the above in place, we can now add two new destinations that will be navigated to from our navigation drawer - <strong>Settings</strong> and <strong>Upgrade</strong>. We’ll add new declarations for these inside of our <code>Destination</code> class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Settings <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(&quot;settings&quot;, <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Settings</span>)
<span class="syntax-all syntax-keyword">object</span> Upgrade <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(&quot;upgrade&quot;, <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Star</span>)</code></pre>

<p>We’ll also need to add support for these within our <code>fromString</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">companion</span> <span class="syntax-all syntax-keyword">object</span> {

	<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">fromString</span>(<span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span> {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-keyword">when</span> (label) {
            <span class="syntax-all syntax-entity">Feed</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Feed</span>
            <span class="syntax-all syntax-entity">Calendar</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Calendar</span>
            <span class="syntax-all syntax-entity">Contacts</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Contacts</span>
            <span class="syntax-all syntax-entity">Upgrade</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Upgrade</span>
            <span class="syntax-all syntax-entity">Settings</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Settings</span>
            <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Home</span>
        }
    }
}</code></pre>

<p>Now that we have these destinations available, we can add these as composable routes to our navigation graph. Even though we converted the initial destinations to be within a nested graph, these two new destinations are not going to be part of a nested graph - they’re just going to sit at the top level. Either way of approaching this here would be an acceptable approach - however, not only does leaving these at the top-level allow us to demonstrate how to use top-level and nested destinations together, these destinations are not related in any way so it feels appropriate to keep them individual for now.</p>

<p>We’ll add these to the graph in the same way that we’ve added the other <code>composable</code> destinations with their corresponding <code>ContentArea</code> composables, using the corresponding <code>Destination</code> classes to compose the UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>
) {
    <span class="syntax-all syntax-entity">NavHost</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        navController <span class="syntax-all syntax-keyword">=</span> navController,
        startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.path
    ) {
        navigation(
            startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path,
            route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.path
        ) {
            composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path) {
                <span class="syntax-all syntax-entity">ContentArea</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                    destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>
                )
            }
            composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>.path) {
                <span class="syntax-all syntax-entity">ContentArea</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                    destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
                )
            }
            composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.path) {
                <span class="syntax-all syntax-entity">ContentArea</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                    destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
                )
            }
        }

        composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>.path) {
            <span class="syntax-all syntax-entity">ContentArea</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>
            )
        }

        composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>.path) {
            <span class="syntax-all syntax-entity">ContentArea</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>
            )
        }
    }
}</code></pre>

<p>With this in place, we now have support for additional destinations within our navigation graph. In the next chapter, we’ll look at implementing the navigation drawer, allowing us to trigger navigation to these destinations.</p>

<h1>Adding a Navigation Drawer</h1>

<figure><img src="draw.png"/></figure>

<p>Now that we have the additions in place for our navigation graph, we can go ahead and implement the navigation drawer that will be used to trigger the navigation events to these new destinations. For this, we’re going to create a composable function that can be used as the content for the <code>drawerContent</code> argument of the <code>Scaffold</code> composable.</p>

<pre><code class="code-highlighted code-kt">drawerContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-keyword">@Composable</span> (<span class="syntax-all syntax-entity">ColumnScope</span>.() <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>)? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span></code></pre>

<p>We can notice one key thing here for the <code>drawerContent</code> argument, the declaration of the <code>ColumnScope</code> - this means that the composable content that we provide will adhere to this scope, which is because the drawer represents a vertically stacked space. With that in mind, we’ll go ahead and create a new ColumnScope composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>()</code></pre>

<p>💡 Scopes are a great way of enforcing composition behaviour to your composable functions.</p>

<p>The content of this composable is going to be quite simple, as per the design. We’re going to start by creating a heading section that displays an account name and email - which we’ll need to add some new string resources for.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_name&quot;</span>&gt;Compose Academy&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_email&quot;</span>&gt;contact@compose.academy&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can now configure a couple of <code>Text</code> composables using these new string resources.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>() {
    <span class="syntax-all syntax-entity">Text</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_name),
        fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">20</span>.sp
    )
    <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))
    <span class="syntax-all syntax-entity">Text</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_email),
        fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.sp
    )
}</code></pre>

<p>We’ll also add the use of the <code>Divider</code> composable so that we can create some visible separation between the header of our navigation drawer, and the items that will follow it. We’ll use the <code>fillMaxWidth</code> modifier to ensure the divider fills the width of the drawer, along with the <code>padding</code> modifier to create some spacing between the edges of the drawer and the divider, as well as some visual space between any composables above and below it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>() {
	<span class="syntax-all syntax-entity">Text</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_name),
        fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">20</span>.sp
    )
    <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))
    <span class="syntax-all syntax-entity">Text</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_email),
        fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.sp
    )

    <span class="syntax-all syntax-entity">Divider</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            .fillMaxWidth()
            .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, vertical <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp)
    )
}</code></pre>

<figure><img src="1-14.png"/></figure>

<p>Next, we’re going to add some items which will be used to trigger events from our navigation drawer. Here we’re going to have three items:</p>

<ul>
	<li><strong>Settings</strong>: this will be used to navigate to the settings composable.</li>
	<li><strong>Upgrade</strong>: this will be used to navigate to the upgrade composable.</li>
	<li><strong>Logout</strong>: this will be used to logout from the application. We won’t be implementing any logout logic, this will be purely for example purposes.</li>
</ul>

<p>All of these three items in the drawer are going to be represented in the same way, so let’s create a new composable function inside of our <code>Drawer.kt</code> file, <code>DrawerItem</code>. Each drawer item is going to have some same properties that are used in its representation:</p>

<ul>
	<li><strong>modifier</strong>: used to control the visual constraints of the composable</li>
	<li><strong>label</strong>: used to display a textual label</li>
	<li><strong>onClicked</strong>: used to receive click events from the composable</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DrawerItem</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onClick</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Within this composable, we’re going to define a single <code>Text</code> composable. We’ll use the <code>label</code> to set the <code>text</code> of our composable function, replacing the first character of this label with the uppercase equivalent in the process.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DrawerItem</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onClick</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Text</span>(
        text <span class="syntax-all syntax-keyword">=</span> label.replaceFirstChar {
            it.titlecase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
        }
    )
}</code></pre>

<p>We’ll also need to set some modifiers for the composable. We’ll start by adding the <code>clickable</code> modifier so that we can trigger the <code>onClick</code> lambda that is being provided to our <code>DrawerItem</code> composable. This allows us to pass click events up to any parent composable. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DrawerItem</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onClick</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Text</span>(
        text <span class="syntax-all syntax-keyword">=</span> label.replaceFirstChar {
            it.titlecase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
        },
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .clickable {
                onClick()
            }
    )
}</code></pre>

<p>Currently, though, the touch target for our composable isn’t very accessible. The composable content is also pressed closely against the edge of the content area.</p>

<figure><img src="2-14.png"/></figure>

<p>To improve this we’ll also apply the <code>padding</code> modifier. This will not only increase the touch target of our composable but also give it sufficient spacing from the edge of its bounds.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DrawerItem</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">onClick</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Text</span>(
        text <span class="syntax-all syntax-keyword">=</span> label.replaceFirstChar {
            it.titlecase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
        },
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .clickable {
                onClick()
            }
			.padding(<span class="syntax-all syntax-constant">16</span>.dp)
    )
}</code></pre>

<figure><img src="3-13.png"/></figure>

<p>With this <code>DrawerItem</code> composable in place, we can now compose it inside of our <code>DrawerContent</code> composable. For this first instance, we’re going to create a drawer item for the <code>Upgrade</code> destination. This means that we’ll pass the <code>Upgrade</code> path for the <code>label</code> argument of the <code>DrawerItem</code>. We’ll also use the <code>fillMaxWidth</code> to enforce our composable to fill the maximum available width from the drawer.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    ...
    <span class="syntax-all syntax-entity">DrawerItem</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>.path
    ) {

    }
}</code></pre>

<p>You’ll notice here that we haven’t yet implemented any logic inside of the <code>onClick</code> lambda. Here we’ll want to pass the event up to the parent composable so that the selected <code>Destination</code> can be navigated to. For this we’ll need to add a new argument to our composable function, this will be in the form of a lambda function that has a <code>Destination</code> as a parameter.</p>

<pre><code class="code-highlighted code-kt">onNavigationSelected<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span></code></pre>

<p>With this we can then trigger this lambda within the <code>onClick</code> implementation, using the <code>Upgrade</code> destination as the destination type.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onNavigationSelected</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    ...
    <span class="syntax-all syntax-entity">DrawerItem</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>.path
    ) {
        onNavigationSelected(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>)
    }
}</code></pre>

<p>Now that we’ve implemented this <code>DrawerItem</code> composable for the <code>Upgrade</code> destination, we can do the same for the <code>Settings</code> destination. After composing a <code>Spacer</code> to create some visual space, we’ll go ahead and compose another <code>DrawerItem</code> for the <code>Settings</code> destination.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onNavigationSelected</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    ...
    <span class="syntax-all syntax-entity">DrawerItem</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>.path
    ) {
        onNavigationSelected(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>)
    }
	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))
    <span class="syntax-all syntax-entity">DrawerItem</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>.path
    ) {
        onNavigationSelected(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>)
    }
}</code></pre>

<p>Alongside the navigation to these two destinations, we’re also going to add support for logging out of the application from our navigation drawer. We’ll also need another callback for this, so we’ll add a <code>onLogout</code> lambda as an argument for our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onNavigationSelected</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onLogout</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We’ll also need to add another string to our <code>strings.xml</code> resource file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;log_out&quot;</span>&gt;Log Out&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With that in place we can now compose another <code>DrawerItem</code> - passing the string that was just defined for the <code>label</code> argument, along with triggering our <code>onLogout()</code> lambda from within the <code>onClick</code> callback.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onNavigationSelected</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onLogout</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    ...
    <span class="syntax-all syntax-entity">DrawerItem</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>.path
    ) {
        onNavigationSelected(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>)
    }
	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))
    <span class="syntax-all syntax-entity">DrawerItem</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>.path
    ) {
        onNavigationSelected(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>)
    }
    <span class="syntax-all syntax-entity">DrawerItem</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.log_out)
    ) {
        onLogout()
    }
}</code></pre>

<p>Currently, with this logout item, it looks a little odd how this is positioned in our navigation drawer.</p>

<figure><img src="4-9.png"/></figure>

<p>Instead, we can push this item to the bottom of our drawer to ensure that it is separated from the rest of our navigation items. We’ll start by composing a <code>Spacer</code> above our logout item, applying a weight of <code>1</code> via the <code>weight</code> modifier - this will force the <code>Spacer</code> to use all of the remaining vertical space, pushing the logout item to the bottom of the drawer. We’ll also add a <code>Spacer</code> beneath the logout item, just to create some visual space at the bottom of the drawer.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> ColumnScope.<span class="syntax-all syntax-entity">DrawerContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onNavigationSelected</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onLogout</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    ...
    <span class="syntax-all syntax-entity">DrawerItem</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>.path
    ) {
        onNavigationSelected(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>)
    }
	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))
    <span class="syntax-all syntax-entity">DrawerItem</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>.path
    ) {
        onNavigationSelected(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>)
    }
	<span class="syntax-all syntax-entity">Spacer</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            .weight(<span class="syntax-all syntax-constant">1f</span>)
    )
    <span class="syntax-all syntax-entity">DrawerItem</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        label <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.log_out)
    ) {
        onLogout()
    }
    <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))

}</code></pre>

<p>With this in place, we now have the content for our navigation drawer implemented:</p>

<figure><img src="5-7.png"/></figure>

<hr />

<h2>Add the navigation drawer to our scaffold</h2>

<p>Before we go ahead and compose the navigation drawer content, we need to enable drawer functionality within our scaffold. For this, we’ll hop back over to our <code>Home</code> composable to make a few modifications. To configure and control the navigation drawer within our <code>Scaffold</code>, we’re going to need to obtain an instance to a <code>DrawerState</code> - we’ll want to have the ability to open and close the drawer on request, which is what we’ll use this class for. From the compose material package, we can utilise the <code>rememberDrawerState</code> function to obtain a reference to this class that will be persisted across recompositions. When using this function we can also provide a default state to be used for the drawer, which we’ll do so in the form of <code>DrawerValue.Closed</code> - meaning that the drawer of our scaffold will be closed by default.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> drawerState <span class="syntax-all syntax-keyword">=</span> rememberDrawerState(<span class="syntax-all syntax-entity">DrawerValue</span>.<span class="syntax-all syntax-entity">Closed</span>)</code></pre>

<p>With this in place within our <code>Home</code> composable, we’ll then need to provide this reference when using <code>rememberScaffoldState</code> to obtain a reference to a <code>ScaffoldState</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberScaffoldState(drawerState)</code></pre>

<p>At this point, our <code>Scaffold</code> is configured to contain a navigation drawer, but we don’t have any way of displaying it. For this we’re going to add a drawer icon to our top app bar, using this to trigger an open even on our <code>DrawerState</code>.</p>

<p>Within our <code>TopAppBar</code> we’ll use the <code>navigationIcon</code> argument to provide an Icon that can be used to trigger this <code>open</code> event. Here we’ll provide an <code>IconButton</code> composable that will be used to trigger the suspending <code>open</code> function from our <code>DrawerState</code> reference.</p>

<pre><code class="code-highlighted code-kt">topBar <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-keyword">val</span> snackbarMessage <span class="syntax-all syntax-keyword">=</span> stringResource(
		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.not_available_yet)
	<span class="syntax-all syntax-entity">TopAppBar</span>(
		title <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title)
		},
		navigationIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                coroutineScope.launch {
                	drawerState.<span class="syntax-all syntax-keyword">open</span>()
                }
            }) {
                
            }
        },
		actions <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
				<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                    coroutineScope.launch {
                    	scaffoldState.snackbarHostState
							.showSnackbar(snackbarMessage)
                    }
                }) {
                    <span class="syntax-all syntax-entity">Icon</span>(
                        imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Info</span>,
                        contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
							id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
                    )
                }
            }
        }
	)
}</code></pre>

<p>We’ll also need to add an <code>Icon</code> for the content of our <code>IconButton</code>, so we’ll first add a content description string to our resources.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_open_menu&quot;</span>&gt;Open Menu&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>And then compose an <code>Icon</code> for the content of our <code>IconButton</code>, using the <code>Icons.Default.Menu</code> for the icon of our composable.</p>

<pre><code class="code-highlighted code-kt">topBar <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-keyword">val</span> snackbarMessage <span class="syntax-all syntax-keyword">=</span> stringResource(
		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.not_available_yet)
	<span class="syntax-all syntax-entity">TopAppBar</span>(
		title <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title)
		},
		navigationIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                coroutineScope.launch {
                	drawerState.<span class="syntax-all syntax-keyword">open</span>()
                }
            }) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Menu</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_open_menu)
                )
            }
        },
		actions <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
				<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                    coroutineScope.launch {
                    	scaffoldState.snackbarHostState
							.showSnackbar(snackbarMessage)
                    }
                }) {
                    <span class="syntax-all syntax-entity">Icon</span>(
                        imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Info</span>,
                        contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
							id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
                    )
                }
            }
        }
	)
}</code></pre>

<p>With this in place, we now have a navigation icon within our <code>TopAppBar</code> that when clicked will open the navigation drawer.</p>

<figure><img src="6-5.png"/></figure>

<hr />

<h2>Adding the drawer content to the scaffold</h2>

<p>What’s left for us to do now is to slot this into our <code>Scaffold</code> so that we can view our drawer content, this will be done using the <code>Scaffold</code> <code>drawerContent</code> argument. When composing this, we’ll use the <code>fillMaxWidth</code> modifier to ensure that our drawer uses the available width, along with adding some empty blocks for the <code>onNavigationSelected</code> and <code>onLogout</code> arguments. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
	...,
 	drawerContent <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-entity">DrawerContent</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			onNavigationSelected <span class="syntax-all syntax-keyword">=</span> {
				
			},
			onLogout <span class="syntax-all syntax-keyword">=</span> {
				<span class="syntax-all syntax-comment">// handle logout
</span>			}
		)
  	}
) {
  ...
}</code></pre>

<p>As previously mentioned, we’re not going to be handling the logout functionality, so we’ll leave this comment in place. However, we do need to support navigation - within the <code>onNavigationSelected</code> implementation we’ll need to use our <code>navController</code> reference to trigger its <code>navigate</code> function. Here we’ll pass the path of the <code>Destination</code> that the lambda provides us with, which will trigger navigation to the corresponding composable in our navigation graph.</p>

<pre><code class="code-highlighted code-kt">onNavigationSelected <span class="syntax-all syntax-keyword">=</span> { destination <span class="syntax-all syntax-keyword">-&gt;</span>
	navController.navigate(destination.path)
}</code></pre>

<p>At this point we’ll also want to close the navigation drawer, this is because the user has navigated to a new destination - so it doesn’t make sense to keep this in view. The <code>DrawerState</code> that we previously created a reference to contains a <code>close</code> function that we can trigger here, but this will need to be done within a <code>CoroutineScope</code> because <code>close</code> is a suspending function. Here we’ll use our previously defined <code>coroutineScope</code> to launch our <code>close</code> operation.</p>

<pre><code class="code-highlighted code-kt">onNavigationSelected <span class="syntax-all syntax-keyword">=</span> {
	navController.navigate(it.path)
	coroutineScope.launch {
		drawerState.close()
	}
}</code></pre>

<p>With this in place, we now have a navigation drawer that can be opened from the navigation icon in the top app bar, using it to navigate to different destinations in our app.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
	...,
 	drawerContent <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-entity">DrawerContent</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			onNavigationSelected <span class="syntax-all syntax-keyword">=</span> {
				navController.navigate(it.path)
				coroutineScope.launch {
					drawerState.close()
				}
			},
			onLogout <span class="syntax-all syntax-keyword">=</span> {
				<span class="syntax-all syntax-comment">// handle logout
</span>			}
		)
  	}
) {
  ...
}</code></pre>

<figure><img src="6-6.png"/></figure>

<h1>Supporting multiple navigation bar types</h1>

<figure><img src="bar-1.png"/></figure>

<p>Now that we’ve added the ability to navigate to destinations from the navigation drawer, we might notice some unexpected visuals in our <code>TopAppBar</code>. In the last section, we added the drawer icon to the <code>TopAppBar</code> - this allows the user to open the navigation drawer to select a navigation item from. However, this should only be visible from the root destinations, when the bottom navigation bar is displayed. As soon as a user navigates to a higher level destination (such as the settings or upgrade composables), we’ll not want this drawer icon to be composed. To be able to compose based on these properties, we’ll need to know what is a root destination and what isn’t. To be aware of this we can modify our <code>Destination</code> class to include a boolean flag, <code>isRootDestination</code>. We can then provide a value here for each <code>Destination</code> and avoid having to check for specific <code>Destination</code> types within our code.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Destination</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">path</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">icon</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ImageVector?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">isRootDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
)</code></pre>

<p>We’ll then need to update the different types of <code>Destination</code> that we have. We’ve set the default value to <strong>true</strong>, so we’ll need to specify here what <code>Destination</code> types are <strong>not</strong> root destinations.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Home <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(path <span class="syntax-all syntax-keyword">=</span> &quot;home&quot;)

<span class="syntax-all syntax-keyword">object</span> Feed <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	path <span class="syntax-all syntax-keyword">=</span> &quot;feed&quot;, 	
	icon <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-constant">List</span>
)

<span class="syntax-all syntax-keyword">object</span> Contacts <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	path <span class="syntax-all syntax-keyword">=</span> &quot;contacts&quot;, 
	icon <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Person</span>
)

<span class="syntax-all syntax-keyword">object</span> Calendar <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	path <span class="syntax-all syntax-keyword">=</span> &quot;gallery&quot;,
	icon <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">DateRange</span>
)

<span class="syntax-all syntax-keyword">object</span> Settings <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	path <span class="syntax-all syntax-keyword">=</span> &quot;settings&quot;, 
	icon <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Settings</span>, 
	isRootDestination <span class="syntax-all syntax-keyword">=</span> false
)

<span class="syntax-all syntax-keyword">object</span> Upgrade <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	path <span class="syntax-all syntax-keyword">=</span> &quot;upgrade&quot;, 
	icon <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Star</span>, 
	isRootDestination <span class="syntax-all syntax-keyword">=</span> false
)</code></pre>

<p>With this in place, we’ve now marked all destinations that are not the Feed, Calendar or Contacts as <strong>not</strong> being root destinations. We can use this <code>isRootDestination</code> flag within our code to determine whether the <code>Destination</code> is currently at the root or not.</p>

<hr />

<h2>Creating a level-specific app bar</h2>

<p>Now that we have this <code>isRootDestination</code> flag available, we can use this to compose a <code>TopAppBar</code> that is specific to the <code>Destination</code> level. While we could have a single <code>TopAppBar</code>, these are going to be quite different - so it will be cleaner and easier to understand if we have separate composables for these. First, we’ll focus on the <code>TopAppBar</code> for the root destination of the project. For this, we’re essentially going to be taking the <code>TopAppBar</code> that we had previously created and placing it inside of its own composable function. </p>

<pre><code class="code-highlighted code-kt">topBar <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-keyword">val</span> snackbarMessage <span class="syntax-all syntax-keyword">=</span> stringResource(
		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.not_available_yet)
	<span class="syntax-all syntax-entity">TopAppBar</span>(
		title <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title)
		},
		navigationIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                coroutineScope.launch {
                	drawerState.<span class="syntax-all syntax-keyword">open</span>()
                }
            }) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Menu</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_open_menu)
                )
            }
        },
		actions <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
				<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                    coroutineScope.launch {
                    	scaffoldState.snackbarHostState
							.showSnackbar(snackbarMessage)
                    }
                }) {
                    <span class="syntax-all syntax-entity">Icon</span>(
                        imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Info</span>,
                        contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
							id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
                    )
                }
            }
        }
	)
}</code></pre>

<p>The only thing that will be different here is that we won’t have access to everything that we have in the <code>Home</code> composable, so we’re going to need to pass in some things via the function arguments. These arguments will need to be:</p>

<ul>
	<li><strong>modifier</strong>: similar to previous composables we’ve created, we want to allow the parent composable to provide modifiers to the composable to enforce certain constraints.</li>
	<li><strong> currentDestination</strong>: the current destination is used to filter out specific things from being composed, so we’ll need access to this within our composable.</li>
	<li><strong>openDrawer</strong>: within the <code>navigationIcon</code> composable argument we trigger the opening of the navigation drawer. To avoid passing in the coroutine scope and the drawer state, we’ll pass this event up so that the parent composable can handle it.</li>
	<li><strong>showSnackbar</strong>: within the <code>actions</code> composable argument we trigger the display of a snacker. To avoid having to pass in the coroutine scope and the scaffold state, we’ll pass this event up so that the parent composable can handle it.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// RootDestinationTopBar.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">openDrawer</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">showSnackbar</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We can then plug our existing <code>TopAppBar</code> composable into this composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">openDrawer</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">showSnackbar</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TopAppBar</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        title <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title)
        },
        navigationIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                openDrawer()
            }) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Menu</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_open_menu)
                )
            }
        },
        actions <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
                <span class="syntax-all syntax-keyword">val</span> snackbarMessage <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.not_available_yet)
                <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                    showSnackbar(snackbarMessage)
                }) {
                    <span class="syntax-all syntax-entity">Icon</span>(
                        imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Info</span>,
                        contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
							id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
                    )
                }
            }
        }
    )
}</code></pre>

<p>Here we now use the <code>openDrawer</code> lambda inside of the <code>navigationIcon</code> composable - this is instead of directly using the coroutine scope and drawer state. This lambda function is used to pass the event up to the parent composable. We also now use the <code>showSnackbar</code> lambda function within the <code>actions</code> composable - again, avoiding us passing in various state references to our composable function. Aside from these, our composable is the same as we had it previously - it’s just now defined in its own composable function.</p>

<figure><img src="8-2.png"/></figure>

<hr />

<h2>Creating the higher level Top App Bar</h2>

<p>Now that we have a <code>TopAppBar</code> defined for use in our root destinations, we now need to think about the app bar that is going to be used for destinations that are <strong>not</strong> root destinations. For this we’ll create a new composable, <code>ChildDestinationTopBar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ChildDestinationTopBar.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)</code></pre>

<p>Here we provide a modifier argument for our composable function along with its default value, as well as a title in the form of a string - this will be used to show the name of the destination that has been navigated to. Using these we can now compose a <code>TopAppBar</code>, along with a <code>Text</code> composable to be used for the <code>title</code> of the bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
) {
    <span class="syntax-all syntax-entity">TopAppBar</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        title <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
        }
    )
}</code></pre>

<p>Because we’re in a higher level destination than that of a root, we’re going to want to provide a way for users to navigate ‘up’ to the previous destination (which will be the root of our app). In the same way, as we handle other events in our child composables, we’re going to pass this event up to the parent. So we’ll need to start by adding a new argument to our composable function in the form of a lambda.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onNavigateUp</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)</code></pre>

<p>With this in place, we can now compose an <code>IconButton</code> within the <code>navigationIcon</code> block of our <code>TopAppBar</code>. This <code>IconButton</code> will be used to trigger our <code>onUpClicked</code> lambda, along with composing an <code>Icon</code> within its content area using the <code>Icons.Default.ArrowBack</code> icon.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onNavigateUp</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
) {
    <span class="syntax-all syntax-entity">TopAppBar</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        title <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
        },
        navigationIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                onNavigateUp()
            }) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> ...
                )
            }
        }
    )
}</code></pre>

<p>To finalise our <code>Icon</code> we’ll need to add a content description, starting with adding a new string to our <code>strings.xml</code> resources.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_navigate_up&quot;</span>&gt;Go back Home&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Followed by using the <code>stringResource</code> function to assign this to the <code>contentDescription</code> of our <code>Icon</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onNavigateUp</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
) {
    <span class="syntax-all syntax-entity">TopAppBar</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        title <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> title)
        },
        navigationIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                onNavigateUp()
            }) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowBack</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_navigate_up)
                )
            }
        }
    )
}</code></pre>

<figure><img src="9-1.png"/></figure>

<hr />

<h2>Composing the Top App Bar</h2>

<p>At this point we have our two individual app bars, we just need to compose one based on the current destination within the navigation graph. For this, we’re going to create another composable function that will be responsible for composing the app bar based on the current root status. This composable function is going to take a combination of the arguments that we defined for our individual app bar functions, this is so that it can pass those arguments into the corresponding composable functions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
	<span class="syntax-all syntax-parameter">onNavigateUp</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onOpenDrawer</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">showSnackbar</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>At this point we have a reference to the current <code>Destination</code> reference, so we’re going to use this to depict what app bar should be composed. Here we will use a simple <code>if</code> statement to determine whether we are going to compose the <code>RootDestinationTopBar</code> or the <code>ChildDestinationTopBar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DestinationTopBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigateUp</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onOpenDrawer</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">showSnackbar</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (destination.isRootDestination) {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            modifier,
            destination <span class="syntax-all syntax-keyword">=</span> destination,
            openDrawer <span class="syntax-all syntax-keyword">=</span> onOpenDrawer,
            showSnackbar <span class="syntax-all syntax-keyword">=</span> showSnackbar
        )
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
            modifier,
            onNavigateUp,
            destination.title
        )
    }
}</code></pre>

<p>With this composable now in place, we can head back over to our <code>Home</code> composable and adjust the composition of the <code>topBar</code> within our <code>Scaffold</code>. Here we’re now going to compose our <code>DestinationTopBar</code> composable, implementing each of its required arguments.</p>

<ul>
	<li><strong>destination</strong>: for the destination, we can simply pass the <code>currentDestination</code> reference that is being calculated based on the current destination of our navigation graph.</li>
	<li><strong>onNavigateUp</strong>: within this lambda implementation we will use our <code>navController</code> reference to trigger the <code>popBackStack</code> function. From a composable that has been navigated to, this will take the user back ‘up’ to our root composable.</li>
	<li><strong>onOpenDrawer</strong>: here we want to open the navigation drawer, so we’ll handle this in the same way that we were previously - using the <code>coroutineScope</code> and <code>drawerState</code> references.</li>
	<li><strong>showSnackbar</strong>: to show the Snackbar we’ll also handle this in the same way that we were before, using the <code>coroutineScope</code> and <code>scaffoldState</code> references.</li>
</ul>

<pre><code class="code-highlighted code-kt">topBar <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">DestinationTopBar</span>(
		destination <span class="syntax-all syntax-keyword">=</span> currentDestination,
		onNavigateUp <span class="syntax-all syntax-keyword">=</span> {
			navController.popBackStack()
		},
		onOpenDrawer <span class="syntax-all syntax-keyword">=</span> {
			coroutineScope.launch {
				drawerState.<span class="syntax-all syntax-keyword">open</span>()
			}
		},
		showSnackbar <span class="syntax-all syntax-keyword">=</span> {
			coroutineScope.launch {
				scaffoldState.snackbarHostState
					.showSnackbar(it)
            }
        }
    )
}</code></pre>

<p>Here we now have our new Top Bar implementation that is being used to compose a <code>TopAppBar</code> depending on the current destination of our navigation graph. When running the project we’ll now be able to see that the app bar implementation provides expected results based on whether the user is at the root of our app, or has navigated to a composable outside of the Home graph.</p>

<h1>Supporting FAB interactions </h1>

<figure><img src="ii.png"/></figure>

<p>Within our <code>Scaffold</code> we had added a <code>FloatingActionButton</code>, but this is not currently triggering anything within our project. We’re going to trigger another feature of our app here, allowing us to add another nested graph to our navigation setup. We’ll call this feature <strong>Creation</strong>, for which we’ll need to define a new <code>Destination</code>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Creation <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	path <span class="syntax-all syntax-keyword">=</span> &quot;creation&quot;, 
	isRootDestination <span class="syntax-all syntax-keyword">=</span> false
)</code></pre>

<p><strong>Creation</strong> is only the feature for this nested graph, it does not relate to the actual destinations contained within it, so we’ll need to define an actual destination within <strong>Creation</strong>. Here we’re going to launch a placeholder screen that would allow our user to create some content within our app - we’ll only define a single destination within this feature, <strong>Add</strong>.</p>

<p>For this, we’ll use the <code>Icons.Default.Add</code> icon from the material package, along with setting the <code>isRootDestination</code> flag to false - as this is not going to be a feature at the root of our navigation graph.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Add <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>(
	path <span class="syntax-all syntax-keyword">=</span> &quot;add&quot;, 
	icon <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Add</span>, 
	isRootDestination <span class="syntax-all syntax-keyword">=</span> false
)</code></pre>

<p>We’ll also need to update the <code>fromString</code> function to account for this additional <code>Destination</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">companion</span> <span class="syntax-all syntax-keyword">object</span> {

	<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">fromString</span>(<span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span> {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-keyword">when</span> (label) {
            <span class="syntax-all syntax-entity">Feed</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Feed</span>
            <span class="syntax-all syntax-entity">Calendar</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Calendar</span>
            <span class="syntax-all syntax-entity">Contacts</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Contacts</span>
            <span class="syntax-all syntax-entity">Upgrade</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Upgrade</span>
            <span class="syntax-all syntax-entity">Settings</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Settings</span>
			<span class="syntax-all syntax-entity">Add</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Add</span>
			<span class="syntax-all syntax-entity">Creation</span>.path <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Creation</span>
            <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">Home</span>
        }
    }
}</code></pre>

<p>With this in place, we now need to add this destination to our navigation graph. For this we’re going to utilise a nested graph, in the same way, that we have done for the <strong>Home</strong> nested graph. In a real scenario, this would likely be a feature that would have multiple destinations contained within it, so this nested graph sets us up in a good position for that. We’ll use the <strong>Creation</strong> destination as the route for the nested graph, using the <strong>Add</strong> destination for the composable contained inside of the graph.</p>

<pre><code class="code-highlighted code-kt">navigation(
	startDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>.path,
	route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Creation</span>.path
) {
	composable(route <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>.path) {
		<span class="syntax-all syntax-entity">ContentArea</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>
		)
	}
}</code></pre>

<p>With this defined, we can now navigate to this destination within our graph. We already have most of the <code>FloatingActionButton</code> configured within our <code>Home</code>, so we’ll now need to trigger the navigation to our <strong>Creation</strong> feature. Here we’ll use our <code>navController</code> to trigger the navigation command, passing in the path to our <strong>Creation</strong> destination.</p>

<pre><code class="code-highlighted code-kt">floatingActionButton <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-keyword">if</span> (currentDestination <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>) {
		<span class="syntax-all syntax-entity">FloatingActionButton</span>(,
			onClick <span class="syntax-all syntax-keyword">=</span> {
            	navController.navigate(
					<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Creation</span>.path)
			}
        ) {
			<span class="syntax-all syntax-entity">Icon</span>(
				imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Add</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> 		
					stringResource(<span class="syntax-all syntax-entity">R</span>.string.cd_create_item)
            )
        }
    }
}</code></pre>

<p>Within our graph, we defined the <strong>Add</strong> destination as the starting point for the nested <strong>Creation</strong> graph. So when this navigation is triggered, the <strong>Add</strong> destination will be navigated to.</p>

<h1>Supporting multiple device orientations</h1>

<figure><img src="9-2.png"/></figure>

<p>Now that most of our UI and navigational logic is in place, we’re going to explore how we can support different kinds of devices and representations of what we have built. Currently, our UI is using a fixed portrait format - this means that if the user is on a larger device or are using their device in landscape mode, then the UI won’t be providing an optimised experience. </p>

<p>In this section, we’re going to take a look at how we can optimise the UI for these different experiences. One key part of this is going to be how the device behaves in providing a better landscape representation, as this will handle a range of experiences from mobile to desktop devices. For this, we’re going to explore conditionally replacing the Bottom Navigation that we previously implemented, using a Navigation Rail in its place for devices using landscape modes.</p>

<figure><img src="rail.png"/></figure>

<h2>Generalising Navigation Items</h2>

<p>Before we start to create the second type of navigation bar that is supported in our app, we’re going to look at how we can refactor the existing implementation so that its logic is reusable. Currently, our <code>BottomNavigationBar</code> is looking a little something like this:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">BottomNavigation</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_NAVIGATION_BAR</span>)
    ) {
        <span class="syntax-all syntax-constant">listOf</span>(
            <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
            <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
        ).forEach {
            <span class="syntax-all syntax-entity">BottomNavigationItem</span>(
                selected <span class="syntax-all syntax-keyword">=</span> currentDestination.path <span class="syntax-all syntax-keyword">==</span> it.path,
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    onNavigate(it)
                },
                icon <span class="syntax-all syntax-keyword">=</span> {
                    it.icon?.<span class="syntax-all syntax-constant">let</span> { image <span class="syntax-all syntax-keyword">-&gt;</span>
                        <span class="syntax-all syntax-entity">Icon</span>(
							imageVector <span class="syntax-all syntax-keyword">=</span> image, 
							contentDescription <span class="syntax-all syntax-keyword">=</span> it.path
						)
                    }
                },
                label <span class="syntax-all syntax-keyword">=</span> {
                    <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> it.title)
                }
            )
        }
    }
}</code></pre>

<p>When it comes to the navigation rail, we’re still going to display those same navigation items - and the logic for that display is going to look the same, so we’ll want to pull that out into a reusable piece of code. We’re going to start there by creating a new function, <code>buildNavigationBarItems</code> - this function is going to be responsible for building the different navigation destinations for our navigation bars.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>() {

}</code></pre>

<p>What we would want to do here ideally is compose the navigation items - however, because we’re going to be sharing this between a <code>BottomNavigation</code> and <code>NavigationRail</code>, sharing composition is not so simple. When it comes to the <code>BottomNavigation</code> composable, its <code>content</code> uses the <code>RowScope</code> which gives us access to the <code>BottomNavigationItem</code> composable. However, the <code>NavigationRail</code> <code>content</code> uses the <code>ColumnScope</code>, meaning that if we were to share composition between these two composables, we would be unable to use scoped composables such as the <code>BottomNavigationItem</code>. Instead what we’ll do is use this function to build the common requirements for a destination, returning that information for the parent composable to use for composition. This means that the <code>BottomNavigation</code> and <code>NavigationRail</code> will be responsible for composing the navigation items, using the common information that is provided to them.</p>

<p>For this common data, we’re going to create a new class called <code>NavigationBarItem</code>. This class will be used to represent each of the navigation items that need to be displayed inside of the navigation bars.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NavigationBarItem</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">selected</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">onClick</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">icon</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With this class defined, we now have a contract for the data types that are going to be returned from our function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">NavigationBarItem</span>&gt;</code></pre>

<p>Now, using the previously defined Destinations that are being displayed inside of the current bottom navigation, we’re going to want to map these to an equivalent <code>NavigationBarItem</code> representation. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">NavigationBarItem</span>&gt; {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
    ).map {
        <span class="syntax-all syntax-entity">NavigationBarItem</span>(
            ...
        )
    }
}</code></pre>

<p>The <code>NavigationBarItem</code> has four different properties that need to be provided in-order to provide a completed representation of the class. We’ll start here with the <code>label</code> that is used to display textual context for a given destination. For this, we’ll provide a <code>Text</code> composable that will be used to represent this label, we just need to provide a value for its <code>text</code>. Here we’ll take the <code>path</code> property of the given <code>Destination</code>, converting the first character of the word to uppercase.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">NavigationBarItem</span>&gt; {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
    ).map {
        <span class="syntax-all syntax-entity">NavigationBarItem</span>(
            label <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> it.path.replaceFirstChar { char <span class="syntax-all syntax-keyword">-&gt;</span>
                    char.titlecase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
                })
            }
        )
    }
}</code></pre>

<p>Next up we have the <code>icon</code>, this is also going to be displayed within the destination for the navigation bar. If the <code>Destination</code> has an <code>icon</code> available, then here we’ll want to compose an <code>Icon</code> using this available <code>icon</code>. We don’t need to provide a content description here because we already have the path of the <code>Destination</code> that is providing navigational context.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">NavigationBarItem</span>&gt; {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
    ).map {
        <span class="syntax-all syntax-entity">NavigationBarItem</span>(
       		icon <span class="syntax-all syntax-keyword">=</span> {
                it.icon?.<span class="syntax-all syntax-constant">let</span> { image <span class="syntax-all syntax-keyword">-&gt;</span>
                    <span class="syntax-all syntax-entity">Icon</span>(
						imageVector <span class="syntax-all syntax-keyword">=</span> image, 
						contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
					)
                }
            },
            label <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> it.path.replaceFirstChar { char <span class="syntax-all syntax-keyword">-&gt;</span>
                    char.titlecase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
                })
            }
        )
    }
}</code></pre>

<p>Next, we have the <code>selected</code> property - this will depict whether the giving <code>Destination</code> is currently selected within the navigation bar. For this, the function is going to need a little more information about what <strong>is</strong> the currently selected <code>Destination</code>, so we’ll add this as an argument to the function. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>(
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>
)</code></pre>

<p>With this in place, we can now use this to calculate the <code>selected</code> value. If here the path of the <code>currentDestination</code> is equal to the <code>path</code> of the <code>Destination</code> that we are currently building a <code>NavigationBarItem</code> for, then the item is to be recognised as selected. We can represent this by checking for equality against these two values.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>(
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">NavigationBarItem</span>&gt; {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
    ).map {
        <span class="syntax-all syntax-entity">NavigationBarItem</span>(
            selected <span class="syntax-all syntax-keyword">=</span> currentDestination.path <span class="syntax-all syntax-keyword">==</span> it.path,
            icon <span class="syntax-all syntax-keyword">=</span> {
                it.icon?.<span class="syntax-all syntax-constant">let</span> { image <span class="syntax-all syntax-keyword">-&gt;</span>
                    <span class="syntax-all syntax-entity">Icon</span>(
						imageVector <span class="syntax-all syntax-keyword">=</span> image, 
						contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
					)
                }
            },
            label <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> it.path.replaceFirstChar { char <span class="syntax-all syntax-keyword">-&gt;</span>
                    char.titlecase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
                })
            }
        )
    }
}</code></pre>

<p>For the last property, we have the <code>onClick</code> property. This is going to be used as a callback to be triggered whenever the navigation item is clicked, which is something we’re going to want to pass up to the parent composable to handle navigation. For this we’ll want to define another function argument, allowing us to pass up the <code>Destination</code> that is being navigated to. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>(
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With this in place, we can now trigger this <code>onNavigate</code> lambda from within the <code>onClick</code> handler of the <code>NavigationBarItem</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildNavigationBarItems</span>(
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">NavigationBarItem</span>&gt; {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
    ).map {
        <span class="syntax-all syntax-entity">NavigationBarItem</span>(
            selected <span class="syntax-all syntax-keyword">=</span> currentDestination.path <span class="syntax-all syntax-keyword">==</span> it.path,
            onClick <span class="syntax-all syntax-keyword">=</span> {
                onNavigate(it)
            },
            icon <span class="syntax-all syntax-keyword">=</span> {
                it.icon?.<span class="syntax-all syntax-constant">let</span> { image <span class="syntax-all syntax-keyword">-&gt;</span>
                    <span class="syntax-all syntax-entity">Icon</span>(
						imageVector <span class="syntax-all syntax-keyword">=</span> image, 
						contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
					)
                }
            },
            label <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> it.path.replaceFirstChar { char <span class="syntax-all syntax-keyword">-&gt;</span>
                    char.titlecase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
                })
            }
        )
    }
}</code></pre>

<p>Now that we have this <code>buildNavigationBarItems</code> function in place, we can tweak the implementation of our <code>BottomNavigationBar</code> to account for this change. So now instead of declaring the different navigational aspects inside of this composable, we’re instead going to use the result of the <code>buildNavigationBarItems</code> function call to compose each of the <code>BottomNavigationItem</code> that is to be displayed inside of our navigation bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">BottomNavigation</span> {
        buildNavigationBarItems(
            currentDestination,
            onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
        ).forEach {
            <span class="syntax-all syntax-entity">BottomNavigationItem</span>(
                selected <span class="syntax-all syntax-keyword">=</span> it.selected,
                onClick <span class="syntax-all syntax-keyword">=</span> it.onClick,
                icon <span class="syntax-all syntax-keyword">=</span> { it.icon() },
                label <span class="syntax-all syntax-keyword">=</span> { it.label() }
            )
        }
    }
}</code></pre>

<p>So here, the <code>BottomNavigation</code> content is being composed based on the result of the <code>buildNavigationBarItems</code> function. For each item inside of this result, we’re composing a <code>BottomNavigationItem</code> and assigning each property of the item to the corresponding property of the <code>BottomNavigationItem</code> composable.</p>

<p>With the declaration of our navigation items now being defined inside of this <code>buildNavigationBarItems</code> function, we’re able to reuse this across the different navigation bars that we are going to support - allowing us to remove any duplication of code, as well as ensuring that the maintenance of these only needs to occur in one place.</p>

<hr />

<h2>Building the Navigation Rail</h2>

<p>Now that we have our shared navigation items in place, we can utilise this to build out the <code>NavigationRail</code> that’s going to be used for landscape orientations of our layout. Similar to how we approached the <code>BottomNavigationBar</code> composable, we’re going to create a new composable function <code>RailNavigationBar</code>. This is going to take the same arguments that we used for the <code>BottomNavigationBar</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">RailNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We’re then going to compose a <code>NavigationRail</code> inside of this, passing the <code>modifier</code> that was provided to our composable function. Similar to the <code>buildNavigationBarItems</code> usage inside of the <code>BottomNavigationBar</code> composable, we’ll then use the result of this to compose the navigation items to be shown in the bar. The key difference here is the use of the <code>NavigationRailItem</code> composable, assigning the corresponding properties to the constructor.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">RailNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onCreateItem</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">NavigationRail</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        buildNavigationBarItems(
            currentDestination <span class="syntax-all syntax-keyword">=</span> currentDestination,
            onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
        ).forEach {
            <span class="syntax-all syntax-entity">NavigationRailItem</span>(
                selected <span class="syntax-all syntax-keyword">=</span> it.selected,
                onClick <span class="syntax-all syntax-keyword">=</span> it.onClick,
                icon <span class="syntax-all syntax-keyword">=</span> { it.icon() },
                label <span class="syntax-all syntax-keyword">=</span> { it.label() }
            )
        }
    }
}</code></pre>

<figure><img src="1-15.png"/></figure>

<p>While at this point the navigation items are being composed, we’re going to want to utilise an extended feature of the <code>NavigationRail</code> composable - the ability to display a header item, which is often done in the form of a floating action button. For this we’re going to compose a button that allows the user to navigate to the creation screen, which we defined in the previous chapter - this is the same behaviour as the floating action button within our scaffold.</p>

<p>For this we’ll need to start by adding a new lambda function to the constructor of our composable, <code>onCreateItem</code> - this will be used to trigger the event from the header item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">RailNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onCreateItem</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Next, we can look at composing a <code>FloatingActionButton</code> inside of the <code>header</code> of the <code>NavigationRail</code>. You might notice that this implementation looks the same as what we have inside of the <code>Scaffold</code> for our screen - we compose an <code>Icon</code> for the button using the <code>Icons.Default.Add</code> for the <code>imageVector</code>, along with the <code>cd_create_item</code> resource for the content description. Finally, we trigger the <code>onCreateItem</code> lambda within the <code>onClick</code> handler for the <code>FloatingActionButton</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">RailNavigationBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">currentDestination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
	<span class="syntax-all syntax-parameter">onCreateItem</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">NavigationRail</span>(
        header <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">FloatingActionButton</span>(
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    onCreateItem()
                }
            ) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Add</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
						<span class="syntax-all syntax-entity">R</span>.string.cd_create_item)
                )
            }
        }
    ) {
        buildNavigationBarItems(
            currentDestination <span class="syntax-all syntax-keyword">=</span> currentDestination,
            onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
        ).map {
            <span class="syntax-all syntax-entity">NavigationRailItem</span>(
                selected <span class="syntax-all syntax-keyword">=</span> it.selected,
                onClick <span class="syntax-all syntax-keyword">=</span> it.onClick,
                icon <span class="syntax-all syntax-keyword">=</span> { it.icon() },
                label <span class="syntax-all syntax-keyword">=</span> { it.label() }
            )
        }
    }
}</code></pre>

<figure><img src="2-15.png"/></figure>

<p>With this in place, we now have the composition for a <code>NavigationRail</code> that displays the different <code>Destinations</code> that are available for our application. Here we are reusing the same declarations that the <code>BottomNavigationBar</code> composable is using, ensuring consistency and reuse across the different navigation bars that our apps support.</p>

<hr />

<h2>Composing the Navigation Rail</h2>

<p>Now that we’ve built out the composable for our <code>NavigationRail</code>, we’re going to want to compose it within our UI. When it comes to this <code>NavigationRail</code>, it’s going to be composed in a different location within our <code>Scaffold</code>. This is because the <code>Scaffold</code> provides a block for the composition of a<code>bottomBar</code> to be declared, but this is not the place that we compose the <code>NavigationRail</code> - there is also no specific block for this component. The <code>NavigationRail</code> is going to be composed inside of the <code>content</code> block, which is currently where <code>Navigation</code> is being composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
	...
) {
	<span class="syntax-all syntax-entity">Navigation</span>(
    	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        navController <span class="syntax-all syntax-keyword">=</span> navController
    )
}</code></pre>

<p>We’re going to want to conditionally compose the <code>NavigationRail</code> alongside this <code>Navigation</code>, so to keep things tidy we’re going to start by splitting out this <code>Navigation</code> into its own composable function - passing the required arguments that that <code>Navigation</code> composable is currently utilising.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Body</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>
) {
	<span class="syntax-all syntax-entity">Navigation</span>(
    	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        navController <span class="syntax-all syntax-keyword">=</span> navController
    )
}</code></pre>

<p>When displaying the <code>NavigationRail</code>, this is going to be composable to the start of the <code>Navigation</code> - so these are going to be composed horizontally. To set this up, we’ll start by wrapping the existing <code>Navigation</code> inside of a <code>Row</code> composable. The only thing that we’ll change here is setting the provided modifier to the parent <code>Row</code> composable, now manually providing a modifier to the <code>Navigation</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Body</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Navigation</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            navController <span class="syntax-all syntax-keyword">=</span> navController
        )
    }
}</code></pre>

<p>With this in place, we can now start working on composing the <code>NavigationRail</code>. We’re only going to want to compose this <code>NavigationRail</code> when the device is in landscape, so we’re going to need to provide two further arguments to our <code>Body</code> composable. This will be a <code>Destination</code> to represent the current destination, along with an <code>orientation</code> value - using these two arguments we can then prepare a conditional statement block. We only want to display the navigation for the app if we are at a root destination, so we’ll use a combination of checking that the provided <code>Destination</code> is a root destination, along with checking that the provided <code>orientation</code> is in fact <code>ORIENTATION_LANDSCAPE</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Body</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>,
	<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">orientation</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier.fillMaxSize()) {
        <span class="syntax-all syntax-keyword">if</span> (destination.isRootDestination <span class="syntax-all syntax-keyword">&amp;&amp;</span>
            orientation <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Configuration</span>.<span class="syntax-all syntax-entity">ORIENTATION_LANDSCAPE</span>
        ) {
            
        }
        <span class="syntax-all syntax-entity">Navigation</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            navController <span class="syntax-all syntax-keyword">=</span> navController
        )
    }
}</code></pre>

<p>With this conditional block in place, all that’s left for us to do inside of this function is compose the <code>RailNavigationBar</code>. To compose this, we’re going to need to further arguments that can be provided to our <code>RailNavigationBar</code> - these are the <code>onCreateItem</code> and <code>onNavigate</code> lambdas. We’ll want to pass these up to the parent composable to handle, so we’ll provide these as arguments to the <code>Body</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Body</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>,
	<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">orientation</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
	<span class="syntax-all syntax-parameter">onCreateItem</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With these in place, we now have all of the required arguments available to compose the <code>RailNavigationBar</code> inside of our conditional block.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Body</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">navController</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NavHostController</span>,
	<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>,
    <span class="syntax-all syntax-parameter">orientation</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
	<span class="syntax-all syntax-parameter">onCreateItem</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onNavigate</span><span class="syntax-all syntax-keyword">:</span> (destination<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier.fillMaxSize()) {
        <span class="syntax-all syntax-keyword">if</span> (destination.isRootDestination <span class="syntax-all syntax-keyword">&amp;&amp;</span>
            orientation <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Configuration</span>.<span class="syntax-all syntax-entity">ORIENTATION_LANDSCAPE</span>
        ) {
            <span class="syntax-all syntax-entity">RailNavigationBar</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> modifier,
                currentDestination <span class="syntax-all syntax-keyword">=</span> destination,
                onCreateItem <span class="syntax-all syntax-keyword">=</span> onCreateItem,
                onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
            )
        }
        <span class="syntax-all syntax-entity">Navigation</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            navController <span class="syntax-all syntax-keyword">=</span> navController
        )
    }
}</code></pre>

<p>Now that our <code>Body</code> composable is complete, we can now compose this inside of the <code>content</code> block of the <code>Scaffold</code>. When doing this, we’re going to need to provide the various arguments that the <code>Body</code> requires for composition.</p>

<ul>
	<li>For the modifier we want this to fill the maximum size that is available to it, so we’ll provide the <code>fillMaxSize</code> modifier here</li>
	<li>The <code>destination</code>, <code>orientation</code> and <code>navController</code> are all arguments that we have values available for. We’ll pass these directly into our <code>Body</code> composable for the corresponding arguments</li>
	<li>For the <code>onCreateItem</code> lambda, we’re going to need to handle the navigation to the <code>Add</code> destination. Here we’ll do the same as we do for the <code>FloatingActionButton</code> that is within our <code>Scaffold</code>, utilising the <code>navigate</code> function of our <code>navController</code> to trigger navigation to the <code>Add</code> destination.</li>
	<li>Next, we’ll need to handle the <code>onNavigate</code> block - this will be used to handle the selection of any navigation items inside of the contained <code>NavigationRail</code>. For this, we’re going to provide the same implementation that is being used for the <code>BottomNavigationBar</code>, using the <code>navController</code> reference to handle navigation for the bar</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(...) {

	<span class="syntax-all syntax-entity">Body</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
		destination <span class="syntax-all syntax-keyword">=</span> currentDestination,
        orientation <span class="syntax-all syntax-keyword">=</span> orientation,
        navController <span class="syntax-all syntax-keyword">=</span> navController,
        onCreateItem <span class="syntax-all syntax-keyword">=</span> {
            navController.navigate(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>.path)
        },
        onNavigate <span class="syntax-all syntax-keyword">=</span> {
            navController.navigate(it.path) {
                popUpTo(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.path) {
                    saveState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                }
                launchSingleTop <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                restoreState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
            }
        }
    )
}</code></pre>

<p>With this in place, we now have a <code>Body</code> composable which will compose its content based on the orientation of the device and current destination. This allows for the <code>NavigationRail</code> to be composed when the device is in landscape and the current destination represents a root destination, followed by the <code>Navigation</code> being composed alone otherwise.</p>

<figure><img src="1-16.png"/></figure>

<hr />

<h2>Hiding the Bottom Bar in landscape mode</h2>

<p>Currently, the <code>BottomNavigationBar</code> within the <code>Scaffold</code> is being displayed in any orientation, representing the composition for the <code>bottomBar</code> content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
  	...,
	bottomBar <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-entity">BottomNavigationBar</span>(
			currentDestination <span class="syntax-all syntax-keyword">=</span> currentDestination,
           	onNavigate <span class="syntax-all syntax-keyword">=</span> {
            	navController.navigate(it.path) {
    	            popUpTo(navController.graph
						.findStartDestination().id) {
                    	saveState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                    }
                    launchSingleTop <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                    restoreState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                }
            }
        )
    }
)</code></pre>

<p>While this is fine to be composed when the device is in portrait, this isn’t going to look quite right when in landscape mode. This is because when in landscape we are composing the <code>NavigationRail</code>, meaning that both navigation bars will be displayed. Because of this, we’re not going to want to compose the <code>BottomNavigationBar</code> for our <code>Scaffold</code> in the landscape scenario. Here we’ll simply add an <code>if</code> statement to check the current orientation, meaning that the<code>BottomNavigationBar</code> will only be composed if the orientation is not that of <code>ORIENTATION_LANDSCAPE</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
  	...,
	bottomBar <span class="syntax-all syntax-keyword">=</span> {
        <span class="syntax-all syntax-keyword">if</span> (orientation <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">Configuration</span>.<span class="syntax-all syntax-entity">ORIENTATION_LANDSCAPE</span> 		<span class="syntax-all syntax-keyword">&amp;&amp;</span> currentDestination.isRootDestination
        ) {
            <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
                currentDestination <span class="syntax-all syntax-keyword">=</span> currentDestination,
                onNavigate <span class="syntax-all syntax-keyword">=</span> {
                    navController.navigate(it.path) {
                        popUpTo(navController.graph
							.findStartDestination().id) {
                            saveState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                        }
                        launchSingleTop <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                        restoreState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                    }
                }
            )
        }
    }
)</code></pre>

<p>We’ll be able to see here now that when the device is in portrait, the <code>BottomNavigationBar</code> is composed. But when in landscape, the composition does not occur here and we rely on the <code>NavigationRail</code> that is composed at the starting side of the screen.</p>

<figure><img src="2-16.png"/></figure>

<hr />

<h2>Hiding the FAB in landscape mode</h2>

<p>Currently, the <code>FloatingActionButton</code> within our <code>Scaffold</code> is being displayed when the user is currently at the <code>Feed</code> <code>Destination</code>. This button is used to navigate to the <code>Add</code> <code>Destination</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
	...,
  	floatingActionButton <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-keyword">if</span> (navController.currentDestination<span class="syntax-all syntax-keyword">!!</span>.route <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path
		) {        
			<span class="syntax-all syntax-entity">FloatingActionButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
              	navController.navigate(
					<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>.path)
            }) {
               	<span class="syntax-all syntax-entity">Icon</span>(
                   	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Add</span>,
                   	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
						<span class="syntax-all syntax-entity">R</span>.string.cd_create_item)
               	)
            }
        }
    }
)</code></pre>

<p>The thing is when in the landscape orientation and the <code>NavigationRail</code> is composed, that rail displays its own button to launch the <code>Add</code> <code>Destination</code>. Because of this, we’re going to want to hide the <code>FloatingActionButton</code> that is composed in our <code>Scaffold</code>. Here we’ll simply add to the <code>if</code> statement that is already being used to check the current destination. Here we’ll also check the current orientation, meaning that the button will only be composed if the orientation is not that of <code>ORIENTATION_LANDSCAPE</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
	...,
  	floatingActionButton <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-keyword">if</span> (orientation <span class="syntax-all syntax-keyword">!=</span>
			<span class="syntax-all syntax-entity">Configuration</span>.<span class="syntax-all syntax-entity">ORIENTATION_LANDSCAPE</span> <span class="syntax-all syntax-keyword">&amp;&amp;</span> 
			navController.currentDestination<span class="syntax-all syntax-keyword">!!</span>.route <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path
		) {  
			<span class="syntax-all syntax-entity">FloatingActionButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
              	navController.navigate(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>.path)
            }) {
               	<span class="syntax-all syntax-entity">Icon</span>(
                   	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Add</span>,
                   	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
						<span class="syntax-all syntax-entity">R</span>.string.cd_create_item)
               	)
            }
        }
    }
)</code></pre>

<p>We’ll be able to see here now that when the device is in portrait, the <code>FloatingActionButton</code> is composed. But when in landscape, the composition does not occur here and we rely on the <code>NavigationRail</code> header for this action.</p>

<figure><img src="1-17.png"/></figure>

<hr />

<h2>Wrapping Up</h2>

<figure><img src="11-2.png"/></figure>

<p>With all of the above in place, we’ve been able to make some modifications so that our UI is conditionally composed based on the current orientation of the device. This allows us to build experiences that are optimised for a wider range of devices, providing a better user experience from our app.</p>

<h1>Testing the Home Screen UI</h1>

<p>Now that we’ve built our Home screen, we’re going to take a look at how we can write tests for our composables. We’re going to be writing some instrumentation tests using the compose ui-test-junit package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>)
debugImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to add mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered whenever expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:3.12.4&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependant on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		exclude <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/AL2.0&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/LGPL2.1&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
	}
}</code></pre>

<hr />

<h2>Testing the Top Bars</h2>

<p>We’re going to start by writing some tests for the different top bars that are displayed within our UI.</p>

<h3>Testing the Child Top Bar</h3>

<p>We’ll start here by creating a new class, <strong> ChildDestinationTopBarTest</strong> - this class will be used to contain the different tests that we’re going to write.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ChildDestinationTopBarTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the <code>ComposeContentTestRule</code> class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@get:Rule
</span><span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched in, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside of.</p>

<p>We’ll start here by testing that the title is displayed within the <code>ChildDestinationTopBar</code> composable. To test this, we’ll want to create a reference to a title, passing this in for the <code>title</code> argument during composition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
            onUpClicked <span class="syntax-all syntax-keyword">=</span> { },
            title <span class="syntax-all syntax-keyword">=</span> title
        )
    }
}</code></pre>

<p>With this now being displayed, we can next perform the required assertions to ensure that the expected title is being displayed within our composable UI. We’ll do this by utilising the <code>onNodeWithText</code> function from our test rule reference.</p>

<p>The <code>onNodeWithText</code> function can be used to locate a composable that is displaying the text that we have provided to the function. Composables will be located in the form of a semantic node. Because our composables are represented via semantics, in our tests we are essentially going to be locating nodes within our semantic tree. In this case, this is done using the <code>onNodeWithText</code> function, which will return us with a <code>SemanticsNodeInteraction</code> reference to perform assertions against. </p>

<p>For this test we want to assert that this node is being displayed within our composed UI, so we’re going to go ahead and utilise the <code>assertIsDisplayed</code> function. This is one of the assertions available on the <code>SemanticsNodeInteraction</code> class, allowing us to assert whether this node is being displayed on the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
            onUpClicked <span class="syntax-all syntax-keyword">=</span> { },
            title <span class="syntax-all syntax-keyword">=</span> title
        )
    }
    composeTestRule.onNodeWithText(
        title
    ).assertIsDisplayed()
}</code></pre>

<p>Next, we’re going to check that the navigation icon within the top bar is displayed as expected. We’ll need to start here by composing the <code>ChildDestinationTopBar</code>, providing values for both of the required arguments. We don’t care what the values of these are within this test, so we’ll pass an empty lambda for the <code>onUpClicked</code> argument, along with a string value using the <code>Feed</code> <code>Destination</code> for the <code>title</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Icon_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
            onUpClicked <span class="syntax-all syntax-keyword">=</span> { },
            title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title
        )
    }
}</code></pre>

<p>Next, we want to assert that the expected icon is displayed within the top bar. For this we’re going to use the <code>onNodeWithContentDescription</code> function - this allows us to provide a string that will be used to find a node whose content description semantic matches the provided value. For this assertion, we’ll use the <code>cd_navigate_up</code> string resource, followed by asserting this icon is displayed using the <code>assertIsDisplayed</code> assertion function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Icon_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
            onUpClicked <span class="syntax-all syntax-keyword">=</span> { },
            title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title
        )
    }

    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_navigate_up)
    ).assertIsDisplayed()
}</code></pre>

<p>Now that we know the icon is being displayed, we’re going to want to assert that the provided lambda function is triggered when the icon is clicked. Here we’re going to use <code>mockito</code> to provide a mock implementation of this callback - allowing us to verify that it is triggered as expected. We’ll pass in this mock implementation to the <code>onUpClicked</code> argument of the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Icon_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> onUpClicked<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
            onUpClicked <span class="syntax-all syntax-keyword">=</span> onUpClicked,
            title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title
        )
    }   
}</code></pre>

<p>Now that this mock implementation is being provided for our composition, we can go ahead and perform the required operation that would trigger that callback. In a previous test, we performed an assertion on the visibility of the navigation icon - we’ll need to locate the same node here using the <code>cd_navigate_up</code> resource, this time using the <code>performClick</code> function to perform an action instead of an assertion.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Icon_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> onUpClicked<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
            onUpClicked <span class="syntax-all syntax-keyword">=</span> onUpClicked,
            title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title
        )
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_navigate_up)
    ).performClick()
}</code></pre>

<p>When this icon is clicked, it would be expected that the lambda we provided would be triggered. We have a mock implementation of this callback in place, so we can use this to verify interactions. For this we’re going to utilise the mockito <code>verify</code> functionality - this allows us to assert that our callback has been triggered within the scope of our test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Icon_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> onUpClicked<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
            onUpClicked <span class="syntax-all syntax-keyword">=</span> onUpClicked,
            title <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title
        )
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_navigate_up)
    ).performClick()

    verify(onUpClicked).invoke()
}</code></pre>

<p>With this in place, we’re now able to assert that the navigation icon is successfully triggering the action that has been provided via the composable function.</p>

<h3>Testing the Root Navigation Top Bar</h3>

<p>While we have tests in place for the <code>ChildDestinationTopBar</code> composable, we’re now also going to add some quick tests for the <code>RootDestinationTopBar</code>. These won’t differ too much from the tests that we’ve already implemented, but allow us to reinforce our learnings and also add some coverage for this additional top bar. We’ll start here by defining a new test class to hold these tests, <code>RootDestinationTopBarTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">RootDestinationTopBarTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<h4>Testing the title display</h4>

<p>We’ll want to start here by asserting that the expected title is displayed in the <code>RootDestinationTopBar</code> composable. This is important because this top bar should always display the <code>Destination.Home</code> <code>title</code>, so we’ll test here that this is the case. We’ll need to begin by composing the <code>RootDestinationTopBar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Next, we’ll locate a node with the composable using the <code>onNodeWithText</code> function - this will find a node that has the corresponding <code>text</code> semantic property. For this value we’ll pass the <code>title</code> for the <code>Home</code> destination, followed by performing the <code>assertIsDisplayed</code> assertion, allowing us to test that a node with this text content is being displayed within the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>.title
    ).assertIsDisplayed()
}</code></pre>

<h4>Testing the menu icon display</h4>

<p>Next, we’re going to check that the navigation icon within the top bar is displayed as expected. We’ll need to start here by composing the <code>RootDestinationTopBar </code>, providing values for both of the required arguments. We don’t care what the values of these are within this test, so we’ll pass empty lambdas for the <code>openDrawer</code> and <code>showSnackbar</code> arguments, along with a <code>destination</code> in the form of <code>Home</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Menu_Icon_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Next, we want to assert that the expected icon is displayed within the top bar. For this we’re going to use the <code>onNodeWithContentDescription</code> function - this allows us to provide a string that will be used to find a node whose content description semantic matches the provided value. For this assertion, we’ll use the <code>cd_open_menu</code> string resource, followed by asserting this icon is displayed using the <code>assertIsDisplayed</code> assertion function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Menu_Icon_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_open_menu)
    ).assertIsDisplayed()
}</code></pre>

<h4>Testing the menu icon callback</h4>

<p>Now that we know the icon is being displayed, we’re going to want to assert that the provided lambda function is triggered when the icon is clicked. Here we’re going to use <code>mockito</code> to provide a mock implementation of this callback - allowing us to verify that it is triggered as expected. We’ll pass in this mock implementation to the <code>openDrawer</code> argument of the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Menu_Icon_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> openDrawer<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> openDrawer,
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Now that this mock implementation is being provided for our composition, we can go ahead and perform the required operation that would trigger that callback. In a previous test, we performed an assertion on the visibility of the navigation icon - we’ll need to locate the same node here using the <code>cd_open_menu</code> resource, this time using the <code>performClick</code> function to perform an action instead of an assertion.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Menu_Icon_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> openDrawer<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> openDrawer,
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_open_menu)
    ).performClick()
}</code></pre>

<p>When this icon is clicked, it would be expected that the lambda we provided would be triggered. We have a mock implementation of this callback in place, so we can use this to verify interactions. For this we’re going to utilise the mockito <code>verify</code> functionality - this allows us to assert that our callback has been triggered within the scope of our test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Menu_Icon_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> openDrawer<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> openDrawer,
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_open_menu)
    ).performClick()

    verify(openDrawer).invoke()
}</code></pre>

<h4>Testing the info icon display</h4>

<p>Within this app bar, we are also displaying an action icon - this icon also triggers a callback, so we’ll add a couple of tests to assert that this is displayed as expected and can be interacted with by the user. We’ll start here by testing that the action is displayed, for which we’ll need to compose a <code>RootDestinationTopBar</code> within our test. When composing this we’ll need to provide a <code>destination</code> value that supports the action within the app bar, which is any value other than the <code>Feed</code> destination.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Info_Icon_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>This composable is using a content description to describe its purpose to accessibility services, in the form of the <code>cd_more_information</code> resource. Within our test we’ll use this to locate the desired node, using the <code>onNodeWithContentDescription</code> function. Once this node has been located we can trigger the <code>assertIsDisplayed</code> function to assert that this node is being displayed within our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Info_Icon_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
    ).assertIsDisplayed()
}</code></pre>

<p>As previously mentioned, the info action is only displayed when the <code>Feed</code> destination is not provided to the composable function. This composable contains logic that depicts if the action should be displayed, so we’re going to add a quick test to have some coverage for this logic - allowing us to assert that this icon is not displayed when the <code>Feed</code> destination is provided. We’ll want to start here by composing the <code>RootDestinationTopBar</code>, providing the <code>Feed</code> destination.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Info_Icon_Displayed_Never_Displayed_For_Feed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Next, we’ll want to assert that this action icon is not being displayed within the app bar. Here we’ll again attempt to locate a node using the <code>cd_more_information</code> content description, this time asserting that such a node does not exist using the <code>assertDoesNotExist</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Info_Icon_Displayed_Never_Displayed_For_Feed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
    ).assertDoesNotExist()
}</code></pre>

<p>This allows us to assert that when composition occurs for the <code>Feed</code> destination, the expected state would be that the action is <strong>not displayed</strong> within the app bar.</p>

<h4>Testing the action icon callback</h4>

<p>In the cases where the action is displayed within the composable, the user can interact with this to trigger the <code>showSnackbar</code> lambda function. To ensure that this is being triggered when expected, we’re going to add a quick test. We’ll need to again compose the <code>RootDestinationTopBar</code>, providing a mock implementation for the <code>showSnackbar</code> lambda.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Info_Icon_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> showSnackbar<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> showSnackbar
        )
    }
}</code></pre>

<p>With this composition in place, we can now perform the required actions and assertions on our composable to ensure that it is behaving as expected. We’ll use the <code>onNodeWithContentDescription</code> function on our test rule to retrieve the node with the provided content description. We’ll provide the content description that is being used for this icon, <code>cd_more_information</code>, to locate this - followed by the <code>performClick</code> function to trigger a click event on the composable.</p>

<p>When this click event occurs, it is expected that the <code>not_available_yet</code> message is passed up via the<code>showSnackbar</code> lambda. We’ll use the <code>verify</code> function from mockito to perform this assertion - allowing us to ensure that this lambda is invoked, passing the expected message when done so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Info_Icon_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> showSnackbar<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            openDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> showSnackbar
        )
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.cd_more_information)
    ).performClick()

    verify(showSnackbar).invoke(
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.not_available_yet)
	)
}</code></pre>

<h3>Testing the Destination Top Bar</h3>

<p>Next up we have the <code>DestinationTopBar</code> composable, this is used to handle the composition of a top bar, depending on the destination that is provided to it - this will be either the <code>RootDestinationTopBar</code> or <code>ChildDestinationTopBar</code>, which we individually wrote tests for in the last section. Here we’ll want to test that:</p>

<ul>
	<li>The <code>RootDestinationTopBar</code> composable is displayed when a root destination is provided to it</li>
	<li>The <code>ChildDestinationTopBar</code> composable is displayed when a non-root composable is provided to it</li>
</ul>

<p>We’ll start here by creating a new test class, <code>DestinationTopBarTest</code>, configuring the required test rule inside of it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">DestinationTopBarTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’ll start here by writing a test that will assert that the <code>RootDestinationTopBar</code> is displayed when a root <code>Destination</code> is provided to it. We’ll compose a <code>DestinationTopBar</code> here, passing the <code>Home</code> destination for the <code>destination</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Root_Destination_Top_Bar_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            onNavigateUp <span class="syntax-all syntax-keyword">=</span> { },
            onOpenDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>So that we can perform the desired assertion, we’ll next need to add a tag to the top bar composable. We’ll create a new object, <code>Tags</code>, and define a new tag that can be assigned to our <code>RootDestinationTopBar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_ROOT_TOP_BAR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;root_top_bar&quot;</span>
}</code></pre>

<p>With these tags defined we can now use the <code>testTag</code> function to assign this tag to our <code>RootDestinationTopBar</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// RootDestinationTopBar.kt
</span><span class="syntax-all syntax-entity">RootDestinationTopBar</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_ROOT_TOP_BAR</span>),
	...
)</code></pre>

<p>With this tag in place, it can now be used to locate a node within our composable hierarchy using the <code>onNodeWithTag</code> function. On this node, we can then use the <code>assertIsDisplayed</code> function to assert that this composable is being displayed, as expected, within the composed UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Root_Destination_Top_Bar_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            onNavigateUp <span class="syntax-all syntax-keyword">=</span> { },
            onOpenDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_ROOT_TOP_BAR</span>
    ).assertIsDisplayed()
}</code></pre>

<p>On the flip side, we’re going to also want to check that when a root <code>Destination</code> <strong>is</strong> being composed, the <code>ChildDestinationTopBar</code> is not displayed within the UI. To be able to assert this, we’ll again need to add a tag to be able to locate this node.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_ROOT_TOP_BAR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;root_top_bar&quot;</span>
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHILD_TOP_BAR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;child_top_bar&quot;</span>
}</code></pre>

<p>We’ll then need to again assign this to the corresponding composable, which in this case is the <code>ChildDestinationTopBar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ChildDestinationTopBar.kt
</span><span class="syntax-all syntax-entity">ChildDestinationTopBar</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_CHILD_TOP_BAR</span>),
	...
)</code></pre>

<p>With this tag in place, we can now locate this node within our tests. Here we’ll compose the same <code>DestinationTopBar</code> as the previous test, except this time we’ll use the <code>TAG_TOP_BAR</code> tag to assert that the node with that tag does not currently exist within the composition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Top_Bar_Never_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Home</span>,
            onNavigateUp <span class="syntax-all syntax-keyword">=</span> { },
            onOpenDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_TOP_BAR</span>
    ).assertDoesNotExist()
}</code></pre>

<p>With the above tests in place, we’re able to assert that the expected UI is composed when a root <code>Destination</code> is provided to our <code>DestinationTopBar</code> composable. We’re now going to write some tests to assert that the expected state is also composed for the UI when a non-root destination is provided to our <code>DestinationTopBar</code> composable.</p>

<p>We’ll start here by composing a <code>DestinationTopBar</code>, this time providing a non-root <code>Destination</code> in the form of <code>Destination.Add</code>. When a non-root destination is provided we expect that the <code>ChildDestinationTopBar</code> is composed - so here we’ll want to assert that the composable with the <code>TAG_TOP_BAR</code> tag is displayed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Top_Bar_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>,
            onNavigateUp <span class="syntax-all syntax-keyword">=</span> { },
            onOpenDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_TOP_BAR</span>
    ).assertIsDisplayed()
}</code></pre>

<p>When this is the case and the <code>ChildDestinationTopBar</code> is composed, we would expect that the <code>RootDestinationTopBar</code> is not composed. In this next test, we’ll configure the same composition as the previous test, except this time we’ll assert that the <code>RootDestinationTopBar</code> does not exist within our composition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Root_Destination_Top_Bar_Never_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DestinationTopBar</span>(
            destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>,
            onNavigateUp <span class="syntax-all syntax-keyword">=</span> { },
            onOpenDrawer <span class="syntax-all syntax-keyword">=</span> { },
            showSnackbar <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_ROOT_TOP_BAR</span>
    ).assertDoesNotExist()
}</code></pre>

<hr />

<h2>Testing Bottom Navigation</h2>

<p>Now that we’ve got all of the tests in place for the top app bars within our UI, we’re next going to move on to testing the composition of the <code>BottomNavigationBar</code> composable. Here we’re going to want to write some tests that allow us to assert that:</p>

<ul>
	<li>The bottom navigation bar is displayed</li>
	<li>The navigation items are displayed within the bottom navigation bar</li>
	<li>The navigation callback is triggered upon item select</li>
	<li>The currently selected item is marked as selected</li>
</ul>

<p>With these test requirements in mind, we’re going to go ahead and write a new test class, <code>BottomNavigationTest</code>, configuring the compose test rule in the process.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">BottomNavigationTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’re going to start here by writing a test to assert that the bottom navigation composable is displayed within the composed UI. We’re going to start here by writing a new test, <code>Bottom_Navigation_Displayed</code>, composing a <code>BottomNavigationBar</code> in the process. Here we’ll pass a <code>Destination</code>, along with an empty lambda for the <code>onNavigate</code> - this is because we don’t need the lambda implemented for this test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>So that we can locate this composable with our tests we’re going to need to utilise a test tag. We’ll add a new tag to our <code>Tags.kt</code> file:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_BOTTOM_NAVIGATION</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;bottom_navigation&quot;</span>
}</code></pre>

<p>Followed by assigning this tag to the <code>BottomNavigation</code> composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// BottomNavigation.kt
</span><span class="syntax-all syntax-entity">BottomNavigation</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_BOTTOM_NAVIGATION</span>))</code></pre>

<p>Using this tag we can then locate the bottom navigation node using the <code>onNodeWithTag</code> function, followed by asserting that it is being displayed using the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_BOTTOM_NAVIGATION</span>
    ).assertIsDisplayed()
}</code></pre>

<p>Now that we have asserted that the bottom navigation is being displayed, we can put together a test that will assert that the items within the bottom navigation bar are being displayed as expected. We’ll start here by creating a new test, composing the <code>BottomNavigationBar</code> as we had done in the previous test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Items_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

}</code></pre>

<p>Next, we’re going to want to take each of the navigation items that are expected to be displayed, performing assertions to ensure this is the case. We’ll first want to take the expected items which in this case are the <strong>Feed</strong>, <strong>Contacts</strong> and <strong>Calendar</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-constant">listOf</span>(
	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>, 
	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>, 
	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
)</code></pre>

<p>With these <code>Destination</code> references, we can now loop through each one and use the title of each destination to locate a node using the <code>onNodeWithText</code> function. With this node located we can then assert that this is being displayed as expected - this will then test that each of the expected navigation items is being correctly displayed inside of the bottom navigation.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Items_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    <span class="syntax-all syntax-constant">listOf</span>(
		<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>, 
		<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>, 
		<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
	).forEach {
        composeTestRule.onNodeWithText(
            it.title
        ).assertIsDisplayed()
    }
}</code></pre>

<p>While we now know that the navigation items are being displayed inside of our bottom navigation bar, we can go one step further here and assert that the expected item is being composed as a selected navigation item. We’re going to start here by again composing the <code>BottomNavigationBar</code>, providing a <code>Destination</code> reference for the currently selected item. We’ll keep this in a variable reference so that we can later use it when performing assertions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Current_Destination_Selected</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> destination,
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>With this being composed, we’re now going to want to assert the selected states of each <code>Destination</code> that is being composed inside of our bottom navigation. In the previous test, we used the title of each destination to assert that the <code>Destination</code> was being composed within the bottom navigation bar. Here we’re going to use the same approach with <code>onNodeWithText</code> to locate the given <code>Destination</code> using its title, but this time assert the selected state. </p>

<p>Using the <code>Destination</code> reference that we provided to the <code>currentDestination</code> argument during composition, we’ll locate the corresponding node for this destination and use the <code>assertIsSelected</code> function to assert that this node is marked as selected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Current_Destination_Selected</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> destination,
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithText(destination.title)
        .assertIsSelected()
}</code></pre>

<p>While we’re here, we’ll also add two more assertions for the other destinations that we know are being composed. We could have these as separate tests, but we’ll assert these here for simplicity sake. Using both the <strong>Feed</strong> and <strong>Calendar</strong> destinations, we’ll locate the corresponding nodes for these and assert that they are not marked as selected using <code>assertIsNotSelected</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Current_Destination_Selected</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> destination,
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithText(destination.title)
        .assertIsSelected()
    composeTestRule.onNodeWithText(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title)
        .assertIsNotSelected()
    composeTestRule.onNodeWithText(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.title)
        .assertIsNotSelected()
}</code></pre>

<p>Now that we know the bottom navigation is being composed as expected, we’re going to want to assert that the provided lambda function is triggered when a destination is clicked. Here we’re going to use <code>mockito</code> to provide a mock implementation of this callback - allowing us to verify that it is triggered as expected. We’ll pass in this mock implementation to the <code>onNavigate</code> argument of the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Callback_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    <span class="syntax-all syntax-keyword">val</span> onNavigate<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
        )
    }
}</code></pre>

<p>Now that this mock implementation is being provided for our composition, we can go ahead and perform the required operation that would trigger that callback. Similar to the previous test, we’ll need to locate the same node here using the <code>Destination</code> title, this time using the <code>performClick</code> function to perform an action instead of an assertion.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Callback_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    <span class="syntax-all syntax-keyword">val</span> onNavigate<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
        )
    }

    composeTestRule.onNodeWithText(
        destination.title
    ).performClick()
}</code></pre>

<p>When this icon is clicked, it would be expected that the lambda we provided would be triggered. We have a mock implementation of this callback in place, so we can use this to verify interactions. For this we’re going to utilise the mockito <code>verify</code> functionality - this allows us to assert that our callback has been triggered within the scope of our test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Callback_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    <span class="syntax-all syntax-keyword">val</span> onNavigate<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">BottomNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
        )
    }

    composeTestRule.onNodeWithText(
        destination.title
    ).performClick()

    verify(onNavigate).invoke(destination)
}</code></pre>

<p>With this in place, we’re now able to assert that the navigation icon is successfully triggering the action that has been provided via the composable function.</p>

<hr />

<h2>Testing the Rail Navigation</h2>

<p>Now that we’ve got all of the tests in place for the bottom navigation, we’re next going to move on to testing the composition of the <code>RailNavigationBar</code> composable. Here we’re going to want to write some tests that allow us to assert that:</p>

<ul>
	<li>The rail navigation bar is displayed</li>
	<li>The navigation items are displayed within the rail navigation bar</li>
	<li>The navigation callback is triggered upon item select</li>
	<li>The currently selected item is marked as selected</li>
</ul>

<p>With these test requirements in mind, we’re going to go ahead and write a new test class, <code>RailNavigationTest</code>, configuring the compose test rule in the process.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">RailNavigationTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’re going to start here by writing a test to assert that the rail navigation composable is displayed within the composed UI. We’re going to start here by writing a new test, <code>Navigation_Rail_Displayed</code>, composing a <code>RailNavigationBar</code> in the process. Here we’ll pass a <code>Destination</code>, along with an empty lambda for the <code>onCreateItem</code> and <code>onNavigate</code> lambdas - this is because we don’t need the lambdas implemented for this test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>So that we can locate this composable with our tests we’re going to need to utilise a test tag. We’ll add a new tag to our <code>Tags.kt</code> file:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_RAIL_NAVIGATION</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;rail_navigation&quot;</span>
}</code></pre>

<p>Followed by assigning this tag to the <code>RailNavigationBar</code> composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// RailNavigation.kt
</span><span class="syntax-all syntax-entity">NavigationRail</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_RAIL_NAVIGATION</span>),
	...
)</code></pre>

<p>Using this tag we can then locate the rail navigation node using the <code>onNodeWithTag</code> function, followed by asserting that it is being displayed using the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_NAVIGATION_RAIL</span>
    ).assertIsDisplayed()
}</code></pre>

<p>Now that we have asserted that the rail navigation is being displayed, we can put together a test that will assert that the items within the rail navigation bar are being displayed as expected. We’ll start here by creating a new test, composing the <code>RailNavigationBar</code> as we had done in the previous test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Items_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>Next, we’re going to want to take each of the navigation items that are expected to be displayed, performing assertions to ensure this is the case. We’ll first want to take the expected items which in this case are the <strong>Feed</strong>, <strong>Contacts</strong> and <strong>Calendar</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-constant">listOf</span>(
	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>, 
	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>, 
	<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
)</code></pre>

<p>With these <code>Destination</code> references, we can now loop through each one and use the title of each destination to locate a node using the <code>onNodeWithText</code> function. With this node located we can then assert that this is being displayed as expected - this will then test that each of the expected navigation items is being correctly displayed inside of the bottom navigation.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Items_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    <span class="syntax-all syntax-constant">listOf</span>(
		<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>, 
		<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>, 
		<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
	).forEach {
        composeTestRule.onNodeWithText(
            it.title
        ).assertIsDisplayed()
    }
}</code></pre>

<p>While we now know that the navigation items are being displayed inside of our rail navigation bar, we can go one step further here and assert that the expected item is being composed as a selected navigation item. We’re going to start here by again composing the <code>RailNavigationBar</code>, providing a <code>Destination</code> reference for the currently selected item. We’ll keep this in a variable reference so that we can later use it when performing assertions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Current_Destination_Selected</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> destination,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>With this being composed, we’re now going to want to assert the selected states of each <code>Destination</code> that is being composed inside of our bottom navigation. In the previous test, we used the title of each destination to assert that the <code>Destination</code> was being composed within the bottom navigation bar. Here we’re going to use the same approach with <code>onNodeWithText</code> to locate the given <code>Destination</code> using its title, but this time assert the selected state. </p>

<p>Using the <code>Destination</code> reference that we provided to the <code>currentDestination</code> argument during composition, we’ll locate the corresponding node for this destination and use the <code>assertIsSelected</code> function to assert that this node is marked as selected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Current_Destination_Selected</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> destination,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule
		.onNodeWithText(destination.title)
        .assertIsSelected()
}</code></pre>

<p>While we’re here, we’ll also add two more assertions for the other destinations that we know are being composed. We could have these as separate tests, but we’ll assert these here for simplicity sake. Using both the <strong>Feed</strong> and <strong>Calendar</strong> destinations, we’ll locate the corresponding nodes for these and assert that they are not marked as selected using <code>assertIsNotSelected</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Current_Destination_Selected</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> destination,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule
		.onNodeWithText(destination.title)
        .assertIsSelected()
    composeTestRule
		.onNodeWithText(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.title)
        .assertIsNotSelected()
    composeTestRule
		.onNodeWithText(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>.title)
        .assertIsNotSelected()
}</code></pre>

<p>Now that we know the rail navigation is being composed as expected, we’re going to want to assert that the provided lambda function is triggered when a destination is clicked. Here we’re going to use <code>mockito</code> to provide a mock implementation of this callback - allowing us to verify that it is triggered as expected. We’ll pass in this mock implementation to the <code>onNavigate</code> argument of the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Callback_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    <span class="syntax-all syntax-keyword">val</span> onNavigate<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
        )
    }
}</code></pre>

<p>Now that this mock implementation is being provided for our composition, we can go ahead and perform the required operation that would trigger that callback. Similar to the previous test, we’ll need to locate the same node here using the <code>Destination</code> title, this time using the <code>performClick</code> function to perform an action instead of an assertion. We’ll then use the <code>verify</code> functionality to assert that the callback is triggered when expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Callback_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    <span class="syntax-all syntax-keyword">val</span> onNavigate<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> onNavigate
        )
    }

    composeTestRule.onNodeWithText(
        destination.title
    ).performClick()

    verify(onNavigate).invoke(destination)
}</code></pre>

<p>Alongside the navigation items, the rail is also expected to contain a floating action button that is used to trigger the item creation flow. To wrap up the tests for the rail navigation bar we’re going to assert that this button is displayed and that it triggered the expected callback.</p>

<p>We’ll start here by creating a new test, <code>Floating_Action_Button_Displayed</code>, that will be used to assert that the floating action button is being displayed. Before we can do this, we’ll need to add a new tag to our <code>Tags.kt</code> file:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_RAIL_CREATE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;rail_create&quot;</span>
}</code></pre>

<p>Followed by assigning this tag to the <code>FloatingActionButton</code> composable within the rail navigation bar, using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// RailNavigation.kt
</span><span class="syntax-all syntax-entity">FloatingActionButton</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_RAIL_CREATE</span>),
	...
)</code></pre>

<p>Using this tag we can then locate the button node using the <code>onNodeWithTag</code> function, followed by asserting that it is being displayed using the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Floating_Action_Button_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> {},
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_RAIL_NAV_CREATE</span>
    ).assertIsDisplayed()
}</code></pre>

<p>Alongside this button being displayed, we’ll want to assert that the provided lambda, <code>onCreateItem</code>, is triggered when expected. Similar to the previous tests that we wrote to assert that the <code>onNavigate</code> lambda is being triggered as expected, we’ll want to go ahead and do the same here.</p>

<p>We’ll create a mock reference for the <code>onCreateItem</code> lambda and pass this when composing the <code>RailNavigationBar</code>. Then, using the tag that we defined for the last test, we’ll perform a click action on the floating action button, followed by asserting that the lambda was invoked as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Create_Item_Callback_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onCreateItem<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">RailNavigationBar</span>(
            currentDestination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>,
            onCreateItem <span class="syntax-all syntax-keyword">=</span> onCreateItem,
            onNavigate <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_RAIL_NAV_CREATE</span>
    ).performClick()

    verify(onCreateItem).invoke()
}</code></pre>

<hr />

<h2>Testing the Home Body</h2>

<p>Now that we have tests in place for the different navigation bars within our project, we’re going to explore writing some tests to assert that these components are composed as expected within the dashboard of the app when the <code>Home</code> composable is composed. Here we’ll want to assert that:</p>

<ul>
	<li>The Navigation Rail is displayed in landscape mode</li>
	<li>The Navigation Rail is not displayed in portrait mode</li>
	<li>The Navigation Rail is not shown for a non-root destination</li>
	<li>The Bottom Navigation is displayed in portrait mode</li>
	<li>The Bottom Navigation is not displayed in landscape mode</li>
	<li>The Bottom Navigation is not shown for a non-root destination</li>
</ul>

<p>With these test requirements in mind, we’re going to go ahead and write a new test class, <code>HomeTest</code>, configuring the compose test rule in the process.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">HomeTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()


}</code></pre>

<h3>Testing the Rail is displayed in Landscape</h3>

<p>We’re going to start with the first test case from above, the <code>NavigationRail</code> being displayed when the UI is composed for a landscape layout. We’ll want to start here by composing the <code>Home</code> composable, providing the <code>Configuration.ORIENTATION_LANDSCAPE</code> value for the <code>orientation</code> argument of the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Displayed_In_Landscape</span>() {
    composeTestRule.setContent {
    	<span class="syntax-all syntax-entity">Home</span>(orientation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Configuration</span>.<span class="syntax-all syntax-entity">ORIENTATION_LANDSCAPE</span>)
    }
}</code></pre>

<p>With this being composed, we can now go ahead and perform the assertion for the <code>NavigationRail</code>. Here we’ll want to use the <code>TAG_NAVIGATION_RAIL</code> tag that we previously defined to locate the desired node, followed by using the <code>assertIsDisplayed</code> function to assert that the rail is being displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Displayed_In_Landscape</span>() {
    composeTestRule.setContent {
    	<span class="syntax-all syntax-entity">Home</span>(orientation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Configuration</span>.<span class="syntax-all syntax-entity">ORIENTATION_LANDSCAPE</span>)
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_NAVIGATION_RAIL</span>
    ).assertIsDisplayed()
}</code></pre>

<h3>Testing the Rail is not displayed in Portrait</h3>

<p>Now that we know the rail is being displayed in landscape mode, we’ll want to test for the rail not being displayed when in portrait mode. For this we can simply compose the <code>Home</code> composable, relying on the default <code>orientation</code> value to enforce portrait mode. Then again using the tag for the navigation rail, we can use the <code>assertDoesNotExist</code> function to assert that the node does not currently exist in the composed UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Not_Displayed_In_Portrait</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Home</span>()
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_NAVIGATION_RAIL</span>
    ).assertDoesNotExist()
}</code></pre>

<h3>Testing the Rail is not displayed for a non-root destination</h3>

<p>Aside from the orientation being used to depict how the rail is going to be composed, the composition is also based on the current destination. When the current destination is not a root destination (as in, it is not within the <strong>Home</strong> nested graph), the navigation rail should not be composed. We’ll want to assert this through some tests, so we’ll start by writing a new test and composing <code>Home</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Not_Displayed_For_Non_Root_Destination</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Home</span>()
    }
}</code></pre>

<p>Next, we’ll use the <code>TAG_RAIL_CREATE</code> tag to perform a click action on the floating action button, triggering a navigation event to the <strong>Create</strong> graph. When this is triggered, we will not be at a root destination - so the navigation rail should not exist. Once this interaction has taken place, we can locate the rail node using the <code>TAG_NAVIGATION_RAIL</code> tag, followed by performing the assertion via the <code>assertDoesNotExist</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Navigation_Rail_Not_Displayed_For_Non_Root_Destination</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Home</span>()
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_RAIL_CREATE</span>
    ).performClick()

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_NAVIGATION_RAIL</span>
    ).assertDoesNotExist()
}</code></pre>

<h3>Testing the Bottom Navigation is displayed in Portrait</h3>

<p>Above we wrote a test to assert that the Navigation Rail is displayed when <code>Home</code> is composed in Landscape mode. On the flip side, we’re going to want to assert that the Bottom Navigation is displayed when <code>Home</code> is composed in Portrait mode. Similar to the test for the Navigation Rail, we’ll then compose <code>Home</code>, followed by using the <code>TAG_BOTTOM_NAVIGATION</code> tag to locate the desired node and assert that it is displayed using the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Displayed_In_Portrait</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Home</span>()
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_BOTTOM_NAVIGATION</span>)
        .assertIsDisplayed()
}</code></pre>

<h3>Testing the Bottom Navigation is not displayed in Landscape</h3>

<p>While we want the Bottom Navigation to be composed in Portrait mode, we don’t want it to be composed in Landscape mode. This time we’ll compose <code>Home</code> and pass in the <code>Configuration.ORIENTATION_LANDSCAPE</code> value for the <code>orientation</code> argument, followed by using the <code>assertDoesNotExist</code> function to assert that the Bottom Navigation has not been composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigation_Not_Displayed_In_Landscape</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Home</span>(orientation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Configuration</span>.<span class="syntax-all syntax-entity">ORIENTATION_LANDSCAPE</span>)
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_BOTTOM_NAVIGATION</span>)
        .assertDoesNotExist()
}</code></pre>

<h3>Testing the Bottom Navigation is not displayed for a non-root destination</h3>

<p>Aside from the orientation being used to depict how the Bottom Navigation is going to be composed, the composition is also based on the current destination. When the current destination is not a root destination (as in, it is not within the <strong>Home</strong> nested graph), the Bottom Navigation should not be composed. We’ll want to assert this through some tests, so we’ll start by writing a new test and composing <code>Home</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigtion_Not_Displayed_For_Non_Root_Destination</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Home</span>()
    }
}</code></pre>

<p>Next, we’ll use the <code>TAG_RAIL_CREATE</code> tag to perform a click action on the floating action button, triggering a navigation event to the <strong>Create</strong> graph. When this is triggered, we will not be at a root destination - so the Bottom Navigation should not exist. Once this interaction has taken place, we can locate the rail node using the <code>TAG_BOTTOM_NAVIGATION</code> tag, followed by performing the assertion via the <code>assertDoesNotExist</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Bottom_Navigtion_Not_Displayed_For_Non_Root_Destination</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Home</span>()
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_RAIL_CREATE</span>
    ).performClick()

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_BOTTOM_NAVIGATION</span>)
        .assertDoesNotExist()
}</code></pre>

<hr />

<h2>Testing the Content Area</h2>

<p>Now that we have tests in place for the composable that houses the content of the dashboard, we’re going to write some tests for the <code>ContentArea</code> composable that is used to show content in the content area of the dashboard. We’ll start by creating a new test class, <code>ContentAreaTest</code>, configuring the test rule within this.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ContentAreaTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<h3>Testing the composed destination</h3>

<p>For the first test, we’re going to want to assert that the expected <code>Destination</code> is composed within the <code>ContentArea</code>. When composing the <code>ContentArea</code>, the <code>Destination</code> is passed to it so that the content for the composable can be set. We’ll want to start here by composing the <code>ContentArea</code> for our test, followed by passing the <code>Destination.Feed</code>. We’ll store this <code>Destination</code> reference as a variable so that we can use it in the next steps of the test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Destination_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> destination)
    }
}</code></pre>

<p>Now that the <code>ContentArea</code> is being composed, we’ll next want to assert the content that is being composed. To do this, we’re going to set a tag on the parent container within the composable. For this we can use the <code>path</code> of the <code>Destination</code> that is passed to the <code>ContentArea</code>, using the <code>testTag</code> function to set this tag on the <code>Column</code> container.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ContentArea.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ContentArea</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(destination.path),
		...
	)
	...
}</code></pre>

<p>With this in place, we can now use the <code>onNodeWithTag</code> function to locate the node using the <code>path</code> of our <code>Destination.Feed</code> reference, followed by using the <code>assertIsDisplayed</code> function to assert that the composable is currently being displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Destination_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> destination)
    }
    composeTestRule.onNodeWithTag(
        destination.path
    ).assertIsDisplayed()
}</code></pre>

<h3>Testing the destination title</h3>

<p>Now that we know the expected destination is being composed within the <code>ContentArea</code>, we’re going to go ahead and perform some checks on the various composables that are contained within the parent <code>ContentArea</code>. We’ll start by asserting the expected title is being displayed - for this, we’ll need to write a new test, <code>Content_Title_Displayed</code>, composing the <code>ContentArea</code> with a specified <code>Destination</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> destination)
    }
}</code></pre>

<p>So that we can locate this composable with our tests we’re going to need to utilise a test tag. We’ll add a new tag to our <code>Tags.kt</code> file:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CONTENT_TITLE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;content_title&quot;</span>
}</code></pre>

<p>Followed by assigning this tag to the title within <code>ContentArea</code> composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Content.kt
</span><span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_CONTENT_TITLE</span>),
	...
)</code></pre>

<p>With this tag in place, we can now locate the node for the title, using the <code>assertTextEquals</code> function to perform the assertion for the title of the provided <code>Destination</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> destination)
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_CONTENT_TITLE</span>
    ).assertTextEquals(destination.title)
}</code></pre>

<h3>Testing the destination icon</h3>

<p>With the title being asserted, we’re going to wrap up the tests for the <code>ContentArea</code> by asserting that the expected icon is being composed. So that we can check the icon within our tests, we’re going to need to add another tag that can be used in our tests.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CONTENT_ICON</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;content_icon&quot;</span>
}</code></pre>

<p>We’ll then assign this tag to the <code>Icon</code> composable, using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Content.kt
</span><span class="syntax-all syntax-entity">Icon</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">80</span>.dp).testTag(<span class="syntax-all syntax-entity">TAG_CONTENT_ICON</span>),
	...
)</code></pre>

<p>With this tag in place, we can now locate the node using the <code>TAG_CONTENT_ICON</code> tag. Within our composable, we’re assigning the <code>title</code> of the provided <code>Destination</code> as the content description for the <code>Icon</code> composable. To assert the <code>Icon</code> is being composed as expected for the given <code>Destination</code>, we’ll utilise the <code>assertContentDescriptionEquals</code> function to assert that the expected content description is being set based on the <code>Destination</code> that is provided to the <code>ContentArea</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Icon_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> destination <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ContentArea</span>(destination <span class="syntax-all syntax-keyword">=</span> destination)
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_CONTENT_ICON</span>
    ).assertContentDescriptionEquals(destination.title)
}</code></pre>

<hr />

<h2>Testing the Composable Navigation</h2>

<p>Now that we have tests for most of the UI components within our screen, we’re going to write some tests to assert that our navigation graphs are working as expected. This means that we can assert the expected destinations are navigated to when certain actions are triggered within our UI. We’ll start by creating a new test class, <code>NavigationTest</code>, configuring the test rule within this.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NavigationTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’re going to start here by performing an assertion that the <code>Feed</code> <code>Destination</code> is displayed by default, as this is the start destination within our navigation graph. Here we’re going to need to start by composing the <code>Navigation</code> composable, providing the required <code>NavHostController</code> reference when doing so. At this point, the <code>Destination.Feed</code> should be loaded as the current destination of the graph. We previously configured the <code>ContentArea</code> composable to use the <code>path</code> of the given <code>Destination</code> as the test tag, so we’ll use the <code>onNodeWithTag</code> function to retrieve the node using the destination <code>path</code>. We can then use the <code>assertIsDisplayed</code> function to assert that this composable is being displayed, which if satisfied will mean that the <code>Destination.Feed</code> has been loaded and is the current destination of the graph.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Feed_Displayed_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Navigation</span>(
            navController <span class="syntax-all syntax-keyword">=</span> rememberNavController()
        )
    }

	composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Feed</span>.path)
		.assertIsDisplayed()
}</code></pre>

<p>We’re now going to want to test that the expected <code>Destination</code> is navigated to when the corresponding navigation is triggered via the use of the <code>path</code>. There are 5 other destinations that we want to test are navigated to as expected, so we’re going to create a helper function that will be used to execute all of the required logic for these tests.</p>

<p>In this <code>assertNavigation</code> function, we’re going to want to compose the same <code>Navigation</code> composable as in the previous test. However, we’re going to need to accept a <code>Destination</code> argument for the function, this will be used to trigger a navigation event using the <code>path</code> of that provided <code>Destination</code>. After this composition, we’ll then want to perform the same check as previously defined, using the <code>path</code> of the destination to locate a node, followed by asserting that the node is being displayed. Most of this logic is the same as the initial test that we wrote above, with the difference of the <code>Destination</code> being provided to trigger the <code>navigate</code> function on the controller reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">assertNavigation</span>(<span class="syntax-all syntax-parameter">destination</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Destination</span>) {
	composeTestRule.setContent {
		<span class="syntax-all syntax-keyword">val</span> navController <span class="syntax-all syntax-keyword">=</span> rememberNavController()
		<span class="syntax-all syntax-entity">Navigation</span>(navController <span class="syntax-all syntax-keyword">=</span> navController)
		navController.navigate(destination.path)
	}
    composeTestRule.onNodeWithTag(destination.path)
        .assertIsDisplayed()
}</code></pre>

<p>With this function in place, we can now put together a test for each of the destinations that are implemented within our graph. Within each of these tests, we can simply call our <code>assertNavigation</code> function, passing the <code>Destination</code> that we’re wishing to test the navigation for.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Contacts_Displayed</span>() {
    assertNavigation(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Contacts</span>)
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Calendar_Displayed</span>() {
    assertNavigation(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Calendar</span>)
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Create_Displayed</span>() {
    assertNavigation(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Add</span>)
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Upgrade_Displayed</span>() {
    assertNavigation(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Upgrade</span>)
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Settings_Displayed</span>() {
    assertNavigation(<span class="syntax-all syntax-entity">Destination</span>.<span class="syntax-all syntax-entity">Settings</span>)
}</code></pre>

<hr />

<p>With all of these tests in place, we’ve covered a lot of different cases that help to ensure our UI is working as expected. We’ve not only tested that composables are being composed based on the information that they are provided with, but also that they triggered the expected callbacks and trigger state manipulations within our composables. While the tests here aren’t extensive, we’ve been able to learn not only what options are available to us while testing composables, but also the approaches that we can take when doing so.</p>

<h1>Building an Email Inbox</h1>

<p>A common theme for mobile apps is some form of content feed, quite often a list that displays a list of items to the user. These types of UI will usually be made up of a single UI component (or even a variation of UI components) repeated multiple times, each representing the piece of content that they are assigned to display information on. These UI components in the feed may represent things such as a social media update, a track from an album, an email in your inbox or a person in your contact list.</p>

<p>With this in mind, we’re going to build out a screen displaying a content feed using jetpack compose - for this we will replicate a minimal email inbox. Building this will give us a chance to build a common UI pattern in mobile development, while also diving into more of the available functionality from the Compose framework.</p>

<figure><img src="11-3.png"/></figure>

<p>At a first glance, an email inbox doesn’t feel like there is too much going on - we have a parent container that needs to display a list of email UI components. Outside of displaying that list, we need to also configure the rest of the state for that screen. This state will allow us to depict the type of UI that we are displaying to the user - whether it is a list of content items, an empty state or an error state. Once those items are in place we can then start to explore some extended functionality for our list - such as performing actions on those items using buttons and swipe actions. So when it comes to this screen, we need to configure and handle several different things.</p>

<ul>
	<li>Build out the state for our screen that represents the items that make up that list</li>
	<li>Create a view model that will be used to orchestrate data to and from the UI</li>
	<li>Build the UI component for the individual email inbox items</li>
	<li>Build the UI for the parent of the content items</li>
	<li>Handle the state when the inbox is loading</li>
	<li>Handle the state when the inbox is empty</li>
	<li>Handle the state when the inbox fails to load</li>
	<li>Provide support for the list to be manually refreshed by the user</li>
	<li>Provide support for the user to delete email items via a swipe-to-dismiss gesture</li>
</ul>

<figure><img src="intro-3.png"/></figure>

<h1>Defining the Inbox State</h1>

<p>Within our inbox, we’re going to be displaying a list of email items - each item will represent the same email UI component but have data that is specific to that instance of an item. Each one of these items will then be used to represent an email within our inbox, containing just the data that is required to display details on that email within the inbox. With this in mind, our inbox state is going to be made up of:</p>

<ul>
	<li>A list of items that represent that emails within the inbox

		<ul>
			<li>Each of these items will then consist of a title and message preview</li>
		</ul></li>
	<li>The current state of the screen. For example, is the screen currently loading.</li>
</ul>

<p>With the above pieces, we can see that there is not too much separate state that we need to think about - we can break this down into either there being a feed of content, a loading state, or a no-content state. Let’s start to take the above requirements and build out a class that will represent the state of our composable UI. We’ll start by creating a new class to hold the state of our screen:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">//InboxState.kt
</span><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxState</span>(

)</code></pre>

<hr />

<h2>Defining the Inbox Status</h2>

<p>As mentioned above, we’re going to need to handle a collection of states that the screen can represent. To simplify our state model, we’re going to create a new enum that will indicate a higher-level state that our screen is in. While we could use boolean flags for this, having this typed state reduces the complexity of our state model, keeping it simpler to understand. We’ll create this enum class with the name of InboxStatus:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxStatus</span> {
  <span class="syntax-all syntax-entity">LOADING</span>, <span class="syntax-all syntax-entity">HAS_EMAILS</span>, <span class="syntax-all syntax-entity">ERROR</span>, <span class="syntax-all syntax-entity">EMPTY</span>
}</code></pre>

<p>Here we can see four different states that our inbox can be in:</p>

<ul>
	<li><strong>Loading</strong>: The inbox is currently loading the list of emails</li>
	<li><strong> Has Emails</strong>: The inbox has loaded a list of emails</li>
	<li><strong>Error</strong>: There has been an error while loading the list of emails</li>
	<li><strong>Empty</strong>: The inbox is empty and there are no emails to display</li>
</ul>

<p>With these different InboxStatus values in place, we can go ahead and add a status property to our InboxState class - this allows the high-level state of our inbox to be represented by a single field. We’ll set the default value of this to <strong>LOADING</strong>, so that when our screen is initialised the loading state is displayed by default.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxState</span>(
  <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">status</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>
)</code></pre>

<hr />

<h2>Defining the Email item</h2>

<p>With this status in place, we can start thinking about the second part of our state - the lower level piece of our screen in the form of the email list. When it comes to this list of emails to be displayed on our screen, we’re going to need to represent this in our state using a list of models that hold the details for each of those emails. For this we’ll create a new class, <code>Email</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Email</span>(
  <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
  <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
  <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">description</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)</code></pre>

<p>Here we can see three different pieces of information that are to be represented within each of the email items.</p>

<ul>
	<li><strong>id</strong>: The unique identifier used to represent an email</li>
	<li><strong>title</strong>: The title of the email message</li>
	<li><strong>description</strong>: The description that represents a portion of the email content</li>
</ul>

<p>This class will represent an email within our Inbox, holding the various properties which can be used to display information within each of our email UI components. With this model in place, we can then go ahead and modify our InboxState so that our email inbox is reflected here. We’ll do this by defining a content property that represents a list of these Email models.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxState</span>(
  <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">status</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>,
  <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">content</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Email</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>With this in place, we now have the required data that can be used to make up the state of our screen.</p>

<hr />

<h1>Creating the Inbox ViewModel</h1>

<p>Now that we have the state modelled for our Inbox, we can start thinking about the ViewModel that will be used to manage this state and provide a way to orchestrate information to the user interface. </p>

<hr />

<h2>Setting up the ViewModel</h2>

<p>Before we can get started here, we’re going to add a new dependency to our project that will give us access to the Android Lifecycle ViewModel class:</p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span></code></pre>

<p>💡 You aren’t required to use a ViewModel when working with compose. For the sake of these exercises, it helps us to keep things simple and follow an approach that many developers are familiar with.</p>

<p>We’ll begin by creating a new ViewModel, called <code>InboxViewModel</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// InboxViewModel.kt
</span><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

}</code></pre>

<p>This <code>ViewModel</code> is going to need to hold a reference to the state of our screen. For this we’re going to utilise <code>StateFlow</code> - this allows us to create a state-holder observable flow that will emit the default state we provide to it, along with any updates that occur during its lifetime. Here we’ll create a new <code>MutableStateFlow</code> instance, providing a reference to our <code>InboxState</code> class as the default value for our <code>StateFlow</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {
	<span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">InboxState</span>())
}</code></pre>

<p>With this in place, we now have a <code>StateFlow</code> reference that is holding a reference to our <code>InboxState</code>, initialising it with a new instance of the state class and relying on the defaults that the constructor provides.</p>

<hr />

<h2>Loading the Inbox Data</h2>

<p>Because we’re not working with real data for our screen, we’re going to start by building a Factory class that will be used to create a list of mock Emails for our Inbox. It would be possible for us to create some way of generating random information - but for simplicity sake, we’re going to create a simple <code>makeEmailList</code> function that will provide us with a list of <code>Email</code> instances.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> EmailFactory {

  <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeEmailList</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Email</span>&gt; {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
      <span class="syntax-all syntax-entity">Email</span>(
        <span class="syntax-all syntax-string">&quot;1&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Did you get my email?&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Hey, I just wanted to check that you got my last email    
</span><span class="syntax-all syntax-string">        - I know you&#39;re pretty busy these days!&quot;</span>
      ),
      <span class="syntax-all syntax-entity">Email</span>(
        <span class="syntax-all syntax-string">&quot;2&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Welcome!&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Thanks for signing up to our mailing list. You&#39;ll need  
</span><span class="syntax-all syntax-string">        to confirm your email address to receive future 
</span><span class="syntax-all syntax-string">        emails from us.&quot;</span>
      ),
      <span class="syntax-all syntax-entity">Email</span>(
        <span class="syntax-all syntax-string">&quot;3&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Thanks for your order!&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Your order is on its way! Keep an eye on its progress 
</span><span class="syntax-all syntax-string">        using our tracking system.&quot;</span>
      ),
      <span class="syntax-all syntax-entity">Email</span>(
        <span class="syntax-all syntax-string">&quot;4&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Join our team? :)&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Thanks for spending the time to interview with us over 
</span><span class="syntax-all syntax-string">        the last few weeks - we&#39;d love to invite you to join 
</span><span class="syntax-all syntax-string">        our team!&quot;</span>
      ),
      <span class="syntax-all syntax-entity">Email</span>(
        <span class="syntax-all syntax-string">&quot;5&quot;</span>,
        <span class="syntax-all syntax-string">&quot;RE: Coffee&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Was great to bump into your last week - I&#39;d love to  
</span><span class="syntax-all syntax-string">        catch-up properly, maybe we could meet at the weekend? 
</span><span class="syntax-all syntax-string">        There&#39;s a lovely new coffee bar on my street!&quot;</span>
      ),
      <span class="syntax-all syntax-entity">Email</span>(
        <span class="syntax-all syntax-string">&quot;6&quot;</span>,
        <span class="syntax-all syntax-string">&quot;You didn&#39;t win this time&quot;</span>,
        <span class="syntax-all syntax-string">&quot;Thanks for entering our competition. Unfortunately you 
</span><span class="syntax-all syntax-string">        didn&#39;t win this time! Please try again soon, you might    
</span><span class="syntax-all syntax-string">        have better luck in future :)&quot;</span>
      )
    )
  }
}</code></pre>

<p>With this sample data in place, we now have some instances of the <code>Email</code> class which can be used to display content for our Inbox. To get this data into our state, we’ll need to create a new function inside of our ViewModel which will simulate the loading of our Inbox content. We’ll start here by creating a new function called <code>loadContent</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// InboxViewModel.kt
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">loadContent</span>() {
  
}</code></pre>

<p>With this function in place, we’re going to want to simulate what would happen if this function was going to be triggering an asynchronous request (e.g making a request to an API to retrieve the Inbox data). For this reason, we’re going to want to display the loading state inside of our Inbox UI. We’ll do this by updating our state to reflect that it should currently be represented as loading.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">loadContent</span>() {
	uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>
	)
}</code></pre>

<p>Now that we are emitting a loading state, we can now we can go ahead and utilise our email factory to create the list of content for our inbox, emitting it as the content property within our InboxState. At the same time, we’ll switch our inbox status from Loading to Success, indicating that we are no longer in a state of loading content and the UI can reflect that we have successfully loaded the required data.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">loadContent</span>() {
	uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>
	)
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">SUCCESS</span>,
		emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
	)
}</code></pre>

<p>💡 While this loading state will be replaced almost instantly, this mimics what we would expect to see in a real data loading scenario.</p>

<hr />

<h2>Handling State Events</h2>

<p>From our inbox, there are going to be a collection of user-triggered events, and when these occur we’re going to need to handle them inside of our ViewModel so that the state can be updated accordingly. With these handled by our ViewModel, this allows us to have a single way of our composable UI communicating with the ViewModel, rather than needing to pass the entire ViewModel or many references to separate functions which could be used to trigger state changes. Instead, we can pass a single function reference to our composable UI which can then be used to trigger these events in the ViewModel. For these events we’re going to need to define different types that can be triggered, so we’ll go ahead and create a new sealed class to represent these.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxEvent</span> {

}</code></pre>

<p>With this sealed class in place, we can start to think about using it to represent the different events that can occur. We’re going to start by handling the scenario where the user might trigger a refresh of the screen (for example, when the inbox is displayed as empty). For this, we’ll create a new event called <strong>RefreshContent</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>()

}</code></pre>

<p>With this event in place, this can now be triggered from our composable UI to cause a state change within our view model. For that to happen though, we need to write this logic inside of our ViewModel. For this we’ll add a <code>handleEvent</code> function to our ViewModel, taking an instance of the <strong>ContentEvent</strong> type as an argument. This function can then be called whenever an event is triggered and needs to be handled.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ContentEvent</span>) {
  <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
    
  }
}</code></pre>

<p>Within this function, we have a when block in place that will allow us to individually handle any triggered <strong>ContentEvent</strong> types. Within this block, we’ll want to handle the RefreshContent event type and when that occurs, we’ll need to reload the content of the Inbox using the previously created <code>loadContent</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ContentEvent</span>) {
  <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
    <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">RefreshContent</span> <span class="syntax-all syntax-keyword">-&gt;</span> loadContent()
  }
}</code></pre>

<p>Other than refreshing the content of the Inbox, the only thing that we need to support is the ability to delete an email via the swipe-to-delete gesture. When this action is performed we’ll want to trigger a corresponding event, so we’ll create another <strong>ContentEvent</strong> type called <strong>DeleteContent</strong>. This type will need to take an argument that represents the ID of the email to be deleted, this can then be used to remove the corresponding email item from the inbox state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InboxEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">DeleteEmail</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>()

}</code></pre>

<p>At this point, we’re able to trigger this event, but it’s not being handled yet by our ViewModel. We’ll need to start here by creating some logic that will remove the email with the given ID from our list of emails. In a real app, we’d be hitting an API here, but because we’re dealing with our mock data we’ll simply remove the email from the list and have this reflected in our Inbox state. Here we’ll create a new function, <code>deleteEmail</code>, passing in the email ID. Within this, we’ll filter out any emails with that ID from our list and then assign this list to the state of our Inbox.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">deleteEmail</span>(<span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) {
  uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.build {
    content <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">this</span>.content?.filter { 
      it.id <span class="syntax-all syntax-keyword">!=</span> id
    }
  }
}</code></pre>

<p>When this function is called with the ID of the mail to remove, our state will be updated to reflect the new Inbox without the deleted email. And now that we have this function implemented, we can go ahead and adjust our handleEvent function so that this <code>deleteEmail</code> function is called when an <strong>DeleteEmail</strong> event is triggered.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ContentEvent</span>) {
  <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
    <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">RefreshContent</span> <span class="syntax-all syntax-keyword">-&gt;</span> loadContent()
   	<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">DeleteEmail</span> <span class="syntax-all syntax-keyword">-&gt;</span> deleteEmail(inboxEvent.id)
  }
}</code></pre>

<p>With this final addition in place, our ViewModel is now capable of handling these two different event types. This allows our user to trigger the refreshing and deletion of content while interacting with our composable UI.</p>

<h1>Creating the Inbox UI</h1>

<p>With the view model and state management all in place, we’re ready to move on and start implementing the composable UI for our Inbox. Using the <code>InboxState</code> that we defined in the previous sections, we’ll compose a User Interface that represents the current state of our screen. This state will then be manipulated through the <code>InboxViewModel</code>.</p>

<figure><img src="11-4.png"/></figure>

<p>This UI will give our users a screen displaying the Inbox for a mock email account - alongside displaying a list of emails, the UI will provide the ability to delete emails via swipe gestures. While building this UI we’ll dive into the specifics of how various composables can be configured and used, along with adding some nice touches to improve the User Experience of our Email Inbox in the form of Accessibility and Animations.</p>

<hr />

<h2>Setting up the entry point</h2>

<p>Before we can get start building our project, we’re going to need to add a couple of dependencies that we’re going to need. We’ll start here by adding these to the <code>build.gradle</code> file for our new project:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// provides access to the `ComponentActivity` class that can be used to compose UI components
</span>implementation &#39;androidx.activity<span class="syntax-all syntax-keyword">:</span>activity<span class="syntax-all syntax-keyword">-</span>compose<span class="syntax-all syntax-keyword">:</span><span class="syntax-all syntax-constant">1.4</span>.<span class="syntax-all syntax-constant">0</span>&#39;

<span class="syntax-all syntax-comment">// foundational classes from the Compose APIs
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.foundation:foundation:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// UI components from the Compose APIs
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Material Design components from the Compose APIs
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Provides an extended collection of Material Iconography
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material-icons-extended:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Tooling functionality for Composables, such as previews
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-tooling-preview:$compose_version&quot;</span>
debugImplementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-tooling:$compose_version&quot;</span></code></pre>

<p>The current release of this book is building against 1.1.0 of compose - be sure to check compatibly if using a newer version.</p>

<p>With these added to our project, we’re now ready to start building out our UI. We’re going to start here by building the access point to our feature - this is how the messaging feature will initially be composed within our user interface. </p>

<p>Here we’ll begin by building a root composable function, <code>Inbox</code> that will be used to house all of our Composable UI for the Email Inbox screen. For this, we’ll create a new Kotlin file called <code>Inbox.kt</code> (to keep our composables nicely organised), followed by creating a new composable function, <code>Inbox</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Inbox.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox</span>() { }</code></pre>

<p>This composable is going to be the entry point to our Email Inbox screen - so we don’t want this function to have to take any arguments. The point that is navigating to the inbox will be able to just compose this function, and this composable will handle everything else. While you won’t see anything visual just yet, you’ll want to compose this <code>Inbox</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Inbox</code> when running the project.</p>

<p>Within this root level composable we’re going to want to force our application theme on the composables that are contained inside of it, so we’ll add a <code>MaterialTheme</code> composable declaration here.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        
    }
}</code></pre>

<p>💡Wrapping your composable hierarchy in a theme allows all components to be consistently styled. In most cases, this can happen at the highest point of composition - even within the setContent function of the parent activity that is composing the UI.</p>

<p>This now means that for any of the composables that are composed in the content block of our <code>MaterialTheme</code>, these will be themed according to the colors and styles that are declared within our theme.</p>

<p>Saying that though, we don’t currently have any composables that are going to make up the content of our email inbox. We’ll go ahead and create a new composable function here, <code>EmailInbox</code>. The difference here is that this composable is going to be responsible for composing our UI based on the state of the screen, meaning that this function <strong>is</strong> going to take some form of argument. Because it’s composing UI based on our state, it’s also going to need to propagate any events so that the state can be updated accordingly. For this reason, it’s also going to need to be able to handle the <code>InboxEvent</code> types that we previously defined. We’ll need to define two additional arguments for our composable to satisfy these requirements.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// EmailInbox.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInbox</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">inboxState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxState</span>,
    <span class="syntax-all syntax-parameter">inboxEventListener</span><span class="syntax-all syntax-keyword">:</span> (inboxEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {

}</code></pre>

<p>💡 It’s good practice to allow a modifier to be passed into a composable, this means that the parent who is composing the child can control the composition to some extent. This also helps to keep your composable functions re-usable across your UI.</p>

<p>This composable will take an <code>InboxState</code> that represents the state of our screen, along with an event handler that allows us to pass up <code>InboxState</code> instances when they are triggered.</p>

<p>So, why can’t this just be the entry point to our email inbox screen? One clear thing here is that this decouples the composable with being concerned about how the state is provided - passing in the state via an argument makes it simpler, as in, it gets passed a state and composes UI based on it. This also makes it much easier to write tests our composable - because we can simply pass it a state object and perform assertions based on that, rather than needing to simulate user actions and perform mocking to produce expected states.</p>

<p>With this composable defined, we can then hop up to the root <code>Inbox</code> that we defined and compose the <code>EmailInbox</code> within our theme block.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">EmailInbox</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            inboxState <span class="syntax-all syntax-keyword">=</span> ...,
            handleEvent <span class="syntax-all syntax-keyword">=</span> ...
        )
    }
}</code></pre>

<p>Things aren’t quite satisfied here yet though, we need to provide both the state and event handler to our <code>EmailInbox</code>. We’ll be using our <code>InboxViewModel</code> that we created in the previous sections to satisfy these arguments, so we’ll first need to retrieve an instance of this. So that we can access this information, we’re going to need to obtain an instance to this ViewModel inside of our composable. Here we’ll use the <code>viewModel</code> function from the <code>lifecycle-viewmodel-compose</code> package. This will retrieve an instance of the desired ViewModel, creating one if it does not currently exist. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()</code></pre>

<p>We can then use this ViewModel within our root composable for our required arguments.</p>

<ul>
	<li>We’ll use <code>collectAsState()</code> to collect the emissions of our <code>StateFlow</code> reference from our ViewModel as composable state. We’ll then pass the value of this emission as the state reference to our composable.</li>
	<li>For event handling, our ViewModel contains a function that matches the requirements of our lambda function argument. We can pass this function reference directly to our composable using <code>viewModel::handleEvent</code>.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">EmailInbox</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            inboxState <span class="syntax-all syntax-keyword">=</span> viewModel.uiState
				.collectAsState().value,
            handleEvent <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::handleEvent
        )
    }
}</code></pre>

<p>As a final tweak, we’re going to want to ensure that the email inbox content is loaded upon the initial composition. Here we’ll use the <code>LaunchedEffect</code> side-effect - this is a block of code that will only be run based on the key that is provided to it (so if the key changes, the block will be re-run). In our case we can simply provide a <code>Unit</code> as the key, meaning that the block will only be run on the initial composition. This means that the <code>loadContent</code> function will only be run on the initial composition of our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">EmailInbox</span>(
            inboxState <span class="syntax-all syntax-keyword">=</span> viewModel.uiState.collectAsState().value,
            handleEvent <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::handleEvent
        )
    }
    <span class="syntax-all syntax-entity">LaunchedEffect</span>(<span class="syntax-all syntax-constant">Unit</span>) {
        viewModel.loadContent()
    }
}</code></pre>

<p>With this in place, we have a composable function that will house the composables making up our email inbox UI. When we initially created the <code>InboxState</code> class we only actually built it out using two different properties - a high-level state of the screen, along with a list of emails to display in the inbox. While there are only two properties here, the different types represented by that high-level state each compose a different piece of UI. Alongside the general structure of our composable UI for the Inbox, there are going to be a few different pieces that will be used to compose what we need here:</p>

<figure><img src="intro-4.png"/></figure>

<p>With the above in mind, we can start building out a collection of composable functions to build out the Composable UI representing our Inbox.</p>

<hr />

<h2>Defining the Screen Scaffold</h2>

<figure><img src="Intro2.png"/></figure>

<p>Because of the defined layout for our screen, we have two clear sections of our UI - the title and content areas. With this in mind, this is a great use case for the Scaffold composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// EmailInbox.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailInbox</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">inboxState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxState</span>,
    <span class="syntax-all syntax-parameter">inboxEventListener</span><span class="syntax-all syntax-keyword">:</span> (inboxEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-entity">Scaffold</span>(
		<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> modifier
	) {

	}
}</code></pre>

<hr />

<h2>Creating the Top App Bar</h2>

<figure><img src="2-17.png"/></figure>

<p>We’re going to start by creating the title area for our composable UI, this will be represented by a TopAppBar composable. This will be provided as the argument for the topBar property of the Scaffold composable. For our TopAppBar, we’re going to override a couple of the default properties.</p>

<p>We want the background color of the bar to be the same as the surface color of our application, this is so that it matches the background color of our inbox area. To blend these two elements even further, we’ll go ahead and remove the elevation of the TopAppBar by setting this property to 0dp.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// emailInbox.kt
</span><span class="syntax-all syntax-entity">Scaffold</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> modifier,
	topBar <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>(
	  		backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
	  		elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>.dp
		)
  	}
)</code></pre>

<p>At this point, we have a TopAppBar that is themed to the surface color of our application, without any kind of floating appearance due to the removed elevation. However, our TopAppBar is not currently displaying any content on the screen to the user. Next, we’ll go ahead and add a title to our TopAppBar, utilising the Text composable to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> modifier,
  	topBar <span class="syntax-all syntax-keyword">=</span> {
		..
		<span class="syntax-all syntax-entity">Text</span>(
  			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    		.fillMaxWidth()
    		.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp),
  		fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>,
  		textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>,
  		text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.title_inbox, 
			inboxState.emails.count()
  		)
)</code></pre>

<p>For our Text composable we’ve styled e a couple of different things:</p>

<ul>
	<li>We’ll want the title to be displayed in the center of the TopAppBar. To achieve this we use the <code>fillMaxWidth()</code> modifier, along with setting the textAlign property to <code>TextAlign.Center</code>.</li>
	<li>So that our title stands out a bit more, we’ve set the fontWeight to <code>FontWeight.Bold</code>.</li>
	<li>We assign a title to the TopAppBar using a string resource defined in our project.</li>
</ul>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;title_inbox&quot;</span>&gt;Inbox (%s)&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Using the stringResource function we also provide a value to replace the <code>%s</code> declaration in our string resource. This represents the count for the number of emails in the user inbox.</p>

<p>With this Text composable in place, we can now assign this to the title argument of our Scaffold.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> modifier,
	topBar <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-entity">TopAppBar</span>(
	  		backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
	  		elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>.dp,
	  		title <span class="syntax-all syntax-keyword">=</span> {
        		<span class="syntax-all syntax-entity">Text</span>(
          			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            			.fillMaxWidth()
            			.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp),
          			fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>,
          			textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>,
          			text <span class="syntax-all syntax-keyword">=</span> stringResource(
						id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.title_inbox, 
						inboxState.emails.count()
		  			)
        		)
      		}
		)
  	}
)</code></pre>

<p>With this title in place, we will now have a title displayed at the top of our scaffold - representing the heading for our screen, and a currently empty content area.</p>

<figure><img src="p.png"/></figure>

<hr />

<h2>Setting up the Content Area</h2>

<figure><img src="3-14.png"/></figure>

<p>With our title in place, we can now move on to displaying some composables inside of the content area for our Inbox scaffold. Within this content area, we are going to be working with several different states - loading, error, empty and the email collection itself. Each of these states is going to be represented by single composable functions, which we’ll want to house in some form of parent container. For this container, we’ll go ahead and use the <code>Box</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> modifier,
 	topAppBar <span class="syntax-all syntax-keyword">=</span> ...
) {
  	<span class="syntax-all syntax-entity">Box</span> {
	
  	}
}</code></pre>

<p>By default, the Box will wrap the size of its children, aligning them at the top/start of itself. We want all of these children composable to represent the full content area of our scaffold, giving us the full-screen estate for each of these children and allowing them to handle their alignment within that available space. We’ll go ahead and use the <code>fillMaxSize()</code> modifier to allow the Box to fill the entire available content area of our Scaffold, along with setting the <code>contentAlignment</code> to <code>Alignment.Center</code> - that way any children who do not fill the entire box will be position in the center of the container.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Scaffold</span>(
  topAppBar <span class="syntax-all syntax-keyword">=</span> ...
) {
  <span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
	contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
  ) {

  }
}</code></pre>

<hr />

<h2>Handling the loading state</h2>

<figure><img src="4-10.png"/></figure>

<p>At this point we have an empty Box composable, acting as the container for the content of our Inbox. We’re going to start populating this by first satisfying the loading state of our Inbox, creating a new composable function to hold a reference to a <code>CircularProgressIndicator</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// loading.kt
</span><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Loading</span>() {
    <span class="syntax-all syntax-entity">CircularProgressIndicator</span>()
}</code></pre>

<p>The <code>CircularProgressIndicator</code> will compose an indeterminate circular progress, resulting in a spinning indicator that will spin for the entirety of its composition within our UI. </p>

<figure><img src="prog.png"/></figure>

<p>We’ll want to show this when the status of our inbox state represents the <code>InboxStatus.LOADING</code> that we defined in the previous section of this chapter. To handle this, we’ll go ahead and add a check for this within our box.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	...
) {
	<span class="syntax-all syntax-keyword">if</span> (inboxState.status <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>) {
	  <span class="syntax-all syntax-entity">Loading</span>()
	}
}</code></pre>

<p>Because our UI is being recomposed whenever our InboxState reference changes, we can now use the <code>status</code> flag to compose our <code>Loading</code> composable whenever this flag represents the <code>InboxStatus.LOADING</code> state.</p>

<figure><img src="load.png"/></figure>

<hr />

<h2>Handling the error state</h2>

<figure><img src="5-8.png"/></figure>

<p>Now that we have a loading indicator displaying within our UI, we’re going to want to handle some of the different cases that could occur within our state. One of these states is going to be that something didn’t go quite right while our inbox was being loaded, and in these cases, we’re going to want to portray this error to the user. For this, we’re going to create a new composable to represent this error state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ErrorState</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {

}</code></pre>

<p>Within this composable we’re going to compose two children - one will represent a message to display to the user, with the other being a button that can be used to attempt to reload the inbox content. Because we are working with multiple composables here, we’re going to first declare a parent container. We’ll use the <code>Column</code> composable here so that we can stack these two children vertically.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ErrorState</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
	<span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

  	}
}</code></pre>

<p>So that we can display an error message to the user, we’re going to need to add this message to the resources of our application. We’ll go ahead and declare a new string resource that represents a generic error message for our inbox.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;message_content_error&quot;</span>&gt;
	Whoops, there was a problem loading the content.
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then go ahead and define a Text composable, providing this string resource as the textual content to be displayed for the body of the composable - using the <code>stringResource</code> function to access this string resource.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ErrorState</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
  	<span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
	  		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.message_content_error)
		)
  	}
}</code></pre>

<figure><img src="111.png"/></figure>

<p>Because we want the user to be able to recover from this error, we’re going to next add an action button that allows the user to refresh the inbox data. We’ll start by adding a string resource for the message that will be displayed in this button:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_try_again&quot;</span>&gt;Try again?&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Along with this resource, we’re going to add the Button composable to our Column - supported by the Spacer composable to create some visual space between these two items. For the content of our Button, we’ll use a Text composable, displaying the string resource that we defined above.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ErrorState</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
  <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
	  id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.message_content_error)
	)

	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

    <span class="syntax-all syntax-entity">Button</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
      
    }) {
      <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_try_again))
    }
  }
}</code></pre>

<figure><img src="1-18.png"/></figure>

<p>At this point though, our button isn’t doing anything. To resolve this, we’re going to need to allow our button to trigger the inbox refresh function that is located within our view model. To avoid us passing our ViewModel directly into this error composable, we’re instead going to pass a reference to the function which can be triggered. Using the specific <code>InboxEvent</code>, the onClick handler of our Button can be used to trigger the refresh our inbox to recover from the error state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ErrorState</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
  	<span class="syntax-all syntax-parameter">inboxEventListener</span><span class="syntax-all syntax-keyword">:</span> (inboxEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
  	<span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
	  		id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.message_content_error)
		)

		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

    	<span class="syntax-all syntax-entity">Button</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
      		inboxEventListener(<span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">RefreshInbox</span>)
    	}) {
      		<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_try_again))
    	}
  	}
}</code></pre>

<p>At this point, our Error composable looks a little off - things aren’t quite lined up properly. This is because, by default, children of a column will be aligned to the <code>Start</code> of the container. To improve how things appear visually here, we’re going to align the content of our column in the horizontal center. We’ll do this by setting the <code>horizontalAlignment</code> of our Column to <code>CenterHorizontally</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ErrorState</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">inboxEventListener</span><span class="syntax-all syntax-keyword">:</span> (inboxEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
  <span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
    horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
  ) {
	...
  }
}</code></pre>

<p>With some alignment now set for our content, we can see that things are being displayed nicely in the center of our error composable.</p>

<figure><img src="2-18.png"/></figure>

<p>So that things aren’t so cramped here, we’ll go ahead and use the <code>padding</code> modifier to create some visual spacing between the edges of the content and the container.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ErrorState</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">inboxEventListener</span><span class="syntax-all syntax-keyword">:</span> (inboxEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
  <span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
    horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
  ) {
	...
  }
}</code></pre>

<p>We can see with this padding in place, there is a better visual spacing within our composable.</p>

<figure><img src="3-15.png"/></figure>

<p>Finally, we’re going to need to ensure that this error state is composed when required, so we’ll go ahead and add to the <code>if</code> block within our Box composable. Here we’ll want to compose our error state if our Inbox State reference has its status flag assigned as the <code>InboxStatus.ERROR</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
  ...
) {
  <span class="syntax-all syntax-keyword">if</span> (inboxState.status <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>) {		<span class="syntax-all syntax-entity">Loading</span>()
  } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">if</span> (inboxState.status <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">ERROR</span>) {
	<span class="syntax-all syntax-entity">ErrorState</span> {
      inboxEventListener(<span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">RefreshInbox</span>)
    }
  }
}</code></pre>

<p>With this in place, we are now composing our error composable when an error has occurred loading the inbox - allowing the user to recover from this scenario via the provided action.</p>

<h3>Composing the empty state</h3>

<p>Aside from an error occurring, it might be the case that there are no emails returned for the user’s inbox - it’s never a bad thing to reach inbox zero after all! For this, we’re going to want to display some form of empty state to the user - this is going to look very similar to the Error composable that we previously created. </p>

<p>We could create some form of composable that can be used for both error/empty states, but to keep things simpler for examples sake we will create a new composable called <code>EmptyState</code> which look pretty much the same as our existing <code>ErrorState</code>. The main difference here will be the use of two different string resources for the title and action composables:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;message_empty_content&quot;</span>&gt;
	Nothing to show here yet.
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_check_again&quot;</span>&gt;Check again&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With these in place, we can go ahead and copy our <code>ErrorState</code> composable, switching out the string resources being used within the child composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmptyState</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
  	<span class="syntax-all syntax-parameter">inboxEventListener</span><span class="syntax-all syntax-keyword">:</span> (inboxEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">InboxEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
  	<span class="syntax-all syntax-entity">Column</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
    	horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
  	) {
    	<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
      		<span class="syntax-all syntax-entity">R</span>.string.message_empty_content))
    	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))

    	<span class="syntax-all syntax-entity">Button</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
      		inboxEventListener(<span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">RefreshInbox</span>)
    	}) {
      		<span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span>
        		<span class="syntax-all syntax-entity">R</span>.string.label_check_again))
    	}
  	}
}</code></pre>

<figure><img src="4-11.png"/></figure>

<p>With this <code>EmptyState</code> composable in place, we’re now ready for it to be composed within our UI. We’ll hope back over to the Box composable within our Scaffold content area, modifying the <code>if</code> clause to handle the Empty state. What we’ll do here is place the <code>EmptyState</code> within the <code>else</code> block - that way if something hasn’t gone wrong and our screen isn’t loading, we can assume that at this point, the response is going to be that of an empty one (which also gives us something to fall back on).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
  ...
) {
  <span class="syntax-all syntax-keyword">if</span> (inboxState.status <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>) {		<span class="syntax-all syntax-entity">Loading</span>()
  } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">if</span> (inboxState.status <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">ERROR</span>) {
	<span class="syntax-all syntax-entity">ErrorState</span> {
      inboxEventListener(<span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">RefreshInbox</span>)
    }
  } <span class="syntax-all syntax-keyword">else</span> {
    <span class="syntax-all syntax-entity">EmptyState</span> {
      inboxEventListener(<span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">RefreshInbox</span>)
    }
  }
}</code></pre>

<hr />

<h2>Displaying the Email Inbox</h2>

<figure><img src="ll.png"/></figure>

<p>At this point, we’ve handled most of the different states that can be represented by our Inbox. The remaining state however is probably the most important one for our UI, being the actual list of emails that allows the user to view their inbox. So that we can get started within implementing this part of our UI, we’ll go ahead and create a new composable function, <code>EmailList</code>, that takes a collection of <code>Email</code> items from our Inbox State reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailList</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">emails</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Email</span>&gt;
) {

}</code></pre>

<p>Inside of this composable we’re going to need to display a list of emails - while we are hardcoding these emails within our state, in a real scenario we won’t know exactly how many email items will come back for us to display. For this reason, we’re going to utilise the <code>LazyColumn</code> composable, which will only compose its children as they are required - making it much more efficient than composing everything at the same time when it might not even be visible to the user.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">LazyColumn</span>(
  modifier <span class="syntax-all syntax-keyword">=</span> modifier
) {

}</code></pre>

<p>We’re going to need to add support for the items that make up our <code>LazyColumn</code>. The items provided here need to be composed using the item function provided through the <code>LazyListScope</code> - this is so that a unique key can be provided for each item being composed, allowing the <code>LazyColumn</code> to correctly manage the current scroll position on the screen. </p>

<p>With that said, we’ll go ahead and utilise the <code>items</code> function - this allows us to provide a list that we wish to compose items from, along with defining how the key for that item should be generated. When it comes to key generation, we’re going to want to use the <code>id</code> from the <code>Email</code> class - each of our emails has a unique ID, so this will satisfy the key requirements for the <code>LazyColumn</code> items. Along with this key generation being called for each item, the itemContent block will also be called - this is where we will declare the composition for each item that is being composed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">LazyColumn</span>(
  modifier <span class="syntax-all syntax-keyword">=</span> modifier
) {
	items(emails, key <span class="syntax-all syntax-keyword">=</span> { item <span class="syntax-all syntax-keyword">-&gt;</span> item.id }) { email <span class="syntax-all syntax-keyword">-&gt;</span>

	}
}</code></pre>

<h3>Setting up Swipe-to-Dismiss</h3>

<figure><img src="klll.png"/></figure>

<p>At this point, we’re ready to define the composable content that represents the body of each email in our list. Because we’re supporting swipe-to-dismiss within our inbox, this is going to be a bit more involved than if we were simply displaying an Email composable. For this reason, each <code>Email</code> within our <code>LazyColumn</code> is going to be represented by the <code>SwipeToDismiss</code> composable. This allows us to support the swipe-to-dismiss behaviour, provided out-of-the-box by the Compose APIs.</p>

<pre><code class="code-highlighted code-kt">items(...) {
	<span class="syntax-all syntax-entity">SwipeToDismiss</span>(
  
	)
}</code></pre>

<p>When it comes to the <code>SwipeToDismiss</code> composable, there are going to be a couple of things that we need to configure which will control the behaviour of our composable. The first behaviour we want to control here is the supported directions of the swipe-to-dismiss gesture, with the supported values being <code>DismissDirection.StartToEnd</code> and <code>DismissDirection.EndToStart</code>. We’re only going to support <code>StartToEnd</code> within our <code>LazyColumn</code> meaning that users will be able to dismiss an item by swiping the item from the start to the end, so we’ll go ahead and declare this using the <code>directions</code> argument of the <code>SwipeToDismiss</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SwipeToDismiss</span>(
	directions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">setOf</span>(
  		<span class="syntax-all syntax-entity">DismissDirection</span>.<span class="syntax-all syntax-entity">StartToEnd</span>
  	)
)</code></pre>

<p>When swiping an item to perform a dismiss gesture, we might want to control the position at which the gesture becomes a dismissal. For example, we might not want the dismiss action to be triggered until the item has been swiped to the halfway point of the swappable row. To control this we can utilise the dismissThresholds property of the <code>SwipeToDismiss</code> composable. For this, we will need to provide an instance of the <code>FractionalThreshold</code> class, which is used to define a point between two anchors at which the specified concept should be triggered. In the case of swipe to dismiss, we are anchoring between 0f and 1f - where 0f is the start of the item and 1f is the end. The value we define for the <code>FractionalThreshold</code> will depict the swipe position at which the item will become dismissed. We’ll go ahead and define a value here in the form of <strong>0.15f</strong>, meaning that the dismissal will be activated once the email has been swiped 15% of the way across the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SwipeToDismiss</span>(
  	directions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">setOf</span>(
    	<span class="syntax-all syntax-entity">DismissDirection</span>.<span class="syntax-all syntax-entity">StartToEnd</span>
  	),
  	dismissThresholds <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-entity">FractionalThreshold</span>(<span class="syntax-all syntax-constant">0.15f</span>)
  	}
)</code></pre>

<p>Now that we’ve configured some initial setup for our <code>SwipeToDismiss</code> composable, we’re going to need to set up the actual content to be used for the items. When it comes to the <code>SwipeToDismiss</code> there are two parts that come into play here - the foreground of the item (which is initially displayed to the user), followed by the background of the item (which is revealed once the swipe gesture is performed). </p>

<figure><img src="bg.png"/></figure>

<p>We’re going to need to define a composable for each of these foreground and background states, both of which will be provided to our <code>SwipeToDismiss</code> reference.</p>

<h3>Defining the item foreground</h3>

<figure><img src="oppo.png"/></figure>

<p>As mentioned previously, the foreground of the item is the state which is displayed to the user when the item is undismissed - which will be the initial state when our UI is composed. In this case of our email inbox, this foreground is going to represent the content of the Email. We’re going to go ahead and create a new composable which will be used to display information for each email.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Email</span>
) {

}</code></pre>

<p>This composable takes an individual instance of an Email class, which will be used to populate the child composables of the <code>EmailItem</code>. The foreground of each email item is going to be composed to represent the title and body of the email:</p>

<figure><img src="email-1.png"/></figure>

<p>While this looks pretty minimal at a first glance, this is going to consist of a couple of composables. We’ll start here by defining a <code>Card</code> composable - this will be used to hold the entire content of the Email class, displaying the body inside of a <code>Card</code> parent. We use the <code>fillMaxSize</code> modifier for the card so that the card fills the available space, but so that the card is not pressed to the sides of the screen (and against the other cards within the list) we’re also going to apply the <code>padding</code> modifier with a value of 16dp.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Card</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp)
) {

}</code></pre>

<p>While there is no content body that we’ve yet defined, our card will be filling the available space for the <code>LazyColumn</code> item, along with using the assigned padding to create space around its outside area.</p>

<figure><img src="card.png"/></figure>

<p>When it comes to the <code>Email</code> reference that this card has, we’re going to want to display the <strong>title</strong> and <strong>description</strong> fields inside of the email item card. However, the <code>Card</code> composable only allows a single child to be placed inside of its content area - so we’re going to need to declare a child of the card which will be used to hold the composables for the <strong>title</strong> and <strong>description</strong> fields of our <code>Email</code> reference.</p>

<figure><img src="ooo.png"/></figure>

<p>Because we want to vertically stack the title and description of the Email, for this we’re going to utilise the <code>Column</code> composable. Along with defining this <code>Column</code>, we’re going to assign some modifiers </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.padding(<span class="syntax-all syntax-constant">16</span>.dp)
		.fillMaxWidth()
) {

}</code></pre>

<p>Assigning some <code>padding</code> here will create some spacing so that our column is not pressed against the edges of the card. Along with this, <code>fillMaxWidth</code> will allow the Column to take up the whole available width within the card - ensuring that the textual content of the composables we are going to provide uses all of the available space. With this <code>Column</code> in place, we can start thinking about the children that we can add here.</p>

<figure><img src="T.png"/></figure>

<p>We’ll start here with the title of the email - we’ll display this using a <code>Text</code> composable. We won’t need to customise much here, we’ll assign the title of the email using the <strong>text</strong> property of the composable, along with setting the <strong>fontWeight</strong> to the value of Bold.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.padding(<span class="syntax-all syntax-constant">16</span>.dp)
    	.fillMaxWidth()
) {
	<span class="syntax-all syntax-entity">Text</span>(
    	text <span class="syntax-all syntax-keyword">=</span> email.title,
    	fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
  	)
}</code></pre>

<p>With this in place, we have the title of our <code>Email</code> displaying within our card item.</p>

<figure><img src="title-1.png"/></figure>

<p>Alongside the title, we’re going to want to display the description of the email - this will act as a short preview of the email content.</p>

<figure><img src="TT.png"/></figure>

<p>For this, we’re going to use another <code>Text</code> composable to display the email preview content to the user. Before we add this though, we’re going to add another composable in the form of a <code>Spacer</code> - this will create some visual space between the title and the description</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.padding(<span class="syntax-all syntax-constant">16</span>.dp)
    	.fillMaxWidth()
) {
  	...

  	<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">8</span>.dp))
}</code></pre>

<p>Next, we’ll add a <code>Text</code> composable to represent the content of our email reference. We’ll assign a couple of different properties here:</p>

<ul>
	<li><strong>fontSize</strong>: this will be set to <code>14sp</code>, making it appear slightly smaller than the title of the email</li>
	<li><strong>maxLines</strong>: setting this value ensures that our <code>Text</code> composable will not have unlimited height available - we’ll cap this at 2 lines. </li>
	<li><strong>overflow</strong>: because we’ve capped the maxLines for the composable, we’re going to declare that any overflow that extends these 2 lines will be handled by the display of ellipsis.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.padding(<span class="syntax-all syntax-constant">16</span>.dp)
    	.fillMaxWidth()
) {
  	...

  	<span class="syntax-all syntax-entity">Text</span>(
    	text <span class="syntax-all syntax-keyword">=</span> email.description,
    	fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">14</span>.sp,
    	maxLines <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">2</span>,
    	overflow <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextOverflow</span>.<span class="syntax-all syntax-entity">Ellipsis</span>
  	)
}</code></pre>

<p>Adding this second <code>Text</code> composable results in our email card item being fully populated.</p>

<figure><img src="content.png"/></figure>

<p>We can next go ahead and provide this <code>EmailItem</code> composable to the <code>dismissContent</code> argument of our <code>SwipeToDismiss</code> composable - passing the reference to the current <code>Email</code> item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SwipeToDismiss</span>(
  	directions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">setOf</span>(
    	<span class="syntax-all syntax-entity">DismissDirection</span>.<span class="syntax-all syntax-entity">StartToEnd</span>
  	),
  	dismissThresholds <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-entity">FractionalThreshold</span>(<span class="syntax-all syntax-constant">0.15f</span>)
  	},
  	dismissContent <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-entity">EmailItem</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
      		email <span class="syntax-all syntax-keyword">=</span> email
    	)
  	}
)</code></pre>

<p>With this in place, we’ll be able to see the provided email content within the body of our card, with this being swipeable from the start to the end of the dismiss row.</p>

<figure><img src="ff-1.png"/></figure>

<h3>Defining the item background</h3>

<figure><img src="bb.png"/></figure>

<p>Now that we have the foreground for our email item created, we can perform the swipe-to-dismiss gesture on an email within our inbox. However, when we perform this gesture there is currently no indication to the user around what that action will result in. For this purpose, we’re going to implement the <strong>background</strong> argument of the <code>SwipeToDismiss</code> composable - allowing us to provide a composable to be used for the background of the row.</p>

<p>We’ll start here by creating a new composable function that will represent the background of our email item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailItemBackground</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {

}</code></pre>

<p>Within this composable, we’re only going to need to display an <code>Icon</code> composable to the user. However, we’re going to want to provide some customisations for this background in the next part of this chapter - so with that in mind, we’re going to wrap the content of our background in a <code>Box</code> composable.</p>

<figure><img src="b.png"/></figure>

<p>The <code>Box</code> composable allows us to contain any number of children, aligning them using the specified alignment configuration. Before we start adding children here, we’re going to add a couple of modifiers to our <code>Box</code>. We’ll use the <code>fillMaxSize</code> modifier to declare that the composable should use all of the available space that it has, along with adding some padding - this will ensure that the contents of the composable have sufficient spacing between themselves and the inside edge of the <code>Box</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">20</span>.dp)
) {

}</code></pre>

<p>Now that we have this composable configured, we can move on to populating the content that it can hold.</p>

<figure><img src="bb-1.png"/></figure>

<p>Here we’re going to add an <code>Icon</code> composable to the content area of our <code>Box</code>. This icon will be used to display a trash bin, signifying that the swipe action is going to delete the specified email.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
  	...
) {
  	<span class="syntax-all syntax-entity">Icon</span>(
    	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Delete</span>
  	)
}</code></pre>

<p>Alongside this, we’re also going to add a content description to our icon, for which we’ll need to add a string resource to our project.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_delete_email&quot;</span>&gt;Delete Email&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then assign this description to the <code>contentDescription</code> argument of the <code>Icon</code> composable, using the <code>stringResource</code> function to access this string from our resources.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
  	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Delete</span>,
  	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span>
      	<span class="syntax-all syntax-entity">R</span>.string.cd_delete_email)
)</code></pre>

<p>At this point, our Icon will be visible within our Box - however, things don’t look quite right.</p>

<figure><img src="trash.png"/></figure>

<p>To improve this visual representation, we need to align the Icon within our box. Here we’ll use the <code>align</code> modifier to apply the <code>CenterStart</code> alignment to the icon - positioning the icon at the start of the box, centered vertically.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterStart</span>),
  	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Delete</span>,
  	contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span>
      	<span class="syntax-all syntax-entity">R</span>.string.cd_delete_email)
)</code></pre>

<figure><img src="trash_aligned.png"/></figure>

<p>With this composable in place, we’re now able to provide our <code>EmailItemBackground</code> composable as the body for the <code>background</code> argument of our <code>SwipeToDismiss</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SwipeToDismiss</span>(
  	directions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">setOf</span>(
    	<span class="syntax-all syntax-entity">DismissDirection</span>.<span class="syntax-all syntax-entity">StartToEnd</span>
  	),
  	dismissThresholds <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-entity">FractionalThreshold</span>(<span class="syntax-all syntax-constant">0.15f</span>)
  	},
  	background <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-entity">EmailItemBackground</span>()
  	},
  	dismissContent <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-entity">EmailItem</span>(email)
  	}
)</code></pre>

<hr />

<h2>Handling item deletion</h2>

<p>With our <code>SwipeToDismiss</code> implementation, we’re able to swipe away items - but we may notice at this point nothing happens once we’ve swiped the item to the end. The background for our item remains in place, and the email is not removed from our inbox (as we should be able to see the inbox count does not change). In this section, we’re going to handle the dismissal of the email items, while also adding some animations to improve the visual representation of item deletion. With this in mind, we need to:</p>

<ul>
	<li>Listen for when an item is dismissed action is triggered</li>
	<li>Trigger an animation for the item removal</li>
	<li>Update our Inbox State to remove the email from the inbox</li>
</ul>

<p>Taking the first point into account, the <code>SwipeToDismiss</code> composable allows for a state reference to be passed in the form of a <code>DismissState</code> reference - this allows us to monitor the state of item dismissal. So that we can provide a reference to our composable, we’re going to need to create a reference to a <code>DismissState</code>. We can do this using the <code>rememberDismissState</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> dismissState <span class="syntax-all syntax-keyword">=</span> rememberDismissState(
  	confirmStateChange <span class="syntax-all syntax-keyword">=</span> {

    	<span class="syntax-all syntax-constant">true</span>
  	}
)</code></pre>

<p>Here we can utilise the <code>confirmStateChange</code> callback to monitor when a state change has been triggered - i.e when an item dismissal has taken place. We return <code>true</code> from this callback, as we always want to allow the user to dismiss an email, so this is us confirming the action is allowed. The key here is what else we can do in this callback, which in our case is the actual dismissal of the item from our state.</p>

<p>Now before we change our Inbox state and remove the item, we want to perform an animation of the item removal. If we update our state from this <code>confirmStateChange</code> callback, our state will change before we can perform an animation. So instead, we’re going to use this callback to trigger the animation, and then we can trigger the change of our state once that animation has been completed.</p>

<p>When it comes to animations, we’re going to start by animating the height of our email row. So when our email item is dismissed, we’ll collapse the height of the email before removing it from the state of our screen. To be able to achieve this, we need to create a boolean flag for the current email item which will depict whether the email should currently be visible or not.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">var</span> isEmailItemDismissed by remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }</code></pre>

<p>With this flag in place, we can now animate the state of our composables based on whether the email item is being dismissed. But before that can happen, we’ll need to toggle this value to <code>true</code> whenever the email item is being dismissed from the list. For this, we’ll update our <code>confirmStateChange</code> callback to toggle this value whenever an item is being dismissed to the end of the row.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> dismissState <span class="syntax-all syntax-keyword">=</span> rememberDismissState(
	confirmStateChange <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-keyword">if</span> (it <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">DismissValue</span>.<span class="syntax-all syntax-entity">DismissedToEnd</span>) {
      	isEmailItemDismissed <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
    	}
    	<span class="syntax-all syntax-constant">true</span>
  	}
)</code></pre>

<p>With this <code>DismissState</code> reference in place, we can now apply this to our <code>SwipeToDismiss</code> composable. Now, the <code>confirmStateChange</code> will be triggered whenever a dismiss action is triggered within the inbox.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SwipeToDismiss</span>(
  	state <span class="syntax-all syntax-keyword">=</span> dismissState,
  	...
)</code></pre>

<p>With this callback now being triggered and our dismissal flag being toggled, we’re in a good position to start adding some animations to dismiss our item. Using the <code>animateDpAsState</code> function, we’ll define the values which should be applied for our email height based on the <code>isEmailItemVisible</code> flag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> emailHeightAnimation by animateDpAsState(
	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isEmailItemVisible) <span class="syntax-all syntax-constant">120</span>.dp 
		<span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-constant">0</span>.dp
)</code></pre>

<p>With this target value configured, these <code>dp</code> values will be automatically animated between based on the value of our <code>isEmailItemVisible</code>. So for the default state of our flag as <code>true</code>, a height of 120dp will be set for our email items. But when this flag is toggled to <code>false</code>, the height will be animated from <code>120dp</code> to <code>0dp</code> - having this animated <code>dp</code> value means that we can apply this directly to our composable and the height of our composable will be animated with this value. Before we go and apply this to our email item, we’re going to make a few adjustments to our animation.</p>

<p>To start with, the spring animation will be applied by default to our email item. This is a pretty quick animation and doesn’t make the dismissal feel too smooth - so instead, we’re going to override this using the <code>animationSpec</code> argument. Here we’ll create a new <code>tween</code> animation, setting a delay before the animation is started. This will allow our email to be swiped, followed by the animation being triggered shortly after. If you run this and perform the animation you’ll see that the dismissal feels very smooth, performed in a good time after the swipe gesture has been performed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> emailHeightAnimation by animateDpAsState(
	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isEmailItemVisible) <span class="syntax-all syntax-constant">120</span>.dp 
		<span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-constant">0</span>.dp,
  	animationSpec <span class="syntax-all syntax-keyword">=</span> tween(delayMillis <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">300</span>)
)</code></pre>

<p>Alongside this <code>animationSpec</code>, we’re going to utilise the <code>finishedListener</code> callback to detect when the <code>dp</code> animation has been completed. When this happens, it’s safe for us to update our Inbox state and remove the email - we won’t experience any jank here, as the animation would have been completed before the body of <code>finishedListener</code> is called.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> emailHeightAnimation by animateDpAsState(
  	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isEmailItemVisible) <span class="syntax-all syntax-constant">120</span>.dp 
		<span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-constant">0</span>.dp,
  	animationSpec <span class="syntax-all syntax-keyword">=</span> tween(delayMillis <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">300</span>),
  	finishedListener <span class="syntax-all syntax-keyword">=</span> {
    	inboxEventListener(<span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">DeleteEmail</span>(email.id))
  	}
)</code></pre>

<p>At this point, we have created a custom animation that will animate the height of our email row, followed by triggering the removal of the email from our state once the animation has been completed. With this done, we now need to apply this to both the email foreground <strong>and</strong> background for each item within our inbox, which will be done using the <code>height</code> modifier. To be able to do this, we’re going to modify the <code>EmailItem</code> and <code>EmailItemBackground</code> composable functions to accept a modifier as an argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailItem</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Email</span>,
    <span class="syntax-all syntax-parameter">dismissState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DismissState</span>
)</code></pre>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailItemBackground</span>(
  <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>We can then utilise the <code>height</code> modifier to apply the <code>emailHeightAnimation</code> reference that we defined, which will compose and recompose the specific composable using the height which the state is currently holding.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SwipeToDismiss</span>(
  	...,
  	dismissContent <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-entity">EmailItem</span>(
    		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
				.fillMaxWidth()
				.height(emailHeightAnimation),
      		email <span class="syntax-all syntax-keyword">=</span> email
    	)
  	},
  	background <span class="syntax-all syntax-keyword">=</span> {
    	<span class="syntax-all syntax-entity">EmailItemBackground</span>(
      		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
				.fillMaxWidth()
				.height(emailHeightAnimation),
    	)
  	}
)</code></pre>

<p>At this point, we’re passing in the height modifier, by we haven’t applied it to the composables. We’ll start at the <code>EmailItem</code> composable where we’ll replace the direct <code>Modifier</code> declaration with the <code>modifier</code> reference that we are now providing to the composable function. This means that our custom height will be applied to the <code>Card</code>, along with the padding which is being chained on.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Card</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp)
)</code></pre>

<p>Hopping over to the <code>EmailItemBackground</code> composable we’ll do the same thing, applying the provided modifier to the <code>Box</code> composable - keeping the previously defined modifiers in place, chained onto our provided reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">20</span>.dp)
)</code></pre>

<p>With this height modifier in place, running the code so far should allow you to perform the swipe gesture and see the animation play out while the item is being dismissed. Once the animation has been completed, the item will be completely dismissed from the inbox - with the inbox count in the top app bar reflecting the new count after the dismissal.</p>

<h3>Animating the background color</h3>

<p>When triggering the swipe gesture on our email item, it’s not super clear that a deletion is going to take place - the delete icon feels very subtle. With deletion being a destructive process, we want to make it clear to the user that a deletion is going to take place. To improve this, we’re going to add a background color to our email background, having this animate into view once the dismiss gesture is triggered.</p>

<p>To be able to know when a dismissal is taking place (and that we should set the background color), our background composable is going to need to know the current dismissal state. For this, we’re going to need to provide the <code>DismissState</code> to the composable function as an argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailItemBackground</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">dismissState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DismissState</span>
)</code></pre>

<p>Now that we have access to the dismissal state inside our background composable, we can go ahead and define an animation to use for the background color. Similar to how we created an animation for the height of the email row, we’re going to utilise the <code>animateColorAsState</code> function to animate between two colors for the background. </p>

<p>When the item is in the <code>DismissedToEnd</code> state (as in, the item is being dismissed), we’re going to want to set the background color to the error state of our theme. With the error color of our theme usually representing an error related color, this feels appropriate to apply here. When the dismiss state does not represent a dismissal, we’re going to use the same theme color that is being used for the background of our UI, represented by the <code>background</code> from our theme.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> backgroundColor by animateColorAsState(
  	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">when</span> (dismissState.targetValue) {
    	<span class="syntax-all syntax-entity">DismissValue</span>.<span class="syntax-all syntax-entity">DismissedToEnd</span> <span class="syntax-all syntax-keyword">-&gt;</span> 		
			<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.error
    	<span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.background
  	}
)</code></pre>

<p>Because the <code>DismissState</code> reference being provided to this composable function will change based on the state of the email item, the <code>targetValue</code> of our animation will use the color based on that. When this state changes, the colors will be animated between. We’ll make a small tweak to improve the animation here, using the <code>animationSpec</code> to override the default animation and apply the <code>tween</code> animation instead.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> backgroundColor by animateColorAsState(
  	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">when</span> (dismissState.targetValue) {
    	<span class="syntax-all syntax-entity">DismissValue</span>.<span class="syntax-all syntax-entity">DismissedToEnd</span> <span class="syntax-all syntax-keyword">-&gt;</span> 		
			<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.error
    	<span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.background
  	},
  	animationSpec <span class="syntax-all syntax-keyword">=</span> tween(),
)</code></pre>

<p>With this animation in place, we can apply this as the background for our <code>Box</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> modifier
    	.background(backgroundColor)
    	.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">20</span>.dp)
)</code></pre>

<p>With this applied, performing the dismiss gesture on an item will animate the background color of the email row from the background color of our theme, to the error color of our theme.</p>

<figure><img src="bg-1.png"/></figure>

<h3>Animating the Delete icon</h3>

<p>While the background animation adds a nice touch to our UI, you might have noticed that now the trash icon doesn’t quite play well when it’s dismissed. Because our email row is collapsing, we want to hide the trash icon once the swipe gesture has been performed - we could do something fancy here with the animations, but the trash icon does not serve a purpose once the gesture has been performed. Instead, we’ll adjust the declaration in our <code>Box</code> composable to only compose the <code>Icon</code> when the dismissed state is the <code>Default</code> value. This way when the item is being dismissed, the trash icon will not be composed as part of our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(...) {
  	<span class="syntax-all syntax-keyword">if</span> (dismissState.currentValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">DismissValue</span>.<span class="syntax-all syntax-entity">Default</span>) {
    	<span class="syntax-all syntax-entity">Icon</span>(...)
  	}
}</code></pre>

<p>While this makes the dismissal play out a bit smoother, the icon still doesn’t sit quite right in our email row. Now that we have the background color applied to our row, the black Icon looks a bit harsh against our error color. To improve this, we’re going to define another animated color state that we will apply to the color of our icon. This time we’ll want to mirror the colors that we previously used, so we’ll use the <code>onError</code> value from our theme for when the email is being dismissed, along with the <code>onSurface</code> color for the stationary value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> iconColor by animateColorAsState(
  	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">when</span> (dismissState.targetValue) {
    	<span class="syntax-all syntax-entity">DismissValue</span>.<span class="syntax-all syntax-entity">DismissedToEnd</span> <span class="syntax-all syntax-keyword">-&gt;</span> 
			<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onError
    	<span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface
  	},
  	animationSpec <span class="syntax-all syntax-keyword">=</span> tween(),
)</code></pre>

<p>We can now apply this to our icon using the <code>tint</code> argument. Now when the email dismissal state is triggered, the color of our icon will be animated from the <code>onSurface</code> to <code>onError</code> (and vice versa).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
  	...,
  	tint <span class="syntax-all syntax-keyword">=</span> iconColor
)</code></pre>

<p>If we perform the swipe gesture, we’ll be able to see the Delete icon animate between these two colors.</p>

<figure><img src="ic.png"/></figure>

<p>As a final last touch for our Delete icon, we’re going to change the scale when the dismiss state kicks in - this will add some emphasis to the icon when the state change occurs. For this we’ll utilise the <code>animateFloatAsState</code> function - similar to how we’ve animated <code>color</code> and <code>dp</code> values, we’ll now animate between two float values. By default we’ll scale our Delete Icon by <code>0.75f</code>, scaling it to its full size when the state is toggled to <code>DismissedToEnd</code>.</p>

<pre><code>val scale by animateFloatAsState(
	targetValue = if (dismissState.targetValue == 
    	DismissValue.DismissedToEnd) {
    	1f
  	} else 0.75f
)</code></pre>

<p>We’ll then apply this scale to our <code>Icon</code> composable using the <code>scale</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterStart</span>)
    	.scale(scale),
  	...
)</code></pre>

<p>If we again transition between these states, we’ll be able to see that the icon scale changes based on the dismiss state that is currently represented for our email item.</p>

<figure><img src="icc.png"/></figure>

<h3>Emphasising the Email Card</h3>

<p>Currently, our email <code>Card</code> is always elevated, which is the default behaviour for this composable. However, it might look quite nice if we only apply the elevation when the card is being swiped. That way by default, the card will appear flat with the row and then floating once being interacted with. To implement this behaviour we’re going to need to provide the <code>DismissState</code> reference to our <code>EmailItem</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmailItem</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">email</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Email</span>,
    <span class="syntax-all syntax-parameter">dismissState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DismissState</span>
)</code></pre>

<p>Next, we’ll create another animation, using the <code>animateDpAsState</code> to animate between two <code>dp</code> values. We’ll apply <code>0dp</code> elevation by default, animating this to <code>4dp</code> when there is a <code>dismissDirection</code> present within our dismiss state (meaning that the card is being swiped).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> cardElevation <span class="syntax-all syntax-keyword">=</span> animateDpAsState(
  	<span class="syntax-all syntax-keyword">if</span> (dismissState.dismissDirection <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>) {
    	<span class="syntax-all syntax-constant">4</span>.dp
  	} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-constant">0</span>.dp
).value</code></pre>

<p>Well then apply this elevation to our card so that we can animate the elevation based on the current dismiss state of the email item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Card</span>(
  	elevation <span class="syntax-all syntax-keyword">=</span> cardElevation,
  	...
)</code></pre>

<p>With this elevation applied, we’ll be able to see the elevation of our <code>Card</code> composable animate between values, based on the current dismiss state.</p>

<figure><img src="elev.png"/></figure>

<hr />

<h2>Displaying item dividers</h2>

<figure><img src="llkkj.png"/></figure>

<p>Now that our email inbox is mostly implemented, we’re going to add a final visual touch to the User Interface by adding some simple dividers between each of the email items. For this, we’ll utilise the <code>Divider</code> composable and add it beneath the <code>SwipeToDismiss</code> composable within the layout hierarchy.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Divider</span>()</code></pre>

<figure><img src="div.png"/></figure>

<p>We can improve the appearance of this slightly by adding some horizontal padding to the divider, creating some space at both the start and end. We’ll use the <code>padding</code> modifier for this, along with the <code>horizontal</code> argument to only apply the padding on the horizontal axis.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Divider</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)
)</code></pre>

<figure><img src="div2.png"/></figure>

<p>With this divider showing, it will automatically be removed once the corresponding email item is removed from the list. However, since we added animations to the rest of the email row items, we’re going to do the same for the divider. We’ll add an animation for the alpha of the divider, allowing it to appear as though it is vanishing as the email item is swiped. </p>

<p>For this, we’ll need to start by defining a new animation, similar to the previous ones that we defined in this chapter. We’ll use the <code>animateFloatAsState</code> to create an animatable float value that will be used for the alpha of our divider.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> dividerVisibilityAnimation by animateFloatAsState(
  	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (dismissState.targetValue <span class="syntax-all syntax-keyword">==</span>
   		<span class="syntax-all syntax-entity">DismissValue</span>.<span class="syntax-all syntax-entity">Default</span>) {
    	<span class="syntax-all syntax-constant">1f</span>
  	} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-constant">0f</span>,
  	animationSpec <span class="syntax-all syntax-keyword">=</span> tween(delayMillis <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">300</span>)
)</code></pre>

<p>By default, the alpha of our divider will be <code>1f</code>, meaning that it will be completely visible. However, when the email item is being dismissed, we’ll animate to the value of <code>0f</code> - meaning that our divider will eventually become invisible to the user. With this implemented, we can apply this to our Divider by using the <code>alpha</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Divider</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)
    	.alpha(dividerVisibilityAnimation)
)</code></pre>

<p>With this in place, we’ll be able to perform the dismiss gesture on our email item and see that the divider animates out of view as the swipe gesture is triggered.</p>

<hr />

<h2>Adding accessibility actions</h2>

<p>Currently, the only way to be able to delete an email from our inbox is by performing a swipe action on the email item. If the user has talkback turned on, there’s going to be some friction when interacting with this feature of our email inbox. When talkback is enabled, the user will be able to highlight each email item - we just need to provide a way to remove some of the friction </p>

<figure><img src="one.png"/></figure>

<p>To achieve this, we’re going to add a custom accessibility action to the email item. This is done by using the <code>customActions</code> semantic, providing a <code>CustomAccessibilityAction</code> for each of the custom actions that we want to support. We’re going to add a <strong>Delete Email</strong> action that will hook into the talkback actions API, allowing the user to delete an email via the native accessibility services.</p>

<p>To add an action we’re going to need to provide a label - we’ll define a label in our application resources, followed by accessing this resource using the <code>stringResource</code> function.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_delete_email&quot;</span>&gt;Delete Email&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> deleteEmailLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_delete_email)</code></pre>

<p>With this, we can now create our action using the <code>CustomAccessibilityAction</code> class. We’ll create a new reference to this, passing in our retrieve string value for the label.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">CustomAccessibilityAction</span>(deleteEmailLabel)</code></pre>

<p>We’ll also need to implement the action handler, this is where we’ll need to perform the action deletion of the email from the inbox. Here we’ll utilise our <code>inboxEventListener</code> reference to trigger the <code>DeleteEmail</code> event, using the id of the email that is to be deleted. This handler needs to return a boolean flag to indicate whether the action was handled - we’ll return <code>true</code> here as we’re triggering our listener to delete the email.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">CustomAccessibilityAction</span>(deleteEmailLabel) {
  inboxEventListener(<span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">DeleteEmail</span>(email.id))
  <span class="syntax-all syntax-constant">true</span>
}</code></pre>

<p>With this action in place, we can go ahead and apply this to our swipe item, which we’ll do so using the <code>semantics</code> modifier. Within this modifier we need to use the <code>customActions</code> semantic, providing a list of the actions that we want to support. We’re only supporting our single action here, so we’ll add this to the semantic within the required list format.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SwipeToDismiss</span>(
  	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.semantics {
    	customActions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(
      		<span class="syntax-all syntax-entity">CustomAccessibilityAction</span>(deleteEmailLabel) {
        		inboxEventListener
					(<span class="syntax-all syntax-entity">InboxEvent</span>.<span class="syntax-all syntax-entity">DeleteEmail</span>(email.id))
        		<span class="syntax-all syntax-constant">true</span>
      		}
    	)
  	},
  	...
)</code></pre>

<p>With this in place, the user will be able to launch the actions menu for each of the email items (this is achieved by performing a three-finger tap on the email item.</p>

<figure><img src="two-1.png"/></figure>

<p>At this point, the user can then double-tap on the <strong>Actions</strong> option to learn about the actions that are available for this item.</p>

<figure><img src="three.png"/></figure>

<p>The user can again perform a double-tap gesture, this time on the <strong>Delete Email</strong> option. When this is performed, the delete email flow will be triggered and the email removed from the inbox. With this in place, we now have native accessibility support for our email inbox - creating an inclusive experience.</p>

<hr />

<p>With all of the above in place, we now have a functional email inbox that allows us to load a collection of email items. Alongside this, we can perform swipe gestures on each of the items to dismiss them from the list - all of which is executed with some pleasant animations.</p>

<p>Now that we have this UI in place, let’s move on to learn how we can write some automated tests to assert these various pieces of functionality!</p>

<h1>Testing the Inbox Feed UI</h1>

<p>Now that we’ve built our Inbox Feed, we’re going to take a look at how we can write tests for our composables. We’re going to be writing some instrumentation tests using the compose ui-test-junit package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>)
debugImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to add mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered whenever expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:3.12.4&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependant on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		exclude <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/AL2.0&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/LGPL2.1&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
	}
}</code></pre>

<hr />

<h2>Testing the Email Inbox</h2>

<p>At a high level of our feature is the <code>EmailInbox</code> composable. While we have a collection of focused composables that are responsible for specific parts of our UI, this composable acts as the parent container - deciding whether the user should be shown the email inbox, empty state, error state and so on. For this reason, we’re going to write a collection of tests that will perform asserts to ensure the correct composables are displayed as expected. We’ll start here by creating a new test class, <code>EmailInboxTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">EmailInboxTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the <code>ComposeContentTestRule</code> class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@get:Rule
</span><span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched in, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside of.</p>

<h3>Testing the Inbox Title</h3>

<p>To start with, our <code>EmailInbox</code> composable displays a collection of email items - we’ll write some tests to ensure that these are displayed as expected. We’ll start with the title of the inbox, for which we’ll create a new test function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox_Title_Displayed</span>()</code></pre>

<p>Inside of this test, we’re going to need to start by setting the composable content that is to be displayed on screen for us to assert against. Here we’ll use the test rule that we previously defined, along with its <code>setContent</code> function. This function takes a composable function as an argument, allowing us to define what is to be composed on screen for our tests. Because we’re wanting to test the <code>EmailInbox</code> Composable that we defined in the previous sections of this chapter, we’ll go ahead and pass the <code>EmailInbox</code> composable function for this composable content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox_Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
		emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList())

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailInbox</span>(inboxState) { }
    }
}</code></pre>

<p>While we aren’t yet performing any assertions, running this test will launch an activity that displays the content of our <code>EmailInbox</code> composable. With this now being displayed, we can next perform the required assertions to ensure that the title is being displayed within our composable UI. We’ll do this by utilising the <code>onNodeWithText</code> function from our test rule reference.</p>

<p>The <code>onNodeWithText</code> function can be used to locate a composable that is displaying the text that we have provided to the function. Composables will be located in the form of a semantic node. Because our composables are represented via semantics, in our tests we are going to be locating nodes within our semantic tree. In this case, this is done using the <code>onNodeWithText</code> function, which will return us with a <code>SemanticsNodeInteraction</code> reference to perform assertions against. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox_Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
		emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList())

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailInbox</span>(inboxState) { }
    }

    composeTestRule.onNodeWithText(
    	<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.title_inbox, inboxState.emails.count())
    )
}</code></pre>

<p>For this test we want to assert that this node is being displayed within our composed UI, so we’re going to go ahead and utilise the <code>assertIsDisplayed</code> function. This is one of the assertions available on the <code>SemanticsNodeInteraction</code> class, allowing us to assert whether this node is being displayed on the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Inbox_Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
		emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList())

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailInbox</span>(inboxState) { }
    }

    composeTestRule.onNodeWithText(
    	<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.title_inbox, inboxState.emails.count())
    ).assertIsDisplayed()
}</code></pre>

<p>With this pieced together, we now have a test that:</p>

<ul>
	<li>Uses the<code>EmailInbox</code> composable to set the UI to be displayed on the screen</li>
	<li>Locates a node within our composable UI, using a String from our application resources</li>
	<li>Asserts that the retrieved node is displayed within our UI</li>
</ul>

<p>If you run this test within your IDE, you’ll not only see the UI spin up inside of the connected device / emulator, but the tests should also be passing due to the required string being composed within the UI.</p>

<h3>Testing the Loading State</h3>

<p>With the title of our composable being tested, we’re now going to assert that the expected composables are displayed when the <code>status</code> property of our <code>InboxState</code> represents the <code>InboxStatus.LOADING</code> value. We’re going to start here by creating a new test and composing the <code>EmailInbox</code>, providing a reference to the <code>InboxState</code> class that has the <code>LOADING</code> for its <code>status</code> property.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Loading_State_Displayed</span>() {
	composeTestRule.<span class="syntax-all syntax-constant">run</span> {
		setContent {
			<span class="syntax-all syntax-entity">EmailInbox</span>(
				inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
					status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>
				)
			) { }
        }
    }
}</code></pre>

<p>Here we use the kotlin <code>run</code> scope function - this is because we are going to be performing multiple operations against our test rule reference, so this simplifies things by removing the need for us to use <code>.</code> notation for every call that we wish to make. This means that now, we can utilise multiple <code>onNodeWithTag</code> function calls inside of this <code>run</code> block. Before we can do that though, we need to be able to locate those nodes.</p>

<p>With this test, we’re going to want to check a couple of different composable states for when the <code>InboxStatus.LOADING</code> <code>status</code> is applied.</p>

<ul>
	<li>Assert that the loading composable is displayed</li>
	<li>Assert that the email list does not exist</li>
	<li>Assert that the empty state does not exist</li>
	<li>Assert that the error state does not exist</li>
</ul>

<p>So that we can perform assertions for these different states, we’re going to need to be able to locate it. Unlike the previous test where we used text values to locate nodes within our composable UI, we don’t care for the nested details within the composables that we’re going to check for here. For this reason, we’re going to need to apply some tags to these composables, these tags can then be used to locate our composable within our tests. We’ll need to start here by defining some tag references that can be accessed from both our tests and our composable. These will live inside of a file called <code>Tags.kt</code></p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CONTENT</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;content&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PROGRESS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;progress&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_EMPTY</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;empty&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_ERROR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;error&quot;</span>
}</code></pre>

<p>With these tags defined, we’ll need to assign them to our composables - this assignment means that we can then retrieve nodes in our UI that have the corresponding tag. We’ll do this by utilising the <code>testTag</code> modifier to assign our tags - starting with the <code>Loading</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Loading.kt
</span>
<span class="syntax-all syntax-entity">CircularProgressIndicator</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_PROGRESS</span>)
)</code></pre>

<p>When this <code>testTag</code> modifier is applied, the provided tag is set as a semantic property on the node. This is not visible to users but will be used by testing and accessibility services to locate composables via a tag identifier.</p>

<p>Similar to how we’ve applied the corresponding tag to the <code>Loading</code> composable, we’ll need to do the same for the parent nodes within the <code>EmptyState</code>, <code>ErrorState</code> and <code>EmailList</code> composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// EmptyState.kt
</span>
<span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_EMPTY</span>),
	horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
)</code></pre>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ErrorState.kt
</span>
<span class="syntax-all syntax-entity">Column</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_ERROR</span>),
	horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
)</code></pre>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// EmailList.kt
</span>
<span class="syntax-all syntax-entity">LazyColumn</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
)</code></pre>

<p>Now that our composables have tags assigned to them, we can now use the <code>onNodeWithTag</code> function within our tests to locate the composable whose tag matches the requested tag. This operates in the same way that the previously used <code>onNodeWithText</code> function operates, but by using a tag instead of textual content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Loading_State_Displayed</span>() {
	composeTestRule.<span class="syntax-all syntax-constant">run</span> {
		setContent {
			<span class="syntax-all syntax-entity">EmailInbox</span>(
				inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
					status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>)
			) { }
        }
            
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PROGRESS</span>)
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_ERROR</span>)
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_EMPTY</span>)
    }
}</code></pre>

<p>Now that these tags are in place, we can locate the node to perform assertions on. To perform these assertions we’re going to need to use a variety of assertion functions to test the different scenarios that we previously defined. Because in this case the progress composable should be displayed, we’ll utilise the <code>assertIsDisplayed</code> which is a <code>SemanticsNodeInteraction</code> extension function. This assertion will check whether the bounds of the composable are currently visible, which would be expected of the <code>Loading</code> composable when the loading state is in place.</p>

<p>Alongside this, we’ll also want to assert that the other three composables do not exist within our composition - this is because when the <code>Loading</code> composable is displayed, none of the other composables should exist. While there is an <code>assertIsNotDisplayed</code> assertion function, we don’t even want the remaining composable to exist in our composable hierarchy. For this reason, we’ll utilise the <code>assertDoesNotExist</code> function on each of the remaining nodes.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Loading_State_Displayed</span>() {
	composeTestRule.<span class="syntax-all syntax-constant">run</span> {
		setContent {
			<span class="syntax-all syntax-entity">EmailInbox</span>(
				inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
					status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>)
			) { }
        }
            
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PROGRESS</span>).assertIsDisplayed()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>).assertDoesNotExist()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_ERROR</span>).assertDoesNotExist()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_EMPTY</span>).assertDoesNotExist()
    }
}</code></pre>

<p>💡 When you are expecting a composable to have not been composed, use the assertDoesNotExist. This behaves different from assertIsNotDisplayed, as that function is focused on the visibility of the composable rather than the presence within the hierarchy. </p>

<h3>Testing the Empty State</h3>

<p>Now that we’re testing the loading state of our composable, we’re going to test the next scenario - the state where the email inbox is empty. This is going to look very similar to the previous test that we wrote for the loading state - the difference here is that we’re going to start bypassing the <code>InboxStatus.EMPTY</code> value for the <code>status</code> of the <code>InboxState</code> that we provide to the composable.</p>

<p>We’re also going to tweak the assertions that are being performed. In this scenario we are expecting that:</p>

<ul>
	<li>Assert that the empty composable is displayed</li>
	<li>Assert that the email list composable does not exist</li>
	<li>Assert that the loading composable does not exist</li>
	<li>Assert that the error composable does not exist</li>
</ul>

<p>With those expectations in mind, we can represent this via the following assertions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_State_Displayed</span>() {
    composeTestRule.<span class="syntax-all syntax-constant">run</span> {
        setContent {
            <span class="syntax-all syntax-entity">EmailInbox</span>(
                inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
					status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">EMPTY</span>
				),
                handleEvent <span class="syntax-all syntax-keyword">=</span> { }
            )
        }
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PROGRESS</span>).assertDoesNotExist()
   	    onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>).assertDoesNotExist()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_ERROR</span>).assertDoesNotExist()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_EMPTY</span>).assertIsDisplayed()
    }
}</code></pre>

<h3>Testing the Error State</h3>

<p>Next, we’re going to test the state where an error has occurred while loading the email inbox. This is going to look very similar to the previous test that we’ve written here - the difference is that we’re going to start bypassing the <code>InboxStatus.ERROR</code> value for the <code>status</code> of the <code>InboxState</code> that we provide to the composable.</p>

<p>We’re also going to tweak the assertions that are being performed. In this scenario we are expecting that:</p>

<ul>
	<li>Assert that the error composable is displayed</li>
	<li>Assert that the email list composable does not exist</li>
	<li>Assert that the loading composable does not exist</li>
	<li>Assert that the empty composable does not exist</li>
</ul>

<p>With those expectations in mind, we can represent this via the following assertions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Error_State_Displayed</span>() {
    composeTestRule.<span class="syntax-all syntax-constant">run</span> {
        setContent {
            <span class="syntax-all syntax-entity">EmailInbox</span>(
                inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
					status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">ERROR</span>
				),
                handleEvent <span class="syntax-all syntax-keyword">=</span> { }
            )
        }
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PROGRESS</span>).assertDoesNotExist()
   	    onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>).assertDoesNotExist()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_ERROR</span>).assertIsDisplayed()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_EMPTY</span>).assertDoesNotExist()
    }
}</code></pre>

<h3>Testing the Content State</h3>

<p>Last up, we’re going to test the state where content has loaded for the email inbox. This is going to look very similar to the previous tests that we’ve written here - the difference is that we’re going to start bypassing the <code>InboxStatus.SUCCESS</code> value for the <code>status</code> of the <code>InboxState</code> that we provide to the composable.</p>

<p>We’re also going to tweak the assertions that are being performed. In this scenario we are expecting that:</p>

<ul>
	<li>Assert that the content composable is displayed</li>
	<li>Assert that the error composable does not exist</li>
	<li>Assert that the loading composable does not exist</li>
	<li>Assert that the empty composable does not exist</li>
</ul>

<p>With those expectations in mind, we can represent this via the following assertions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_State_Displayed</span>() {
    composeTestRule.<span class="syntax-all syntax-constant">run</span> {
        setContent {
            <span class="syntax-all syntax-entity">EmailInbox</span>(
				inboxState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxState</span>(
					status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">InboxStatus</span>.<span class="syntax-all syntax-entity">SUCCESS</span>
				),
                handleEvent <span class="syntax-all syntax-keyword">=</span> { }
            )
        }
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PROGRESS</span>).assertDoesNotExist()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>).assertIsDisplayed()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_ERROR</span>).assertDoesNotExist()
        onNodeWithTag(<span class="syntax-all syntax-entity">TAG_EMPTY</span>).assertDoesNotExist()
    }
}</code></pre>

<p>With these different state-related tests in place, we’re now able to have confidence that the expected composition takes place based on the <code>status</code> value within the provided <code>InboxState</code>.</p>

<hr />

<h2>Testing Item Dismissal</h2>

<p>Now that we’ve covered the different states that can be represented with our <code>EmailInbox</code> composable, we’re going to write a couple of higher-level tests for the <code>Inbox</code> composable. What makes this different from our lower level composables (such as the empty state or email inbox), is that this composable is our argument less constructor - meaning that from our tests we can trigger state updates and recomposition of our UI. This means that with the tests for the <code>Inbox</code> composable we can assert that interactions with it result in the expected state changes. For these tests, we’re going to focus on the dismissal of the email items within the inbox.</p>

<p>For the first test we’re going to assert that when an item is dismissed from the inbox (as in, when it is swiped away), the list represents that an item has been removed. Within this test, we’re not going to care exactly what item is dismissed (that will be for tests within the lower level composable), just that the list count has been updated to reflect the state change. We’re going to need to start here by composing the <code>Inbox</code> inside of a new test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Item_Dismissed_When_Swiped</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Inbox</span>()
    }
}</code></pre>

<p>Next, we’re going to want to trigger the dismissal of an item within the inbox. When this happens, the item will be removed from our state (through the ViewModel) and the list will be updated to reflect that change. First, though, we’ll need to swipe away an item from our list. Within our test, this is going to involve a couple of steps.</p>

<ul>
	<li>We’ll first need to find the node that represents the email list. Here we’ll utilise the <code>onNodeWithTag</code> function, using the previously defined <code>TAG_CONTENT</code> to locate our composable.</li>
	<li>Next, we’ll need to perform a swipe interaction with a child from the node that we’ve just located. Here we can use the <code>onChildAt</code> function that will return us a single <code>SemanticsNode</code> that we can perform assertions and interactions on.</li>
	<li>Now that we have this child reference, we can now perform our swipe interaction. For this we’ll use the <code>performTouchInput</code> - within the block of this function, we can perform any actions that are scoped by <code>TouchInjectionScope</code>. Within this scope, the <code>swipeRight</code> function is available - this allows us to perform a right swipe gesture on the child node that we’ve located.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Item_Dismissed_When_Swiped</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Inbox</span>()
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
    	.onChildAt(<span class="syntax-all syntax-constant">0</span>)
        .performTouchInput {
            swipeRight()
        }
}</code></pre>

<p>Next, we’ll need to assert that the size of the email list has changed based on our previous interaction. When our state is initialised, we use <code>EmailFactory.makeContentList()</code> to load up a default set of emails into the inbox. Here we’re going to want to assert that the count of our list is now 1 item smaller than when it was initialised.</p>

<p>Here we’ll again use the <code>onNodeWithTag</code> function to retrieve the node that represents our content list, using the <code>TAG_CONTENT</code> tag. This node will again represent the list of emails that are being composed, so we’ll want to retrieve the children that are making up this list. Using the <code>onChildren</code> function, this will give us a <code>SemanticsNodeInteractionCollection</code> that represents the list of nodes that makes up the composable. With this collection available, we can now perform an assertion on the expected size. When an item has been dismissed, this size is going to be 1 item less than the initially created email list - so we can use the <code>assertCountEquals</code> function to assert this.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Item_Dismissed_When_Swiped</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Inbox</span>()
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
        .onChildAt(<span class="syntax-all syntax-constant">0</span>)
        .performTouchInput {
            swipeRight()
        }

	<span class="syntax-all syntax-keyword">val</span> emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
        .onChildren()
        .assertCountEquals(emails.count() <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">1</span>)
}</code></pre>

<p>Aside from the dismissal of items, we’re also going to check that all of the items which <strong>shouldn’t</strong> have been dismissed are still in place - this allows us to assert that only the swiped item has been removed. We’ll start by writing a new test, composing the <code>Inbox</code> for the test content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Remaining_Items_Displayed_When_Another_Dismissed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Inbox</span>()
    }
}</code></pre>

<p>Within this test we’re again going to want to swipe an email item from the list, this means that we’ll be able to perform the assertion that the email list contains the remaining items from the list. As we did in the previous test, we’ll perform the <code>swipeRight</code> action on the first item within the email list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Remaining_Items_Displayed_When_Another_Dismissed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Inbox</span>()
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
        .onChildAt(<span class="syntax-all syntax-constant">0</span>)
        .performTouchInput {
            swipeRight()
        }
}</code></pre>

<p>Next, we’re going to need to take the items that are in the email, aside from the first one (as we dismissed that above), and assert that they are still in place within the list. The above test asserts that the count of the emails is one less than the initialised list, this test will assert that those items represent the expected emails.</p>

<p>Here we’re going to start by using the <code>takeLast</code> operation to take the last N items of our list - we will want this to be all items <strong>except</strong> for the first one. For each item within this collection, we’re going to want to check that it matches the expected content. For this we’re going to assign a new tag to each email item so that we can easily assert this within our tests - for this we’ll need to start by adding a new tag that can be applied to our composable. For this tag we’re going to end this with an underscore character, allowing us to append the id of an email, creating a unique tag for each email item within the list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_EMAIL</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;email_&quot;</span>
}</code></pre>

<p>With this tag defined, we can now assign this to the dismissible email item. Here we’ll utilise the <code>testTag</code> modifier to apply the tag to the composable - for this we’ll use the <code>TAG_EMAIL</code> tag, appending the id of the corresponding email to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// EmailList.kt
</span>
<span class="syntax-all syntax-entity">SwipeToDismiss</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.semantics {
        	...
        }
        .testTag(<span class="syntax-all syntax-entity">TAG_EMAIL</span> <span class="syntax-all syntax-keyword">+</span> email.id),
	...
)</code></pre>

<p>With this tag in place, we can now use this within our tests to perform interactions and assertions with the email items. While looping through the email items within the collection (apart from the first one, because that has been dismissed as per our previous test), we’re going to need to perform the following actions:</p>

<ul>
	<li>Using the <code>onNodeWithTag</code> function, locate the node that represents the list of emails using the <code>TAG_CONTENT</code> tag</li>
	<li>Retrieve the child node at the current index of the loop</li>
	<li>Trigger the <code>performScrollTo</code> function which will scroll to the child node that we’ve just located. This is to ensure that the composable is currently on view within the window</li>
	<li>Assert that the node has the expected tag that represents the id of the current email in our loop</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Remaining_Items_Displayed_When_Another_Dismissed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Inbox</span>()
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
        .onChildAt(<span class="syntax-all syntax-constant">0</span>)
        .performTouchInput {
            swipeRight()
        }

    <span class="syntax-all syntax-keyword">val</span> emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
    emails.takeLast(emails.count() <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">1</span>)
		.forEachIndexed { index, email <span class="syntax-all syntax-keyword">-&gt;</span>
        	composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
                .onChildAt(index)
                .performScrollTo()
                .<span class="syntax-all syntax-keyword">assert</span>(hasTestTag(<span class="syntax-all syntax-entity">TAG_EMAIL</span> <span class="syntax-all syntax-keyword">+</span> email.id))
    	}
}</code></pre>

<p>💡 The assert function allows us to provide a SemanticsMatcher that is used to perform the assertion. This is a lower-level function that is useful when you need to perform assertions on SemanticsNodeInteraction instances. </p>

<p>With this test in place, we are now asserting that each of the remaining items within the email list has the expected tag, represented by the id of the corresponding email.</p>

<hr />

<h2>Testing the Email List</h2>

<p>In the previous tests, we’ve looked at performing assertions on the email list based on the swipe dismissals that have been performed on the email list. For this section, we’re going to focus on testing the email list itself, based on the information that is provided to the composable function. We’ll set ourselves up here by creating a new test class, <code>EmailListTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">EmailListTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’re going to start here by writing a new test that will assert all of the expected email items are being displayed in the list. Within this test we’re going to need to start by composing an <code>EmailList</code>, passing in a collection of emails that are being created using our <code>EmailFactory</code>. We’ll need this variable reference so that we can soon perform assertions on our items.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Email_Items_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailList</span>(
            emails <span class="syntax-all syntax-keyword">=</span> emails,
            deleteEmail <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Now that the email list is being composed, we’re going to need to loop through each of the items in this list of emails, asserting that the expected composables are being displayed. This is going to look very similar to the previous test that we wrote for the swipe interactions. For each item within the list of emails we’ll need to:</p>

<ul>
	<li>Use the <code>onNodeWithTag</code> function to locate the node that represents the list of emails using the <code>TAG_CONTENT</code> tag</li>
	<li>Retrieve the child node at the current index of the loop</li>
	<li>Trigger the <code>performScrollTo</code> function which will scroll to the child node that we’ve just located. This is to ensure that the composable is currently on view within the window</li>
	<li>Assert that the node has the expected tag that represents the id of the current email in our loop</li>
</ul>

<p>The key difference here is that we are now doing this for all email items, instead of the expected state after a dismissal. We are testing this here to ensure that the <code>EmailList</code> is composing the expected list of emails - while the previous test for our <code>Inbox</code> composable was also testing a similar state (and we could also have had another test there), this allows us to keep this extra test case close to the composable that is implementing composable logic.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Email_Items_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailList</span>(
            emails <span class="syntax-all syntax-keyword">=</span> emails,
            deleteEmail <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    emails.forEachIndexed { index, email <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
            .onChildAt(index)
            .performScrollTo()
            .<span class="syntax-all syntax-keyword">assert</span>(hasTestTag(<span class="syntax-all syntax-entity">TAG_EMAIL</span> <span class="syntax-all syntax-keyword">+</span> email.id))
    }
}</code></pre>

<p>Now that we’ve been able to assert that all of the email items are being displayed, we’re going to want to test that the <code>deleteEmail</code> lambda is correctly called when expected. While we have a test previously written for the <code>Inbox</code> composable, these lower-level tests allow us to assert that the callback is triggered for the expected email <code>id</code>.</p>

<p>We’re going to start by writing a new test, composing the <code>EmailList</code>. Aside from passing a list of emails to the <code>emails</code> argument, we’ll also need to pass in a <code>mock</code> lambda function for the <code>deleteEmail</code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based on composable events.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Delete_Email_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
    <span class="syntax-all syntax-keyword">val</span> deleteEmail<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailList</span>(
            emails <span class="syntax-all syntax-keyword">=</span> emails,
            deleteEmail <span class="syntax-all syntax-keyword">=</span> deleteEmail
        )
    }
}</code></pre>

<p>Now the <code>EmailList</code> is being composed, we can add some logic that will be used to trigger the dismiss action on one of our email items. Similar to the swipe actions that we performed in previous tests, we’ll locate a specific child within the <code>TAG_CONTENT</code> node, followed by performing the <code>swipeRight</code> operation on it. You’ll notice here that we’re also keeping a reference to the index of the email item that we’re interacting with, <code>indexToDelete</code>. This is so that we can later use it in the following assertions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Delete_Email_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
    <span class="syntax-all syntax-keyword">val</span> deleteEmail<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> indexToDelete <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">2</span>

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailList</span>(
            emails <span class="syntax-all syntax-keyword">=</span> emails,
            deleteEmail <span class="syntax-all syntax-keyword">=</span> deleteEmail
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
        .onChildAt(indexToDelete)
        .performScrollTo()
        .performTouchInput {
            swipeRight()
        }
}</code></pre>

<p>With the swipe interaction now taking place, we can perform the assertion on our lambda function. We can verify this within our test by using mockito and its <code>verify</code> function to assert that the lambda has been invoked. If this is the case, the test will succeed - otherwise, the lambda not being triggered will mean that our verification will not be satisfied and the test will fail. When utilising <code>verify</code> here, we’re going to want to assert this using the <code>id</code> of the email item located at the index we defined for <code>indexToDelete</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Delete_Email_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
    <span class="syntax-all syntax-keyword">val</span> deleteEmail<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> indexToDelete <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">2</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailList</span>(
            emails <span class="syntax-all syntax-keyword">=</span> emails,
            deleteEmail <span class="syntax-all syntax-keyword">=</span> deleteEmail
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
        .onChildAt(indexToDelete)
        .performScrollTo()
        .performTouchInput {
            swipeRight()
        }
    verify(deleteEmail).invoke(emails[indexToDelete].id)
}</code></pre>

<p>If you run this test, you’ll notice that it won’t be passing. While we will be able to see in the automated test that the email item is swiped, you’ll notice that the dismissal is never triggered. The reason for this is because we have an animated <code>dp</code> value that animates based on the value of <code>isEmailItemVisible</code> - it is only once this animation completes that we trigger the <code>deleteEmail</code> callback.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> emailHeightAnimation by animateDpAsState(
	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isEmailItemVisible) {
		<span class="syntax-all syntax-constant">120</span>.dp
	} <span class="syntax-all syntax-keyword">else</span> {
		<span class="syntax-all syntax-constant">0</span>.dp
	},
	animationSpec <span class="syntax-all syntax-keyword">=</span> tween(delayMillis <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">300</span>),
	finishedListener <span class="syntax-all syntax-keyword">=</span> {
		deleteEmail(email.id)
	}
)</code></pre>

<p>But why is this an issue? Well, when the compose tests are run, our tests are run in synchronisation with the compose UI. The issue in this specific case is that it means our animation will not run through to the end, which means that the <code>finishedListener</code> callback will never be triggered. What we can do here is utilise our test rule to wait until the UI is in an idle state, meaning that the animation execution would have been completed and the <code>finishedListener</code> would be triggered.</p>

<pre><code class="code-highlighted code-kt">composeTestRule.waitForIdle()</code></pre>

<p>We can slot this into our test <strong>after</strong> the swipe interaction has been performed, waiting for the idle state before the verification of the <code>deleteEmail</code> takes place.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Delete_Email_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> emails <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">EmailFactory</span>.makeContentList()
    <span class="syntax-all syntax-keyword">val</span> deleteEmail<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> indexToDelete <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">2</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmailList</span>(
            emails <span class="syntax-all syntax-keyword">=</span> emails,
            deleteEmail <span class="syntax-all syntax-keyword">=</span> deleteEmail
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTENT</span>)
        .onChildAt(indexToDelete)
        .performScrollTo()
        .performTouchInput {
            swipeRight()
        }
    composeTestRule.waitForIdle()
    verify(deleteEmail).invoke(emails[indexToDelete].id)
}</code></pre>

<hr />

<h2>Testing the Empty State</h2>

<p>Now that we’ve got tests in place for the email content composable, we’re going to add a quick test for the empty state composable. Our empty composable contains an action that can be used to refresh the inbox, so we’ll want to assert that this is triggering the expected action. We’ll start here by creating a new test class with supporting rule.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">EmptyStateTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’ll now need to compose the <code>EmptyState</code>. This only takes a single argument, <code>onRefresh</code>, which takes the form of a lambda function. Here, we’ll pass in a <code>mock</code> lambda function for the <code>onRefresh</code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based on composable events.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Refresh_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onRefresh<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmptyState</span>(onRefresh <span class="syntax-all syntax-keyword">=</span> onRefresh)
    }
}</code></pre>

<p>With this in place, we now need to perform the action that will trigger the lambda function. The <code>EmptyState</code> is expected to contain an action that is using the <code>label_check_again</code> string resource, this is also what should trigger the refresh event when interacted with. Here, we’ll use the <code>performClick</code> function to click on the node after locating it used the expected string resource.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Refresh_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onRefresh<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmptyState</span>(onRefresh <span class="syntax-all syntax-keyword">=</span> onRefresh)
    }

    composeTestRule
        .onNodeWithText(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.targetContext
				.getString(<span class="syntax-all syntax-entity">R</span>.string.label_check_again)
		).performClick()
}</code></pre>

<p>With this in place, we can now use the <code>verify</code> function to assert that the <code>onRefresh</code> lambda has been invoked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Refresh_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onRefresh<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmptyState</span>(onRefresh <span class="syntax-all syntax-keyword">=</span> onRefresh)
    }

    composeTestRule
        .onNodeWithText(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.targetContext
				.getString(<span class="syntax-all syntax-entity">R</span>.string.label_check_again)
		).performClick()

    verify(onRefresh).invoke()
}</code></pre>

<hr />

<h2>Testing the Error State</h2>

<p>To wrap up our testing work, we’re going to next test the error state composable. Our error composable contains an action that can be used to refresh the inbox after an error has occurred, so we’ll want to assert that this is triggering the expected action. We’ll start here by creating a new test class with supporting rule. This test is going to look almost the same as the previous test we wrote for the <code>EmptyState</code> composable, except here we compose the <code>ErrorState</code> and use the <code>label_try_again</code> resource for the node interaction.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ErrorStateTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

	<span class="syntax-all syntax-keyword">@Test
</span>	<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Refresh_Triggered</span>() {
    	<span class="syntax-all syntax-keyword">val</span> onRefresh<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    	composeTestRule.setContent {
        	<span class="syntax-all syntax-entity">ErrorState</span>(onRefresh <span class="syntax-all syntax-keyword">=</span> onRefresh)
    	}

    	composeTestRule
			.onNodeWithText(
        		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
					.targetContext.getString(
						<span class="syntax-all syntax-entity">R</span>.string.label_try_again)
        	).performClick()

    	verify(onRefresh).invoke()
	}
}</code></pre>

<hr />

<p>With all of these tests in place, we’ve covered a lot of different cases that help to ensure our UI is working as expected. We’ve not only tested that composables are being composed based on the information that they are provided with, but also that they triggered the expected callbacks and trigger state manipulations within our composables. While the tests here aren’t extensive, we’ve been able to learn not only what options are available to us while testing composables, but also the approaches that we can take when doing so.</p>

<h1>Building a Video Player</h1>

<p>When working on Android projects, we’re likely going to be defaulting to using Jetpack Compose when building UI. While that may be the case, it might not always be possible. For example, we may have existing classes that are written using the Android View system, which might not make sense for us to convert to compose at this time. There might also be some things built in the Android View system that just isn’t supported by Jetpack Compose yet.</p>

<p>Whatever the reason, we’re bound to find ourselves in scenarios where we either need to or it makes sense for us to use Android View system components. For these situations, Jetpack Compose has several interoperability features that allow us to use Composable UI inside of existing Android Layouts, as well as tools for using Android View classes inside of Composable UI. In this chapter, we’re going to utilise some of these features to create a Video Player that uses a mixture of Jetpack Compose concepts and Android View classes.</p>

<figure><img src="video.png"/></figure>

<p>When it comes to building out this screen, over the rest of the chapter we’re going to be tackling a collection of tasks:</p>

<ul>
	<li>Build out a Video player that streams a video from a given URL</li>
	<li>Use interoperability features to utilise existing Android Views inside of a composable UI</li>
	<li>Create controls that allow the status of the video player to be managed</li>
	<li>Use animations to handle the display of the video player controls, allowing them to be auto-dismissed when not being interacted with</li>
	<li>Define a manageable state that will be used to control how the UI is composed</li>
	<li>Utilise Side Effects to manage the state of the video player based on external constraints</li>
</ul>

<p>Once all of the above is complete, we’ll have a working Video Player implementation. We’ll have a video being displayed and played using an Android View class, with the controls and state-defined using Jetpack Compose.</p>

<h1>Defining the Video player State</h1>

<p>Within our Video Player, we’re going to be dealing with a couple of different pieces of state that depict how the UI is going to be displayed to the user. There’s not going to be too many different scenarios that the screen is going to be in, but these different states will be represented in the following forms:</p>

<ul>
	<li>A video that will automatically be played once it has finished loading</li>
	<li>An error state that is displayed when the video fails to load</li>
	<li>A control bar that:

		<ul>
			<li>will only be enabled once the video has finished loading</li>
			<li>will allow the user to either Play or Pause the video</li>
			<li>will dismiss once it is no longer being interacted with</li>
		</ul></li>
</ul>

<p>With the above set out, we can start to see that there are going to be several pieces of state that we need to hold. With that in mind, let’s start to take the above statements and build a class that will represent the state of our composable UI. We’ll start by creating a new class:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">VideoState</span>()</code></pre>

<p>With the scenarios stated above, we’re going to need to handle a couple of states that the screen can represent. </p>

<hr />

<h2>Playback State</h2>

<p>We’re going to start by adding a definition for the current state of the video player - this will tell our UI whether the video is current loading, or if it is in another state that can be controlled via the video player controls. To help keep our <code>VideoState</code> class simple, we’re going to represent this state using an enum class - this not only adds better clarity to the current state of our player, but it helps us to avoid using a collection of boolean flags (or other means) to represent this part of our state. To tackle this we’ll create a new enum class called <code>PlayerStatus</code> and populate it with some values that it can represent.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PlayerStatus</span> {
    <span class="syntax-all syntax-entity">PLAYING</span>, <span class="syntax-all syntax-entity">PAUSED</span>, <span class="syntax-all syntax-entity">LOADING</span>, <span class="syntax-all syntax-entity">IDLE</span>, <span class="syntax-all syntax-entity">ERROR</span>
}</code></pre>

<p>For our <code>PlayerStatus</code> we’ve defined five different values which can be represented, these are:</p>

<ul>
	<li><strong>Playing</strong>: The video is currently being played</li>
	<li><strong>Paused</strong>: The video playback is currently paused</li>
	<li><strong>Loading</strong>: The video is currently being loaded, meaning it is not ready to play yet</li>
	<li><strong>Idle</strong>: The video has been loaded but is not currently in a playback state</li>
	<li><strong>Error</strong> - The video has failed to load</li>
</ul>

<p>With this in place, we can then go ahead and add this to our state class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">VideoState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>
)</code></pre>

<p>Now when composing our UI, we can perform composition using this state - meaning our UI can now react to changes on the PlayerStatus, such as when it moves from <strong>PLAYING</strong> to <strong>PAUSED</strong>. When the video player is launched, we’re going to do need to load the video - so by default, our player will always need to start in the loading state. For that reason, we’ll give our playerStatus variable a default value of <strong>LOADING</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">VideoState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>
)</code></pre>

<hr />

<p>For now, that is the only state that our screen state is going to hold. If you wish to simplify things, you can remove the use of the data class and directly access a <code>PlayerStatus</code> reference. If you wish to build on this feature and add to the state, then this VideoState class gives you a good starting point to do so!</p>

<h1>Creating the Video Player View Model</h1>

<p>Now that we have the state modelled for our video player, we can start thinking about the ViewModel that will be used to manage that state and provide a way to orchestrate it to the user interface. </p>

<hr />

<h2>Setting up the ViewModel</h2>

<p>While we don’t have a complex state setup for our video player, there is going to be a small amount of logic that will be used to manipulate this. For this reason, it’ll be helpful for us to have a ViewModel that can encapsulate this logic from our User Interface. We’ll start by creating a new ViewModel class for our Video Player:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">VideoViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

}</code></pre>

<p>So that we can orchestrate state to our User Interface, we’ll need to define a data stream that allows for subscription to state changes. For this, we’ll go ahead and define a global <code>MutableStateFlow</code> reference that can be used to emit state events, as well as observed by our UI layer.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">VideoViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    <span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">VideoState</span>())

}</code></pre>

<p>With this in place, we have a state stream that will emit a default state of our VideoState class. When we created this state class we configured the <code>playerStatus</code> with a default value, <code>LOADING</code> - this means that currently the UI will always be composed as if our video was always loading. To resolve this, we’ll need to go ahead and configure some state change logic within our ViewModel so that this <code>playerStatus</code> can be configured based on the events that occur within our video player.</p>

<hr />

<h2>Handling Video Player Events</h2>

<p>From our User Interface, we’re going to want to manipulate the state that has been configured within our ViewModel - this is going to be specifically whenever the <code>PlayerStatus</code> is changed. This will be either when:</p>

<ul>
	<li>The status is manually toggled by the user</li>
	<li>The video has finished loading and is ready to play</li>
	<li>The video has failed to load and cannot be played</li>
</ul>

<p>So that we have these represented by some form of model (as well as leave some room for future event additions), we’re going to define a new sealed class, <code>VideoEvent</code>. This class will be used to define the different events that can be triggered from our UI:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">VideoEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> ToggleStatus<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> VideoLoaded<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>()

	<span class="syntax-all syntax-keyword">object</span> VideoError<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>()

}</code></pre>

<p>With these now defined, we need to have our ViewModel handle these, configuring the state based on the event that has been triggered. To receive these events from our UI layer, we’ll go ahead and add a new function to our ViewModel, <code>handleEvent</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">videoEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>) {

}</code></pre>

<h3>Handle Video Loading</h3>

<p>We’ll start by handling the <code>VideoLoaded</code> event - when this is triggered we want to update our <code>playerStatus</code> to reflect this event from our UI, signifying that the video has been loaded is ready to be played. We’ll add a new <code>when</code> block to our function and start by handling the <code>VideoLoaded</code> event. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">videoEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>) {
	<span class="syntax-all syntax-keyword">when</span> (videoEvent) {
		<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">VideoLoaded</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
			uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
				playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">IDLE</span>
			)
		}
	}
}</code></pre>

<p>When this event occurs, we’re going to want to update the value of our <code>uiState</code> reference to reflect that the video is ready to play. Here, we’ll use the <code>copy</code> function on our existing state value, assigning a new value to the <code>playerStatus</code> property. Now that the video has finished loading, we’ll assign this value as <code>IDLE</code> so that any observers to our state know that the video player is no longer in the <code>LOADING</code> state.</p>

<h3>Handle Video Errors</h3>

<p>Sometimes the loading of the video won’t go quite as planned, and in these cases, we’re going to want to make sure we portray the error to the user. To be able to do so, this is going to need to be reflected within our state object - we already have the <code>VideoError</code> class type, so we’re going to modify our <code>handleEvent</code> function to handle this kind of event. When this occurs we’ll need to modify our <code>VideoState</code> reference so that the <code>playerStatus</code> reflects an error state, which we can do so using the <code>PlayerStatus.ERROR</code> type.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">videoEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>) {
	<span class="syntax-all syntax-keyword">when</span> (videoEvent) {
		...
		<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">VideoError</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
        	uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
            	playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">ERROR</span>
            )
        }
	}
}</code></pre>

<p>Now whenever the error event is triggered from our UI, our view model will be able to have this reflected within our <code>VideoState</code> - meaning that our UI will be able to portray this state to the user when recomposed.</p>

<h3>Handle Video Playback</h3>

<p>Alongside the loading and error events, our <code>VideoState</code> can represent the current playback status of the video in the form of Playing or Paused. When the user interacts with the playback state from the UI, we’re going to want to toggle the current state so that it represents the opposite of the current set value. For this, we’ll create a new function, <code>togglePlayerStatus</code>, that will be used to switch between the Playing and Paused states.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">togglePlayerStatus</span>() {
	
}</code></pre>

<p>In this function, we’re going to need to write a small bit of logic that switches between the Playing and Paused state. To put this in place we’ll need to:</p>

<ul>
	<li>Get the current <code>PlayerStatus</code> value</li>
	<li>Calculate the new <code>PlayerStatus</code> value based on the current one</li>
	<li>Set the new <code>PlayerStatus</code> value to our <code>VideoState</code></li>
</ul>

<p>For the first point, we’ll simply begin by using our state reference to retrieve the current value of our <code>playerStatus</code> property:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> playerStatus <span class="syntax-all syntax-keyword">=</span> uiState.value.playerStatus</code></pre>

<p>Next, we’ll use this value to define a new <code>PlayerStatus</code> reference. Because we’re only currently flipping between the Playing and Paused state we can keep this simple for now. So if our current reference does not indicate a Playing state then we’ll toggle our state to be Playing, otherwise, we’ll mark the <code>playerStatus</code> as being Paused.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> newPlayerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
	playerStatus <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>
) {
	<span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>
} <span class="syntax-all syntax-keyword">else</span> {
    <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>
}</code></pre>

<p>Finally, we’ll take the above and use it to assign our new <code>PlayerStatus</code> value to our <code>VideoState</code> reference:</p>

<pre><code class="code-highlighted code-kt">uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
	playerStatus <span class="syntax-all syntax-keyword">=</span> newPlayerStatus
)</code></pre>

<p>With all the above in place, we can piece them together into our <code>togglePlayerStatus</code> function to give us something that looks like so:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">togglePlayerStatus</span>() {
	<span class="syntax-all syntax-keyword">val</span> playerStatus <span class="syntax-all syntax-keyword">=</span> uiState.value.playerStatus
	<span class="syntax-all syntax-keyword">val</span> newPlayerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
		playerStatus <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>
	) {
        <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>
    }
	uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
		playerStatus <span class="syntax-all syntax-keyword">=</span> newPlayerStatus
	)
}</code></pre>

<p>With this function now implemented, we can trigger it whenever the <code>ToggleStatus</code> event is triggered from our UI. Within our <code>handleEvent</code> function we’ll go ahead and call our new <code>togglePlayerStatus()</code> function whenever the <code>ToggleStatus</code> event is triggered.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">videoEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>) {
	<span class="syntax-all syntax-keyword">when</span> (videoEvent) {
		...
		<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">ToggleStatus</span> <span class="syntax-all syntax-keyword">-&gt;</span> togglePlayerStatus()
	}
}</code></pre>

<p>With this in place, our user can now toggle between the Playing and Paused <code>PlayerStatus</code> values, allowing the playback state to be reflected within our UI.</p>

<hr />

<h1>Creating the Video Player UI</h1>

<p>With the view model and state management all in place, we’re ready to move on and start implementing the composable UI for our View Player. </p>

<figure><img src="intro-5.png"/></figure>

<p>When we’re finished building this UI, we’re going to end up with something that looks like the following:</p>

<figure><img src="video-1.png"/></figure>

<p>This UI will allow our users to view a full-screen video experience from within our app, while also providing some minimal management to control the playback of the video. While building this UI we’ll dive into several compose topics - one of the main things for this project being interoperability between the Android View System and Composable UI. We’ll also touch on foundational concepts for Jetpack Compose apps, as well as some animation and accessibility focused topics. With that said, let’s get building!</p>

<hr />

<h2>Adding the internet permission</h2>

<p>We’re going to be loading a video from the internet, so we’ll need to add the <code>INTERNET</code> permission to our manifest file. This can be placed above the <code>application</code> tag within the manifest file for the module.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">uses-permission</span> <span class="syntax-all syntax-entity">android:name</span>=<span class="syntax-all syntax-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</code></pre>

<hr />

<h2>Setting up the Video Player UI</h2>

<p>To start, we’re going to begin by building a root composable function, <code>VideoPlayer</code> that will be used to house all of our Composable UI for the Video Player. For this, we’ll create a new Kotlin file called <code>VideoPlayer.kt</code> (to keep our composables nicely organised), followed by creating a new composable function, <code>VideoPlayer</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// VideoPlayer.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">VideoPlayer</span>() {

}</code></pre>

<p>At this point, our <code>VideoPlayer</code> composable isn’t going to be able to do too much. In previous sections, we spent some time defining our <code>VideoState</code> reference, along with some details in our <code>VideoViewModel</code> that enable the orchestration of data between our ViewModel and UI. So that we can eventually plugin our <code>VideoPlayer</code> to these details, we’re going to add arguments to our composable:</p>

<ul>
	<li>We’ll add a <code>VideoState</code> reference so that the state from our ViewModel can be passed into this composable function. That way, our UI can be composed based on the state coming from our ViewModel reference.</li>
	<li>We’ll add an event callback, allowing us to pass up the event for the parent composable to handle. This allows us to avoid passing a direct reference to our ViewModel into the composable function - simplifying things when we come to writing tests for our composables.</li>
</ul>

<p>With the above said, we end up with something that looks like the following, our <code>VideoPlayer</code> composable with a <code>VideoState</code> reference and event callback:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">VideoPlayer</span>(
    <span class="syntax-all syntax-parameter">videoState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {

}</code></pre>

<p>With this in place, we have a composable function that can be used to compose the UI for our video player, but this isn’t something that could easily act as an entry point to our player. For example, if we wanted to navigate to this composable in our app, we’d need to provide both a <code>VideoState</code> reference and an event callback - I imagine you might also want to be testing your composable as we work through this chapter! Before we go any further here, we’ll go ahead and create an entry-point composable for our screen. Here, we’ll go ahead and create a new <code>Video</code> composable inside of a new Kotlin file, <code>Video.kt</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Video.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Video</span>() {

}</code></pre>

<p>Because this composable doesn’t require any arguments, it makes its contents encapsulated - allowing us to launch this from anywhere in our app without needing to worry about any of its requirements. While you won’t see anything visual just yet, you’ll want to compose this <code>Video</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Video</code> when running the project.</p>

<p>This entry point is going to need to compose the previous composable that we defined, <code>VideoPlayer</code>, which we can go ahead and add into our composable function:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Video</span>() {
    <span class="syntax-all syntax-entity">VideoPlayer</span>(
        videoState <span class="syntax-all syntax-keyword">=</span> ...,
        handleEvent <span class="syntax-all syntax-keyword">=</span> ...
    )
}</code></pre>

<p>But at this point, you might notice that things aren’t going to compile - this is because our <code>VideoPlayer</code> composable required a <code>VideoState</code> reference and event callback. To be able to provide these, we’re going to need a reference to our <code>VideoViewModel</code>. To make things easier for us here, we’ll need to add the <code>lifecycle-viewmodel-compose</code> dependency project. This will allow us to retrieve an instance of the desired ViewModel, creating one if it does not currently exist. </p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:1.0.0-alpha07&quot;</span></code></pre>

<p>With this in place we can now retrieve a reference to our ViewModel using the provided <code>viewModel()</code> function:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Video</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()

    <span class="syntax-all syntax-entity">VideoPlayer</span>(
        videoState <span class="syntax-all syntax-keyword">=</span> ...,
        handleEvent <span class="syntax-all syntax-keyword">=</span> ...
    )
}</code></pre>

<p>Now that we have access to our<code>VideoViewModel</code> we can provide the required properties to our <code>VideoPlayer</code> composable.</p>

<p>For our <code>VideoState</code> reference we’re going to use the <code>collectAsState()</code> function on our state Flow reference - this allows us to observe our data stream as a composable state object. This means that while we’ll receive updates to our state object, we’ll receive them as composable state - meaning that our UI can be recomposed whenever that state change is received. We don’t want to pass the State&lt;VideoState&gt; reference directly into our <code>VideoPlayer</code> composable, so instead we’ll use the <code>value</code> of this state reference which will give us the contained value of our <code>State</code>, <code>VideoState</code>.</p>

<p>For our event handler, we can pass a reference to the handleEvent function that we created within our <code>VideoViewModel</code>. We’ll do this in the form of <code>viewModel::handleEvent</code>, meaning that our <code>VideoPlayer</code> composable now has a reference to an event handler that can be triggered whenever events occur within our Composable UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Video</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()

    <span class="syntax-all syntax-entity">VideoPlayer</span>(
        videoState <span class="syntax-all syntax-keyword">=</span> viewModel.uiState.collectAsState().value,
        handleEvent <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::handleEvent
    )
}</code></pre>

<p>At this point we now have two composable functions:</p>

<ul>
	<li>A <code>Video</code> composable that can be used as an entry point to our Video Player, not requiring any arguments to be composed</li>
	<li>A <code>VideoPlayer</code> composable that takes the provided <code>VideoState</code> and composes UI based on the current state representation</li>
</ul>

<p>Together these two composables provide us with a way to launch our Video Player and compose the UI for it based on the current state. With those in place, we can move on to creating the UI components that represent our Video Player.</p>

<hr />

<h2>Setting up ExoPlayer</h2>

<p>So that we can play videos in our app, we’re going to need a component that allows us to support media playback. That’s a lot of work to build ourselves, so we’re going to rely on existing implementations - there’s just one problem, there isn’t a composable that supports media playback. But that’s OK because Jetpack Compose contains interoperability APIs that allow us to use existing Android View classes inside of composable functions. This means that we can use existing media player implementations inside of our video screen, which we will do so using ExoPlayer.</p>

<p>If you haven’t used ExoPlayer before, that’s OK - we’re not going to deep dive into what it provides, we’ll just touch the surface and get a video playing with it. ExoPlayer is built by Google and is a pretty stable media solution, so it’s a great tool to be aware of! Before we can start, we’ll need to add two dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">implementation 
	<span class="syntax-all syntax-string">&quot;com.google.android.exoplayer:exoplayercore:$exoplayer_version&quot;</span>
implementation 
	<span class="syntax-all syntax-string">&quot;com.google.android.exoplayer:exoplayer-ui:$exoplayer_version&quot;</span></code></pre>

<p>Exoplayer-core contains the core offerings of the library, while exoplayer-ui contains the visual components that we need for video playback. We have these added to our project we can start to think about how we can slot in media playback functionality. In the last section we created the <code>VideoPlayer</code> composable, so let’s head back over to that composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">VideoPlayer</span>(
    <span class="syntax-all syntax-parameter">videoState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {

}</code></pre>

<p>We’re going to create a separate composable in the following section that will be responsible for the actual video playback, but what we want to do before then is setup the driver for that video playback - this is the class that will be responsible for the configuration of the video we are playing. This is because we want to keep this outside of our actual player implementation, decoupling the configuration details and allowing that composable to just focus on displaying the media, rather than having to configure it also.</p>

<p>We’ll start here by creating a new <strong>remember</strong> block, using the name <code>exoPlayer</code>. This is used so that the created value can be stored during composition, reused across recompositions - avoiding the ExoPlayer being recreated every single time. Because we are going to be using the same URL for the entire video player, we don’t need to reconfigure the player in any way.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> exoPlayer <span class="syntax-all syntax-keyword">=</span> remember {

}</code></pre>

<p>Next, we’re going to define a new <strong>MediaItem</strong>. In ExoPlayer, this represents the media that is t be loaded up into our player reference. We’re going to create a <strong>MediaItem</strong> using its <code>fromUri</code> function, providing a URL of a video to be loaded. For this we’re going to use a URL pointing to the famous Big Bunny video - you may have seen this video before, it’s used for a lot of open-source project examples.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> exoPlayer <span class="syntax-all syntax-keyword">=</span> remember {
	<span class="syntax-all syntax-keyword">val</span> media<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MediaItem</span> <span class="syntax-all syntax-keyword">=</span>
		<span class="syntax-all syntax-entity">MediaItem</span>.fromUri(<span class="syntax-all syntax-string">&quot;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&quot;</span>)
}</code></pre>

<p>With that in place, we can now create an ExoPlayer reference that can be used to manage the playback of our video. For this we’re going to use the <code>SimpleExoPlayer</code> class - this ‘simple’ player uses a collection of default configurations, removing the need for us to set a lot of these things up and just focus on playing media. We’ll use the class Builder to create a new reference to this class, for which we’ll need a Context reference. We’ll use the current value of <code>LocalContext</code> to retrieve a context reference, followed by passing this into the Builder of the <code>SimpleExoPlayer</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
<span class="syntax-all syntax-keyword">val</span> exoPlayer <span class="syntax-all syntax-keyword">=</span> remember {
	<span class="syntax-all syntax-keyword">val</span> media<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MediaItem</span> <span class="syntax-all syntax-keyword">=</span>
		<span class="syntax-all syntax-entity">MediaItem</span>.fromUri(<span class="syntax-all syntax-string">&quot;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&quot;</span>)
	<span class="syntax-all syntax-keyword">val</span> exoPlayer <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SimpleExoPlayer</span>.<span class="syntax-all syntax-entity">Builder</span>(context).build()
}</code></pre>

<p>Finally, we need to tell our <code>SimpleExoPlayer</code> about the media that we want it to play. We’ll use the <code>setMediaItem</code> function to provide our previously defined <code>MediaItem</code>, meaning that now our ExoPlayer reference knows about the bunny video that we want it to play.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
<span class="syntax-all syntax-keyword">val</span> exoPlayer <span class="syntax-all syntax-keyword">=</span> remember {
	<span class="syntax-all syntax-keyword">val</span> media<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MediaItem</span> <span class="syntax-all syntax-keyword">=</span>
		<span class="syntax-all syntax-entity">MediaItem</span>.fromUri(<span class="syntax-all syntax-string">&quot;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&quot;</span>)
	<span class="syntax-all syntax-entity">SimpleExoPlayer</span>.<span class="syntax-all syntax-entity">Builder</span>(context).build().<span class="syntax-all syntax-constant">apply</span> {
		setMediaItem(media)
	}
}</code></pre>

<p>Now that we have an ExoPlayer reference, we’re ready to start defining the logic and composables that will be used to orchestrate media playback. We’re going to add one last modification to our ExoPlayer reference before we move forward with any playback implementation.</p>

<p>When we defined the state and events for our video player, we defined a <code>VideoLoaded event</code> - with the intention for this to be used for signifying when our video had been loaded and was ready for playback. Because ExoPlayer is going to take our MediaItem and load the video from our provided URL, ExoPlayer is going to be the one to let us know when that video has loaded. So that we know when this event has occurred we’re going to set a playback state listener on our exoplayer reference, using the <code>addListener</code> function:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
<span class="syntax-all syntax-keyword">val</span> exoPlayer <span class="syntax-all syntax-keyword">=</span> remember {
	<span class="syntax-all syntax-keyword">val</span> media<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MediaItem</span> <span class="syntax-all syntax-keyword">=</span>
		<span class="syntax-all syntax-entity">MediaItem</span>.fromUri(<span class="syntax-all syntax-string">&quot;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&quot;</span>)
	<span class="syntax-all syntax-entity">SimpleExoPlayer</span>.<span class="syntax-all syntax-entity">Builder</span>(context).build().<span class="syntax-all syntax-constant">apply</span> {
		setMediaItem(media)
		addListener(<span class="syntax-all syntax-keyword">object</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Player</span>.<span class="syntax-all syntax-entity">Listener</span> {
			override fun onPlaybackStateChanged(state<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>) {
				super.onPlaybackStateChanged(state)
				if (state <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Player</span>.<span class="syntax-all syntax-entity">STATE_READY</span>) { 
					handleEvent(<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">VideoLoaded</span>)
				}
            }
        })
	}
}</code></pre>

<p>Here we set a new <code>Player.Listener</code> on our exoplayer reference, listening for when the Player has reached the <code>STATE_READY</code> value. When this is the case, we want to let the parent composable know that the video has been loaded so that our state can be updated to reflect this. To trigger this we’ll use the handleEvent function that has been passed into our composable function, triggering the <code>VideoLoaded</code> event in the process. This now means that when our video has been loaded we can let the parent composable know, having this ready state reflected within the state of our screen - which will eventually influence how other composables behave.</p>

<p>With this all in place, we now have an <code>ExoPlayer</code> reference that can be used to manage the media playback for our video player. This will take on the responsibility of not only loading our desired video but also manage the playback of the video - allowing us to focus on building the composables that will be used to display and manipulate the video playback.</p>

<hr />

<h2>Creating the Player</h2>

<p>So that we can display videos inside of our composable UI, we’re going to need to create the UI component that will act as the player for the video. This composable is going to be focused on holding the ExoPlayer view that will handle the playback of our media, which when implemented can be placed directly inside of the parent containers that we created in the previous sections.</p>

<p>We’ll begin by creating a new file, <code>Player.kt</code>, along with a new composable function that will be used to hold our ExoPlayer view.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Playback.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>() {

}</code></pre>

<p>To keep our player implementation simple (and not have it have to worry about video-related events), we’re going to pass an ExoPlayer instance into our composable, as opposed to instantiating the instance inside of it. This also helps to keep our composable a bit more lightweight and focused on just composing the UI based on what is provided to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Playback.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>(
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>
) {

}</code></pre>

<p>Now that we have our ExoPlayer reference, we’re going to start by making sure that it’s ready for us to use. For this we’re going to use the <code>prepare</code> function - this will prepare the player ready for us to use, allowing us to start media playback once it is ready. </p>

<p>The thing is, we only want to run this <code>prepare</code> function on the initial composition of our composable - if our composable is recomposed and our ExoPlayer reference has not changed, there is no need for us to re-prepare the player. So that we only prepare the player as required, we’re going to make use of a compose side-effect known as <code>LaunchedEffect</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>(
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>
) {
	<span class="syntax-all syntax-entity">LaunchedEffect</span>(exoPlayer, block <span class="syntax-all syntax-keyword">=</span> {
        exoPlayer.prepare()
    })
}</code></pre>

<p>The <code>LaunchedEffect</code> side-effect allows us to execute a function based on the scope of the composable, launching a coroutine to execute the provided block. When composition happens, the side-effect block will be executed and if the <code>LaunchedEffect</code> leaves the composition, then the coroutine will be cancelled. Subsequent compositions will only trigger the side-effect block if the provided key is changed (in our case, the ExoPlayer reference). If the key is changed at any point, then the existing coroutine will be cancelled, with a new coroutine execution taking its place. Using this side-effect we can prepare our ExoPlayer reference on initial composition and only as required.</p>

<p>With our ExoPlayer reference prepared, we can now start thinking about how we are going to use that to display video playback. To handle video playback we’re going to utilise the player that is provided by ExoPlayer, the <code>PlayerView</code> - the only issue here is that the <code>PlayerView</code> is an Android View class and we’re working with composables. Luckily for us, Jetpack Compose offers so interoperability features that allow us to use Android View classes inside of Composable functions - this functionality is offered in the form of the <code>AndroidView</code> composable. This composable function features two key arguments which are used to offer interoperability - these arguments are function blocks call <strong>factory</strong> and <strong>update</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">VideoView</span>(
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>
) {

	<span class="syntax-all syntax-entity">LaunchedEffect</span>(exoPlayer, block <span class="syntax-all syntax-keyword">=</span> {
        exoPlayer.prepare()
    })

    <span class="syntax-all syntax-entity">AndroidView</span>(
        factory <span class="syntax-all syntax-keyword">=</span> {
            
        },
        update <span class="syntax-all syntax-keyword">=</span> {
            
        }
	)
}</code></pre>

<p>The <strong>factory</strong> block will be called a single time on the UI thread when the AndroidView is initially composed. Because this ensures that the View will only be instantiated a single time, you can also use this block to perform any other related initialisations that only need to happen a single time. When this factory block is called, a reference to this view will be stored against a view holder so that it can be composed when required.</p>

<p>When it comes to the <strong>update</strong> block - this is a callback that is triggered once the layout within the factory block has been inflated. This block will be triggered after the factory block has completed, and then every single time state is changed - allowing you to ensure that the AndroidView reflects the current state of your data. </p>

<p>We’ll start with implementing the body of our <code>AndroidView</code> using the factory. Within this we simply want to instantiate a new reference to a <code>PlayerView</code>, for this, we’ll need a content reference so we’ll also add this as a required argument to the <code>Player</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>,
	<span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>
) {

	...

    <span class="syntax-all syntax-entity">AndroidView</span>(
    	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        factory <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">PlayerView</span>(context)
        },
        update <span class="syntax-all syntax-keyword">=</span> {
            
        }
	)
}</code></pre>

<p>At this point, we have a composable function that will compose an <code>AndroidView</code>, which in turn will display our ExoPlayer <code>PlayerView</code>. When working with Android View classes inside of our AndroidView, we can interact with them just like we would inside of non-compose scenarios. Let’s modify some of the display properties for our <code>PlayerView</code>, configuring the layout parameters to fill the maximum available dimensions for both the width and height:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PlayerView</span>(context).<span class="syntax-all syntax-constant">apply</span> {
	layoutParams <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>(
		<span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>.<span class="syntax-all syntax-entity">MATCH_PARENT</span>,
		<span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>.<span class="syntax-all syntax-entity">MATCH_PARENT</span>
    )
}</code></pre>

<p>We’ll also want to configure some <code>PlayerView</code> specific properties. We’ll need to start by assigning a player to the <code>PlayerView</code>, this is so that video playback will function - we can use the ExoPlayer reference that is provided to our composable function for this.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PlayerView</span>(context).<span class="syntax-all syntax-constant">apply</span> {
	layoutParams <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>(
		<span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>.<span class="syntax-all syntax-entity">MATCH_PARENT</span>,
		<span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>.<span class="syntax-all syntax-entity">MATCH_PARENT</span>
    )
	player <span class="syntax-all syntax-keyword">=</span> exoPlayer
}</code></pre>

<p>Finally, we don’t want our <code>PlayView</code> to display any playback controls - this is because we are going to be implementing our own controls using Composable UI. So that we can use our own controls and the stock ones do not display, we’ll use the<code>hideController</code> function, as well as disable the default controller using <code>useController</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">PlayerView</span>(context).<span class="syntax-all syntax-constant">apply</span> {
	layoutParams <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>(
		<span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>.<span class="syntax-all syntax-entity">MATCH_PARENT</span>,
		<span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>.<span class="syntax-all syntax-entity">MATCH_PARENT</span>
    )
	player <span class="syntax-all syntax-keyword">=</span> exoPlayer
	hideController()
	useController <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
}</code></pre>

<p>With this in place, we now have a <code>PlayerView</code> wrapped by the <code>AndroidView</code> composable, allowing us to display the video playback view directly inside of our composable UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>,
	<span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>
) {

	<span class="syntax-all syntax-entity">LaunchedEffect</span>(exoPlayer, block <span class="syntax-all syntax-keyword">=</span> {
        exoPlayer.prepare()
    })

    <span class="syntax-all syntax-entity">AndroidView</span>(
    	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        factory <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">PlayerView</span>(context).<span class="syntax-all syntax-constant">apply</span> {
            	layoutParams <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>(
                    <span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>.<span class="syntax-all syntax-entity">MATCH_PARENT</span>, 					<span class="syntax-all syntax-entity">ViewGroup</span>.<span class="syntax-all syntax-entity">LayoutParams</span>.<span class="syntax-all syntax-entity">MATCH_PARENT</span>
                )
                hideController()
                useController <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
                player <span class="syntax-all syntax-keyword">=</span> exoPlayer
            }
        },
        update <span class="syntax-all syntax-keyword">=</span> {

        }
	)
}</code></pre>

<p>At this point we’ve configured the factory block of the <code>AndroidView</code>, allowing our PlayView to be configured and displayed on the screen. However, our view currently isn’t going to be reflecting the latest playback status from our UI state. So that we can come our Player based on our UI state, we’re going to need to provide the current PlayerStatus to our composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">IDLE</span>,
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>,
	<span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>
)</code></pre>

<p>Now that our <code>Player</code> composables knows the current <code>PlayerStatus</code> we can reflect this status with our <code>ExoPlayer</code> <code>PlayerView</code>. Whenever our <code>Player</code> is recomposed to reflect this state change, we want to ensure that our <code>AndroidView</code> is also updated accordingly. For this we’re going to utilise the <strong>update</strong> block - this will allow us to update any properties of our <code>PlayerView</code> from the <strong>factory</strong> block based on these state changes.</p>

<p>Here we’re going to configure the player of our <code>PlayerView</code> (the one that we assigned using our ExoPlayer reference) based on the current <code>PlayerStatus</code> within our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>,
	<span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>
) {

	...

    <span class="syntax-all syntax-entity">AndroidView</span>(
    	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        factory <span class="syntax-all syntax-keyword">=</span> {
            ...
        },
        update <span class="syntax-all syntax-keyword">=</span> {
			<span class="syntax-all syntax-keyword">when</span> (state) {
            	<span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                    playerView.player?.play()
                }
                <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                    playerView.player?.pause()
                }
            }
        }
	)
}</code></pre>

<p>If our <code>PlayerStatus</code> currently represents the <code>PLAYING</code> state, then we want to trigger the <code>play</code> function on our player, otherwise, if it represents <code>PAUSED</code> then we’ll trigger <code>pause</code>. With this in place, it means that the parent composable will be able to pass in any state changes for the current playback status of our Video Player, with our <code>AndroidView</code> utilising this state to ensure that our <code>ExoPlayer</code> reference is in the corresponding playback state.</p>

<p>With the above in place, we have a <code>PlayerView</code> that can be used in our composable UI to display video playback. The only issue at this point is that our Player composable is not reacting to any lifecycle change events - this means that if the composable is torn down (such as our app being moved away from and put into the background) the <code>PlayerView</code> reference is not adapting to this new state - meaning that video playback will continue in the background. What we want to do is release the player reference so that playback is stopped when our composable is torn down.</p>

<p>For this we’re going to explore using another composable side-effect, this time in the form of a <code>DisposableEffect</code>. The <code>DisposableEffect</code> is a side-effect that takes a <code>key</code> and an <code>effect</code> block:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">@NonRestartableComposable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DisposableEffect</span>(
    <span class="syntax-all syntax-parameter">key1</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Any?</span>,
    <span class="syntax-all syntax-parameter">effect</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DisposableEffectScope</span>.() <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-entity">DisposableEffectResult</span>
)</code></pre>

<p>The <code>key</code> is used to determine if the composable needs to be cleaned up - if the key-value changes, then the composable is registered as needing to be disposed of so it is reset and the effect is called again. In the case of the composable leaving composition, the composable is just decomposed.</p>

<p>With the effect block, we will utilise the <code>onDispose</code> clause to perform the required cleanup of our <code>ExoPlayer</code> reference. Because our composable is being decomposed, our <code>DisposableEffect</code> is aware of this so the <code>onDispose</code> clause will be called accordingly. Within this <code>onDispose</code> we will want to call the <code>release</code> function on our <code>ExoPlayer</code> reference, meaning that when our composable is decomposed our <code>ExoPlayer</code> reference will be cleaned up in the process.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
    <span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>,
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>
) {

	<span class="syntax-all syntax-entity">LaunchedEffect</span>(exoPlayer, block <span class="syntax-all syntax-keyword">=</span> {
        exoPlayer.prepare()
    })

	<span class="syntax-all syntax-entity">DisposableEffect</span>(
        <span class="syntax-all syntax-entity">AndroidView</span>(
            ...
		)
    ) {
        onDispose {
            exoPlayer.release()
        }
    }

}</code></pre>

<p>While at this point we’re handling the disposable of our composable, we still need to take care of some of the Android Lifecycle events. For example, if the <code>onPause</code> lifecycle event is triggered (as in, the user moves to another application and moves ours to the background) then we’ll want to pause the video, resuming it once then return and the <code>onResume</code> lifecycle event is triggered. For this, we’ll need to be able to observe the current lifecycle for our application from within our composable function - meaning we’ll need access to a <code>LifecycleOwner</code> reference. We’ll add a new argument for this to our <code>Playback</code> composable function, providing a default value of <code>LocalLifecycleOwner.current</code> if this is not provided - which gives us the nearest <code>LifecycleOwner</code> that has invoked the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playback</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">lifecycleOwner</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">LifecycleOwner</span> <span class="syntax-all syntax-keyword">=</span> 	
		<span class="syntax-all syntax-entity">LocalLifecycleOwner</span>.current,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>,
    <span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>,
    <span class="syntax-all syntax-parameter">exoPlayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExoPlayer</span>
)</code></pre>

<p>Now that we have this <code>LifecycleOwner</code> reference, we’re going to want to observe its state so that we can react accordingly. We’re going to start by declaring another <code>DisposableEffect</code> composable, providing the <code>LifecycleOwner</code> reference as the key - this means that if this reference changes, then the <code>DisposableEffect</code> will be called again. Within this side-effect we’ll create a new <code>LifecycleEventObserver</code> so that we can observe the lifecycle events that occur for the given <code>LifecycleOwner</code>, followed by registering this listener against our <code>LifecycleOwner</code> reference, removing it during the <code>onDispose</code> block of the <code>DisposableEffect</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">DisposableEffect</span>(lifecycleOwner) {
	<span class="syntax-all syntax-keyword">val</span> observer <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LifecycleEventObserver</span> { _, event <span class="syntax-all syntax-keyword">-&gt;</span>
		
    }

    lifecycleOwner.lifecycle.addObserver(observer)

    onDispose {
        lifecycleOwner.lifecycle.removeObserver(observer)
    }
}</code></pre>

<p>Now that this listener has been registered, we’re going to want to manage the provided <code>ExoPlayer</code> reference based on the emitted lifecycle event. Here we’ll use conditional checks to trigger <code>play</code> on our <code>ExoPlayer</code> reference when the triggered lifecycle event is <code>Lifecycle.Event.ON_RESUME</code>, triggering <code>pause</code> when the <code>Lifecycle.Event.ON_PAUSE</code> event is received. We’ll only want to respond to these events when the current <code>PlayerStatus</code> is equal to <code>PlayerStatus.PLAYING</code> (which means our video is currently being played), as we won’t want to fire these events when the user is not currently playing the provided media.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">DisposableEffect</span>(lifecycleOwner) {
	<span class="syntax-all syntax-keyword">val</span> observer <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LifecycleEventObserver</span> { _, event <span class="syntax-all syntax-keyword">-&gt;</span>
		<span class="syntax-all syntax-keyword">if</span> (state <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>) {
			<span class="syntax-all syntax-keyword">if</span> (event <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Lifecycle</span>.<span class="syntax-all syntax-entity">Event</span>.<span class="syntax-all syntax-entity">ON_RESUME</span>) {
				exoPlayer.play()
			} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">if</span> (event <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Lifecycle</span>.<span class="syntax-all syntax-entity">Event</span>.<span class="syntax-all syntax-entity">ON_PAUSE</span>) {
                exoPlayer.pause()
            }
        }
    }

    lifecycleOwner.lifecycle.addObserver(observer)

    onDispose {
        lifecycleOwner.lifecycle.removeObserver(observer)
    }
}</code></pre>

<p>With this in place, we have an observer that will listen to and react to lifecycle events that occur within our composable. However, things aren’t going to quite work as expected yet - this is because the <code>PlayerStatus</code> value that we are utilising within the observer won’t reflect the latest values that are provided through recomposition. So that we can ensure the latest value provided to the composable function is always used within our observer, we’re going to need to use the <code>rememberUpdatedState</code> function. As per the documentation:</p>

<blockquote>
<p>rememberUpdatedState should be used when parameters or values computed during composition are referenced by a long-lived lambda or object expression. Recomposition will update the resulting State without recreating the long-lived lambda or object, allowing that object to persist without cancelling and resubscribing, or relaunching a long-lived operation that may be expensive to recreate and restart. This may be common when working with DisposableEffect or LaunchedEffect,</p>
</blockquote>

<p>With that in mind, we’ll create a new reference here using the <code>rememberUpdatedState</code> function and providing our <code>PlayerStatus</code> reference. Now, whenever our composable is recomposed, the latest value will always be utilised within the lifecycle observer.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> currentPlayerStatus by rememberUpdatedState(state)
<span class="syntax-all syntax-entity">DisposableEffect</span>(lifecycleOwner) {
	<span class="syntax-all syntax-keyword">val</span> observer <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LifecycleEventObserver</span> { _, event <span class="syntax-all syntax-keyword">-&gt;</span>
		<span class="syntax-all syntax-keyword">if</span> (currentPlayerStatus <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>) {
			<span class="syntax-all syntax-keyword">if</span> (event <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Lifecycle</span>.<span class="syntax-all syntax-entity">Event</span>.<span class="syntax-all syntax-entity">ON_RESUME</span>) {
				exoPlayer.play()
			} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">if</span> (event <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Lifecycle</span>.<span class="syntax-all syntax-entity">Event</span>.<span class="syntax-all syntax-entity">ON_PAUSE</span>) {
                exoPlayer.pause()
            }
        }
    }

    lifecycleOwner.lifecycle.addObserver(observer)

    onDispose {
        lifecycleOwner.lifecycle.removeObserver(observer)
    }
}</code></pre>

<p>While we have provided a default value for the <code>LifecycleOwner</code> that is being provided to our composable function, we’re going to go ahead and propagate this value down from the activity that is composing our function - this is so that we can be explicit about the <code>LifecycleOwner</code> that is being utilised here. We’ll start by adding this as an argument to our <code>VideoPlayer</code> function, passing this into the <code>Playback</code> composable as required.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">VideoPlayer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">lifecycleOwner</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">LifecycleOwner</span> <span class="syntax-all syntax-keyword">=</span> 
		<span class="syntax-all syntax-entity">LocalLifecycleOwner</span>.current,
    <span class="syntax-all syntax-parameter">videoState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {

	...
	
	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            .fillMaxSize()
            .clickable(
                onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> controlsClickLabel)
                ) {
                    controlsVisible <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>controlsVisible
                }
            .testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_VIDEO_PLAYER</span>),
        lifecycleOwner <span class="syntax-all syntax-keyword">=</span> lifecycleOwner,
        state <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus, 
        context <span class="syntax-all syntax-keyword">=</span> context, 
        exoPlayer <span class="syntax-all syntax-keyword">=</span> exoPlayer
    )
}</code></pre>

<p>Next, we’ll want to provide this to our <code>Video</code> composable function as an argument, followed by passing it down into the <code>VideoPlayer</code> as an argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Video</span>(
    <span class="syntax-all syntax-parameter">lifecycleOwner</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">LifecycleOwner</span> <span class="syntax-all syntax-keyword">=</span> 	
		<span class="syntax-all syntax-entity">LocalLifecycleOwner</span>.current
) {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()

    <span class="syntax-all syntax-entity">VideoPlayer</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
        videoState <span class="syntax-all syntax-keyword">=</span> viewModel.uiState.collectAsState().value,
        lifecycleOwner <span class="syntax-all syntax-keyword">=</span> lifecycleOwner,
        handleEvent <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::handleEvent
    )
}</code></pre>

<p>And finally, within the <code>VideoActivity</code> where we compose the content of our video feature, we’ll pass the current reference to a <code>LifecycleOwner</code> using the activity that is performing the composition.</p>

<pre><code class="code-highlighted code-kt">setContent {
	<span class="syntax-all syntax-entity">Video</span>(lifecycleOwner <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">this</span>)
}</code></pre>

<p>With that in place we’ve now built out a <code>Player</code> composable that allows us to effectively display video playback, with this we’ve:</p>

<ul>
	<li>Learnt about the LaunchedEffect side-effect and how it can be used to trigger events on initial compositions (or if the provided key has changed)</li>
	<li>Use a pre-existing Android View class inside of a composable function using interoperability features</li>
	<li>Learnt about the DisposableEffect side-effect and how it can be used to handle decomposition and tidy-up of any composables and logic</li>
	<li>Created our video player that reacts to state that is being passed into the composable function</li>
</ul>

<p>Now that we have our video playback in place, we can move on to explore how we can control the playback of the video via user interaction.</p>

<hr />

<h2>Creating the Controls</h2>

<p>So that the user can control the playback of the video media, we’re going to implement some simple controls. For this composable, we’re going to create a control bar that:</p>

<ul>
	<li>Displays Play/Pause button that allows the user to control media playback</li>
	<li>Disables any user interaction until the video has loaded</li>
	<li>Animates out of view when it has not been interacted with</li>
</ul>

<p>While only supporting the ability to Play / Pause the video, we’ll be implementing the other two points from above to make our composable controls a little bit more interesting. To get started we’ll create a new file called <code>Controls.kt</code>, followed by a composable function called <code>Controls</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Controls.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    
}</code></pre>

<p>Even though we’re only going to be displaying a single control in our control bar, we’re going to need a parent container. This is because we want the control bar to fill the width of our video player - as well as give the bar some styling that is independent of the controls inside of it. For this, we’ll go ahead and declare a <code>Box</code> - the <code>Box</code> composable will stack the children in the order that they are provided to it. If providing multiple children then there may be overlap with the composables that you define, but because we are only using a single child composable we are safe from that happening.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

	}
}</code></pre>

<h3>Creating the playback button</h3>

<p>With the container in place, we can go ahead and define the composable that will be used for our Play/Pause control - for this, we’ll use the <code>IconButton</code> composable. While there is a <code>Button</code> composable available that we could just provide an icon to as the body, the <code>IconButton</code> is specifically designed to display intractable icons as its minimum touch targets meet the required dimensions for accessibility standards. When using the <code>IconButton</code> you must provide its two required arguments, the <strong>onClick</strong> callback and <strong>content</strong> argument:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">IconButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                
            }
        ) {

		}
	}
}</code></pre>

<p>The <code>onClick</code> callback allows us to receive click events for the <code>IconButton</code>, while the <strong>content</strong> allows us to provide the composable body that we want to be composed inside of the <code>IconButton</code>. For now, we’re going to leave the <code>onClick</code> function empty, but we’ll go ahead and add the body for our <code>IconButton</code> in the form of an <code>Icon</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">IconButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                
            }
        ) {
			<span class="syntax-all syntax-entity">Icon</span>(
                imageVector <span class="syntax-all syntax-keyword">=</span> ...,
                contentDescription <span class="syntax-all syntax-keyword">=</span> ...
            )
		}
	}
}</code></pre>

<p>We can see here that the <code>Icon</code> composable has two required arguments. There are several variations of the <code>Icon</code> composable, depending on the format of the icon is that you are providing to it. For simplicities sake, we’re going to provide an <code>ImageVector</code>, taken from the <code>material-icons-extended</code> library. This contains a lot of icons that we don’t need in the project but allows us to just slot the icon in the place where we need it.</p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.compose.material:material-icons-extended:$compose_version&quot;</span></code></pre>

<p>Before we go ahead and add the icon to our composable, we’re going to need some extra information in our composable. Because we are using the same button for the Play/Pause action, we’re going to need to know the current state of the playback so that we can set the icon based on that. For this we’re going to need to provide the <code>PlayerStatus</code> into the composable, this will come from the current state of the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>
)</code></pre>

<p>With this in place, we can go ahead and calculate the icon based on this information. If the <code>PlayerStatus</code> currently represents the <code>PLAYING</code> state then we’ll use the <code>Icons.Default.Pause</code> icon (as when playing, the user will be able to toggle the state to paused), otherwise, we’ll utilise the <code>Icons.Default.PlayArrow</code> to indicate that the user can set the video to the playing state. After creating a reference to an icon using this logic, we’ll assign this to the <strong>imageVector</strong> argument of the <code>Icon</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">IconButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                
            }
        ) {
			<span class="syntax-all syntax-keyword">val</span> icon <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (playerStatus <span class="syntax-all syntax-keyword">==</span>
				<span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>
			) {
            	<span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Pause</span>
            } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">PlayArrow</span>


			<span class="syntax-all syntax-entity">Icon</span>(
                imageVector <span class="syntax-all syntax-keyword">=</span> icon,
                contentDescription <span class="syntax-all syntax-keyword">=</span> ...
            )
		}
	}
}</code></pre>

<p>Before our <code>Icon</code> composable is complete we’ll need to add a <code>contentDescription</code>, as this is a required argument. While this is nullable, we’ll want to provide a description so that the icon is accessible to users using a screen reader. If we don’t provide a content description, the user will not be aware of what the icon is used for - therefore causing friction when trying to interact with the playback state of the video.</p>

<p>So that we can assign a description to our <code>Icon</code>, we’ll go ahead and start by adding two new string resources in our <code>strings.xml</code> resource file - we’ll add one for both the playing and paused states:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_play&quot;</span>&gt;Play video&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_pause&quot;</span>&gt;Pause video&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Now that we have these string resources in place, we can reference them from our composable. Similar to the logic used for the icon of our composable, we’ll create a reference for the description paused on the current <code>PlayerStatus</code> that has been provided to our composable.</p>

<pre><code>val description = 
	if (playerStatus == PlayerStatus.PLAYING) {
		stringResource(id = R.string.cd_pause)
	} else stringResource(id = R.string.cd_play)</code></pre>

<p>When our <code>PlayerStatus</code> represents the <code>PLAYING</code> status our description will represent the “Pause Video” string - this will be matched with the Pause icon that will be displayed at the time, as our video will be playing so that <code>IconButton</code> will be used to pause the video. With this logic in place, we can now assign our description reference to the <code>contentDescription</code> argument of the <code>Icon</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">IconButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                
            }
        ) {
			<span class="syntax-all syntax-keyword">val</span> icon <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (playerStatus <span class="syntax-all syntax-keyword">==</span>
				<span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>
			) {
            	<span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Pause</span>
            } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">PlayArrow</span>

			<span class="syntax-all syntax-keyword">val</span> description <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (playerStatus <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>
			) {
                stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_pause)
            } <span class="syntax-all syntax-keyword">else</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play)

			<span class="syntax-all syntax-entity">Icon</span>(
                imageVector <span class="syntax-all syntax-keyword">=</span> icon,
                contentDescription <span class="syntax-all syntax-keyword">=</span> description
            )
		}
	}
}</code></pre>

<hr />

<h3>Toggling playback state</h3>

<p>Now we have the above in place, we have an <code>IconButton</code> composable that will configure its icon and content description based on based on the current <code>PlayerStatus</code> that is provided to our composable. The only thing now is that our <code>IconButton</code> isn’t triggering any events when it’s clicked - which is kind of the whole reason for adding a button in the first place! When the <code>IconButton</code> is clicked we’re going to want to toggle the playback status of the video - the only thing is that our composable doesn’t have a reference to the player instance that needs controlling. This is a good thing though, as it means the controls of our video player are decoupled from the actual video player implementation. This just means that we’re going to need to pass up any click events on the <code>IconButton</code> so that the parent composable can handle those click events and update the <code>PlayerStatus</code> accordingly. For this we’ll need to add another argument to our <code>Controls</code> composable in the form of a callback - we’ll call this <code>togglePlayingState</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>,
    <span class="syntax-all syntax-parameter">togglePlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Now when our <code>IconButton</code> is clicked we can trigger the callback to pass up the event to the parent composable. To do this we’ll trigger our togglePlayingState callback with the <code>onClick</code> lambda of our <code>IconButton</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>,
    <span class="syntax-all syntax-parameter">togglePlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">IconButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                togglePlayingState()
            }
        ) {
			...
        }
    }
}</code></pre>

<figure><img src="1-19.png"/></figure>

<hr />

<h3>Styling the Control bar</h3>

<p>Now that we have the body of our controls implemented, our control bar isn’t yet going to look quite right within our UI. This is because we haven’t configured how our composable should be composed onscreen, this means that by default our <code>Controls</code> composable is just going to be wrapping the size of the content that we have provided to it.</p>

<p>However, we want our <code>Controls</code> to fill the width of our video player, as well as use a background colour to make it prominent when displayed on top of our player. Here we’re going to utilise the <code>background</code> modifier to do so. We’ll chain this onto our modifier declaration, using the surface colour from our theme when applying this.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>,
    <span class="syntax-all syntax-parameter">togglePlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface)
    ) {
        <span class="syntax-all syntax-entity">IconButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                togglePlayingState()
            }
        ) {
			...
        }
    }
}</code></pre>

<p>With these applied, we can see that our <code>Controls</code> composable fills the maximum width that it has available, along with using the surface colour from our application theme as the background:</p>

<figure><img src="99.png"/></figure>

<p>You might notice here that the <code>IconButton</code> doesn’t sit quite right inside of the <code>Box</code> - if we aligned it in the center, things would look a little more presentable. To align children inside of a <code>Box</code> we can use the <code>contentAlignment</code> argument, using one of the 2D Alignment values to declare how the alignment should be applied. We’ll use the <code>Alignment.Center</code> value to have our <code>IconButton</code> aligned in the center of our <code>Box</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>,
    <span class="syntax-all syntax-parameter">togglePlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface),
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-entity">IconButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                togglePlayingState()
            }
        ) {
			...
        }
    }
}</code></pre>

<p>With this <strong>contentAlignment</strong> applied we can now see how the <code>IconButton</code> is position inside of the <code>Box</code>: </p>

<figure><img src="controls.png"/></figure>

<h3>Setting the enabled state of the controls</h3>

<p>Now that our control bar is looking presentable, we’re going to add the finishing touch to its expected functionality. Our <code>Controls</code> composable has a reference to the current <code>PlayerStatus</code> state - when we defined these values we did so in a way that allows it to not only just reflect the playing and paused state, but also the loading and idle state. The thing is, when the <code>PlayerStatus</code> is in the loading state, we don’t want to allow the user to interact with the controls - this is because the video hasn’t loaded yet, so we don’t need to allow the user to play or pause the video (as this wouldn’t have any effect anyway!).</p>

<p>What we’ll do here is utilise the <strong>enabled</strong> argument of the <code>IconButton</code> composable. This will allow us to control whether or not the button can be interacted with by the user - which we don’t want to allow if the video is currently being loaded. In this case, we will want only to enable the button if the <code>PlayerStatus</code> value is not equal to <code>LOADING</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Controls</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">playerStatus</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PlayerStatus</span>,
    <span class="syntax-all syntax-parameter">togglePlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface),
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-entity">IconButton</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                togglePlayingState()
            },
            enabled <span class="syntax-all syntax-keyword">=</span> playerStatus <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>
        ) {
			...
        }
    }
}</code></pre>

<p>With the logic of <code>playerStatus != PlayerStatus.LOADING</code> applied to the <strong>enabled</strong> argument, the <code>IconButton</code> composable will be disabled if the playerStatus is marked as loading - disallowing interaction while the video is being loaded.</p>

<figure><img src="disabled.png"/></figure>

<p>With all of this in place, we have a fully functioning control bar that allows the user to play + pause video playback. All that’s left now is to piece our composables together to wrap up the video player UI.</p>

<hr />

<h2>Piecing things together</h2>

<p>With all of the above composables in place, we now have the individual components that can be used to make up our video player - we just need to piece them together! At the start of this section, we defined the <code>VideoPlayer</code> composable, so we’ll now use that as the parent composable for these individual components that we’ve created. </p>

<h3>Composing the Player and Controls</h3>

<p>If we backtrack to the start of this section in the chapter, we created a new composable function called <code>VideoPlayer</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">VideoPlayer</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">videoState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VideoEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {

	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
    <span class="syntax-all syntax-keyword">val</span> exoPlayer <span class="syntax-all syntax-keyword">=</span> remember {
        <span class="syntax-all syntax-keyword">val</span> media<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MediaItem</span> <span class="syntax-all syntax-keyword">=</span>
            <span class="syntax-all syntax-entity">MediaItem</span>.fromUri(<span class="syntax-all syntax-string">&quot;https://
</span><span class="syntax-all syntax-string">			commondatastorage.googleapis.com/
</span><span class="syntax-all syntax-string">			gtv-videos-bucket/sample/BigBuckBunny.mp4&quot;</span>)
        <span class="syntax-all syntax-keyword">val</span> exoPlayer <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SimpleExoPlayer</span>.<span class="syntax-all syntax-entity">Builder</span>(context)
			.build()
        exoPlayer.setMediaItem(media)
        exoPlayer
    }
    exoPlayer.addListener(<span class="syntax-all syntax-keyword">object</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Player</span>.<span class="syntax-all syntax-entity">Listener</span> {
        override fun onPlaybackStateChanged(state<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>) {
            super.onPlaybackStateChanged(state)
            if (state <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">Player</span>.<span class="syntax-all syntax-entity">STATE_READY</span>) {
				handleEvent(<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">VideoLoaded</span>)
			}
        }
    })
}</code></pre>

<p>Within this composable function, we created a reference to an <code>ExoPlayer</code> instance and configured it with the required information for video playback. At this point though, the composable function does not do much else. With the composables that we’ve created throughout this chapter, we can now slot those into our <code>VideoPlayer</code> composable so that they are composed as part of our player UI.</p>

<p>We’re going to start here by defining a <code>Box</code> composable. As we previously mentioned, this composable allows us to stack composables on top of one another - this is perfect for our video player, as we wish to display the control bar on top of our video playback composable. We’ll define this <code>Box</code> composable and give it a background color using <code>Color.Black</code> - using this will help to create an immersive experience, as any area our video does not fill will be visible as black space.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {

}</code></pre>

<p>With this <code>Box</code> in place, we now have a parent composable that can be used to hold our player and control composables. We’ll first compose the <code>Playback</code> composable - this is because we want this to appear <strong>underneath</strong> the controls composable, so it gets declared first within the composable block. When composing this, we’ll provide the <code>fillMaxSize</code> modifier to fill the available size on the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {
	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
		context <span class="syntax-all syntax-keyword">=</span> ..., 
		exoPlayer <span class="syntax-all syntax-keyword">=</span> ...
    )
}</code></pre>

<p>The <code>Playback</code> composable has three required arguments, a <strong>Context</strong> reference, <strong>ExoPlayer</strong> reference and <code>PlayerStatus</code> value. We already have a Context reference from where we are initialising our ExoPlayer reference just above here, so we can pass that directly into our <code>Playback</code> composable. At the same time, we have also initialised the ExoPlayer reference within this process, so we can pass that in too.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {
	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
		context <span class="syntax-all syntax-keyword">=</span> context, 
		exoPlayer <span class="syntax-all syntax-keyword">=</span> exoplayer
    )
}</code></pre>

<p>For the <code>PlayerStatus</code> value, we can directly pass in the <code>playerStatus</code> value that we have available from our <code>VideoState</code> reference that is passed to the <code>VideoPlayer</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {
	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
        state <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus, 
		context <span class="syntax-all syntax-keyword">=</span> context, 
		exoPlayer <span class="syntax-all syntax-keyword">=</span> exoPlayer
    )
}</code></pre>

<p>At this point, the <code>Playback</code> composable is being composed within our UI and now we need to compose the <code>Controls</code>, so the video playback of our <code>Playback</code> composable can be controlled.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {
	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
        state <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus, 
		context <span class="syntax-all syntax-keyword">=</span> context, 
		exoPlayer <span class="syntax-all syntax-keyword">=</span> exoPlayer
    )

	<span class="syntax-all syntax-entity">Controls</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
		playerStatus <span class="syntax-all syntax-keyword">=</span> ...,
		togglePlayingState <span class="syntax-all syntax-keyword">=</span> ...
	)
}</code></pre>

<p>The <code>Controls</code> composable has two required arguments, the <strong>playerStatus</strong> and <strong>togglePlayingState</strong> callback. For the playerStatus we can do the same as we did for the <code>Playback</code> composable, passing the value in directly from the <code>VideoState</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {
	...

	<span class="syntax-all syntax-entity">Controls</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
		playerStatus <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus,
		togglePlayingState <span class="syntax-all syntax-keyword">=</span> ...
	)
}</code></pre>

<p>When it comes to the <strong>togglePlayingState</strong> callback we need to trigger an event so that the playback state is toggled within our state. The <code>VideoPlayer</code> composable that we are composing inside of has a reference to a <code>handleEvent</code> function that takes a <code>VideoEvent</code> to be handled, allowing us to pass UI events up to the parent composable for handling. Earlier in this chapter, we defined these <code>VideoEvent</code> types, one of which being the <code>ToggleStatus</code> type. We’re going to trigger this event here so that when this <strong>togglePlayingState</strong> callback is triggered from within our <code>Controls</code> composable, it can be handled here and the event passed up to the parent composable using the event handler.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {
	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
        state <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus, 
		context <span class="syntax-all syntax-keyword">=</span> context, 
		exoPlayer <span class="syntax-all syntax-keyword">=</span> exoPlayer
    )

	<span class="syntax-all syntax-entity">Controls</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
		playerStatus <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus,
		togglePlayingState <span class="syntax-all syntax-keyword">=</span> {
			handleEvent(<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">ToggleStatus</span>)
		}
	)
}</code></pre>

<p>At this point, we can see that our video playback UI is composed, but the <code>Controls</code> composable doesn’t appear to be sitting quite right within our UI. </p>

<figure><img src="44-1.png"/></figure>

<p>To fix this, we’re going to provide a <code>Modifier</code> to the <code>Controls</code> composable, utilising the <code>align</code> modifier to align the composable within the parent <code>Box</code>. Here we’ll use the <code>Alignment.BottomCenter</code> so that the <code>Controls</code> composable is positioned at the bottom and in the center of the playback area, feeling like a more natural positioning for the controls bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {
	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
        state <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus, 
		context <span class="syntax-all syntax-keyword">=</span> context, 
		exoPlayer <span class="syntax-all syntax-keyword">=</span> exoPlayer
    )

	<span class="syntax-all syntax-entity">Controls</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
			.fillMaxWidth()
			.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">BottomCenter</span>),
		playerStatus <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus,
		togglePlayingState <span class="syntax-all syntax-keyword">=</span> {
			handleEvent(<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">ToggleStatus</span>)
		}
	)
}</code></pre>

<p>With the above in place, we now have our video playback UI being composed, allowing our users to consume playback content while also having control over the current status of the playback. At this point though, the control bar is always visible - to create a better immersive experience we can hide the control bar from view, allowing our user to enjoy the full-screen video playback without the controls blocking any viewing space.</p>

<figure><img src="44444.png"/></figure>

<hr />

<h3>Managing the control bar visibility</h3>

<p>While our video is playing, the control bar can block part of the playback area - so once the user has finished interacting with the control bar, we’ll want to move it out of view so that the user can continue with the immersive full-screen experience. So when it comes to displaying the toolbar, we’ll implement the behaviour in the following way:</p>

<ul>
	<li>The control bar will be displayed by default when the video player is first displayed</li>
	<li>If the user does not interact with the control bar, then the control bar will dismiss after a specified amount of time</li>
	<li>When the user interacts with the video player and the control bar is hidden, then the control bar will animate back into view</li>
</ul>

<p>While these points outline the behaviour of the control bar, the control bar itself isn’t going to care about all of these. The control bar is being used to compose controls on the screen, it doesn’t need to know about when it’s going to show and hide itself, that will be the responsibility of the current composable that we are working inside of, the parent of the <code>Controls</code> composable. What we can do here is define an animation that will be used to control the alpha of the <code>Controls</code> composable, passing this in via a modifier so that the alpha can be applied without the composable knowing anything about this logic.</p>

<p>Before we can start thinking about the animation logic, we need some form of state that can be used to represent whether or not the controls are currently visible. This doesn’t need to be a part of our screen state, as currently, this logic is OK to be coupled to our <code>VideoPlayer</code> composable - as nothing else above this composable needs to know about this value. With the said, we’ll go ahead and define a new piece of mutable state, <code>controlsVisible</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {

	<span class="syntax-all syntax-keyword">var</span> controlsVisible by remember {
		mutableStateOf(<span class="syntax-all syntax-constant">true</span>)
    }

	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
        state <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus, 
		context <span class="syntax-all syntax-keyword">=</span> context, 
		exoPlayer <span class="syntax-all syntax-keyword">=</span> exoPlayer
    )

	<span class="syntax-all syntax-entity">Controls</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            .fillMaxWidth()
			.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">BottomCenter</span>),
		playerStatus <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus,
		togglePlayingState <span class="syntax-all syntax-keyword">=</span> {
			handleEvent(<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">ToggleStatus</span>)
		}
	)
}</code></pre>

<p>We default this value to <strong>true</strong> so that when our video player is first composed and the state is initialised, the controls are visible on the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
) {

	<span class="syntax-all syntax-keyword">var</span> controlsVisible by remember {
		mutableStateOf(<span class="syntax-all syntax-constant">true</span>)
    }

	<span class="syntax-all syntax-entity">Playback</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
        state <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus, 
		context <span class="syntax-all syntax-keyword">=</span> context, 
		exoPlayer <span class="syntax-all syntax-keyword">=</span> exoPlayer
    )

	<span class="syntax-all syntax-entity">Controls</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
			.fillMaxWidth()
			.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">BottomCenter</span>),
		playerStatus <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus,
		togglePlayingState <span class="syntax-all syntax-keyword">=</span> {
			handleEvent(<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">ToggleStatus</span>)
		}
	)
}</code></pre>

<p>Now that we have this state in place, we’re going to want to manipulate its value when certain interactions occur on screen. Let’s start with when the control bar is interacted with, as we have the <code>togglePlayingState</code> callback that can be used to detect when playback change is triggered via the control bar. When this event does occur we are going to want to change the visibility of controls based on the <strong>current</strong> <code>PlayerStatus</code> value before the state is updated from the event change. </p>

<p>At a high level, we’re going to want to hide the controls if the current state of the player does not represent the <code>PLAYING</code> state. This means that if the video is currently <code>IDLE</code> and moving to <code>PLAYING</code> then we’ll hide the controls, and if the video is currently <code>PAUSED</code> and moving to <code>PLAYING</code> then we’ll also want to hide the controls - this is because in both cases the player will be moving to the <code>PLAYING</code> state, so we don’t want to block playback visibility. In any other cases, we will be moving away from the <code>PLAYING</code> state - so keeping the controller on the screen allows users to continue managing the video playback state until the video is playing again.</p>

<pre><code class="code-highlighted code-kt">togglePlayingState <span class="syntax-all syntax-keyword">=</span> {
	handleEvent(<span class="syntax-all syntax-entity">VideoEvent</span>.<span class="syntax-all syntax-entity">ToggleStatus</span>)
	<span class="syntax-all syntax-keyword">if</span> (videoState.playerStatus <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>) {
		controlsVisible <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
	}
}</code></pre>

<p>While the above hides the control bar visibility by setting <code>controlsVisible</code> to <strong>false</strong>, we’re going to want to somehow allow the user to display the control bar once it has been hidden. For simplicity sake, we’re going to display the control bar whenever the user taps the playback area. This means we can add a click listener to our <code>Player</code> composable and toggle this <code>controlsVisible</code> value to display our controls. We’re going to add this functionality by utilising the Modifier that we are already providing to the <code>Player</code> composable, meaning we can directly chain on the <code>clickable</code> modifier and toggle the value of <code>controlsVisible</code> based on its current value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Playback</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxSize()
		.clickable {
			controlsVisible <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>controlsVisible
		},
	state <span class="syntax-all syntax-keyword">=</span> videoState.playerStatus, 
	context <span class="syntax-all syntax-keyword">=</span> context, 
	exoPlayer <span class="syntax-all syntax-keyword">=</span> exoPlayer
)</code></pre>

<p>So now whenever the playback area is clicked, the <code>controlsVisible</code> will be toggled to the opposite state - allowing the control bar to be displayed (and also hidden) whenever the playback area is tapped. </p>

<p>One issue with this approach is that for users utilising accessibility features, the click functionality here will not be very accessible. While the click action is there, the screen reader has no clue what that click action does. To improve this we’re going to add a click label - that way the screen reader can communicate the intention of our click action to the user. Before we add this label we’re going to need to add some string resources to our project - we’ll add one for displaying the video controls, as well as one for hiding the video controls:</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_display_controls&quot;</span>&gt;
	Display video controls
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;

&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_hide_controls&quot;</span>&gt;
	Hide video controls
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’ll then need to assign the label based on the current value of our <code>controlsVisible</code> reference. If the controls are currently visible then we want to set the description for hiding the controls, otherwise, we’ll use the description for showing the controls.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> controlsClickLabel <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (controlsVisible) {
	<span class="syntax-all syntax-entity">R</span>.string.label_hide_controls
} <span class="syntax-all syntax-keyword">else</span> {
	<span class="syntax-all syntax-entity">R</span>.string.label_display_controls
}</code></pre>

<p>We can then use this to apply a value to the <code>onClickLabel</code> of the clickable modifier. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Playback</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxSize()
		.clickable(
        	onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> controlsClickLabel)
        ) {
			controlsVisible <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>controlsVisible
		},
	...
)</code></pre>

<p>As we can see, this isn’t a required property of the clickable modifier, but for minimal effort, we can increase the accessibility of our composable for screen readers.</p>

<hr />

<h3>Animating the control bar visibility</h3>

<p>As a final piece of work for our video player, we’re going to add a touch of animation so that the control bar can be displayed and hidden in an animated fashion. While at the moment our control bar is showing and hiding from interaction with the video player, adding animation gives it a nice little touch!</p>

<p>Because we want to animate the alpha of the <code>Controls</code> composable, we’re going to need to utilise an animation function, in the form of <code>animateFloatAsState</code>. This only has a single required argument, the targetValue - this is the float value that we wish to animate to.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> alphaAnimation by animateFloatAsState(
	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (controlsVisible) <span class="syntax-all syntax-constant">0.7f</span> <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-constant">0f</span>
)</code></pre>

<p>We’re going to want to set the alpha of our control bar based on whether the controls should currently be visible, in the context of our <code>controlsVisible</code> reference. So if our controls should currently be shown (as in, controlsVisible is true) then we’ll animate to the value of 0.7f - this is because we don’t want the control bar not to have any alpha at all, as visually it’s nice to have it slightly transparent. On the other hand, if the controls are not to be shown, then we want to animate to the value of 0f - making our control bar completely translucent and not visible. This results in animating between 0f and 0.7f to show and hide the control bar from view - all we need to do now is apply this to our control bar using the alpha modifier, which we can chain onto the existing modifiers that we are passing to our <code>Controls</code> composable:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Controls</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
    	.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">BottomCenter</span>)
    	.alpha(alphaAnimation),
	...
)</code></pre>

<p>With this in place, we will be able to see our control bar animating between a visible and non-visible state.</p>

<figure><img src="barr.png"/></figure>

<p>While this now works and our control is animating its alpha state, we can go one step further here and customise the animation that is being used. We can do this by using the optional <strong>animationSpec</strong> argument of the <code>animateFloatAsState</code> function. By default the function will use a spring animation - we’re going to switch this out for the tween animation. I think the animation feels a little nicer in this case (you can switch this out and try for yourself to see what you prefer!), but more importantly, the tween animation allows us to define a delay to be applied before the animation is started.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> alphaAnimation by animateFloatAsState(
	targetValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (controlsVisible) <span class="syntax-all syntax-constant">0.7f</span> <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-constant">0f</span>,
	animationSpec <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (controlsVisible) {
		tween(delayMillis <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>) 
	} <span class="syntax-all syntax-keyword">else</span> tween(delayMillis <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">750</span>)
)</code></pre>

<p>This is handy because in the case of the controls not being visible, animating the control bar out of view immediately after an interaction might feel a little bit sudden. So instead we can apply a delay here, allowing the existing animation to be applied slightly after the animation is triggered. We can see above that in the case of the controls being visible, we do not apply a delay and allow the controls to be shown instantly to the user.</p>

<p>This animation customisation is a small optional touch, so if you prefer the default <code>animationSpec</code> then there is no need to add this into your implementation!</p>

<hr />

<p>With all of the above in place, we’ve explored a collection of Compose APIs and constructed our own Video Player using existing Android View classes.</p>

<figure><img src="video-2.png"/></figure>

<p>This serves as a great example of how we can mix the worlds of Jetpack Compose and the Android View system. While Jetpack Compose is likely to be our default for building apps, there’s going to be times when it feels more pragmatic to use solutions that already exist - and this is where the Jetpack Compose interoperability features will come in handy. ExoPlayer is a great example of this, where we can use things such as the AndroidView to plug the media implementation directly into our Composable UI.</p>

<p>You’ll likely encounter similar scenarios in the application that you’re building. Whether it’s ExoPlayer, Google Maps or your own existing UI components - be sure to explore the interoperability APIs that you can re-use existing components and continue delivering value to your users!</p>

<h1>Testing the Video Player UI</h1>

<p>Now that we’ve built our Video player, we’re going to take a look at how we can write tests for our composables. We’re going to be writing some instrumentation tests using the compose ui-test-junit package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>
debugImplementation(<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to add mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered whenever expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:3.12.4&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependant on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		exclude <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/AL2.0&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/LGPL2.1&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
	}
}</code></pre>

<hr />

<h2>Setting up the test class</h2>

<p>We’ll start here by creating a new class, <code>ControlsTest</code> - this class will be used to contain the different tests that we’re going to write.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ControlsTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the <code>ComposeContentTestRule</code> class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@get:Rule
</span><span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched in, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside of.</p>

<hr />

<h2>Testing the Controls</h2>

<p>We’re going to start by writing a collection of tests for the behaviour of the control bar. In the previous chapter, we defined a collection of behaviour that configures the control bar based on the conditions of our video player state, so we must assert this behaviour through tests.</p>

<h3>Testing the controls disabled state</h3>

<p>Before the video has loaded we mark the playback button within the control bar as disabled - this is done via the use of the <code>PlayerStatus</code> flag that is provided to the <code>Controls</code> composable. To test this logic we’ll start by writing a new test function:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Control_Not_Enabled_When_Video_Not_Ready</span>() {

}</code></pre>

<p>Inside of this test, we’re going to need to start by setting the composable content that is to be displayed on screen for us to assert against. Here we’ll use the test rule that we previously defined, along with its <code>setContent</code> function. This function takes a composable function as an argument, allowing us to define what is to be composed on screen for our tests. Because we’re wanting to test the <code>Controls</code> Composable that we defined in the previous sections of this chapter, we’ll go ahead and pass this composable function for this composable argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Control_Not_Enabled_When_Video_Not_Ready</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}
}</code></pre>

<p>While we aren’t yet performing any assertions, running this test will launch an activity that displays the content of our <code>Controls</code> composable. With this now being displayed, we can next perform the required assertions to ensure that the playback button is disabled within our composable UI. However, before we can locate the node with our composed UI we’re going to need to add a tag that allows us to do so. This tag will allow us to locate this composable within our UI regardless of the current state that the button is in - because the button has dynamic content based on our state, this helps to simplify things a bit. We’ll go ahead here and define a new tag within a <code>Tags.kt</code> file:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CONTROL_BUTTON</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_CONTROL_BUTTON&quot;</span>
}</code></pre>

<p>We’ll then need to jump back into the composable function for our <code>Controls</code> composable, assigning our new tag to the playback <code>IconButton</code> using the <code>testTag</code> modifier:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">IconButton</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_CONTROL_BUTTON</span>)
	...
)</code></pre>

<p>Now that our button is locatable via this tag we can go ahead and locate it within our tests. For this we’re going to use the <code>onNodeWithTag</code> function - this allows us to locate a composable within our composed UI that matches the provided tag. Once a node has been located, we can perform assertions on it. In this case, we want to assert that the button is not currently enabled, so we’ll utilise the <code>assertIsNotEnabled</code> function for this.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Control_Not_Enabled_When_Video_Not_Ready</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}

	composeTestRule.onNodeWithTag(
    	<span class="syntax-all syntax-entity">TAG_CONTROL_BUTTON</span>
    ).assertIsNotEnabled()
}</code></pre>

<p>If we run this test, we’ll be able to see that our <code>Controls</code> composable is composed, followed by the defined assertion being performed and passing.</p>

<h3>Testing the controls enabled state</h3>

<p>On the flip side of the previous test, we’re next going to want to assert that the button is enabled when the <code>PlayerStatus</code> does not represent the loading state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Control_Enabled_When_Video_Ready</span>() {
	
}</code></pre>

<p>We could write a collection of tests here to cover each of the <code>PlayerStatus</code> values that should reflect the enabled state, but for simplicities sake, we’ll just use the <code>IDLE</code> value. We’ll again go ahead and compose our UI using the <code>Controls</code> composable, providing the <code>PlayerStatus.IDLE</code> as the current status of the player.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Control_Enabled_When_Video_Ready</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">IDLE</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}
}</code></pre>

<p>We can then go ahead and use our defined tag to perform the assertion on our button. This time we want to assert that the button is enabled, so we’ll do this using the <code>assertIsEnabled</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Control_Enabled_When_Video_Ready</span>() {
	composeTestRule.setContent {
 		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">IDLE</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}

	composeTestRule.onNodeWithTag(
		<span class="syntax-all syntax-entity">TAG_CONTROL_BUTTON</span>
	).assertIsEnabled()
}</code></pre>

<p>With this test in place, our <code>Controls</code> composable will be displayed - reflecting an enabled state based on the provided <code>PlayerStatus</code> which is verified by the defined assertion in our test.</p>

<h3>Testing the Pause control display</h3>

<p>Aside from the enabled state changing based on the provided state, the actual content of the playback button will change based on the current <code>PlayerStatus</code> that is provided to our <code>Controls</code> composable. We’re going to want to write some tests for some of this behaviour, so we’ll start with ensuring that the pause control is displayed when our video is playing. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Pause_Control_Displayed_When_Playing</span>() {

}</code></pre>

<p>We’re going to need to compose some UI for our test, which we can do using the same approach in the previous tests. The only difference is that we want to provide the <code>PlayerStatus</code> using the <code>PLAYING</code> value, this will indicate to our <code>Controls</code> composable that the video is currently playing.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Pause_Control_Displayed_When_Playing</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}
}</code></pre>

<p>If the video is playing, then the controls bar should show the playback control button as the <strong>Pause</strong> option, this is done visually using an Icon. The only thing is that this is difficult to test, as we can’t perform the test assertion on a visual element within our composed UI. Going back to the implementation of the <code>Icon</code>, we provided a content description for the <code>Icon</code> based on the current <code>PlayerStatus</code> value:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> description <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (playerStatus <span class="syntax-all syntax-keyword">==</span>
	<span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>
) {
	stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_pause)
} <span class="syntax-all syntax-keyword">else</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play)

<span class="syntax-all syntax-entity">Icon</span>(
	imageVector <span class="syntax-all syntax-keyword">=</span> icon,
	contentDescription <span class="syntax-all syntax-keyword">=</span> description
)</code></pre>

<p>Because we have this content description in place, we’re going to utilise this within our tests to locate the node that we want to perform an assertion against. For this we can utilise the <code>onNodeWithContentDescription</code> function on our test rule reference, allowing us to locate a node using the provided content description.</p>

<p>When calling this function we need to provide a content description in the form of a string. While in our composable we use the stringResource composable function, we can’t quite do this in our tests. For this reason, we’re going to access the context through our test instrumentation, retrieving a content description string using the provided resource ID.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
	.targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.cd_pause)</code></pre>

<p>With this, we can now utilise the <code>onNodeWithContentDescription</code> function with our retrieved string reference, which will locate a node for us to perform assertions against. In this case, we want to assert that the node is in fact displayed, which we can do using the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Pause_Control_Displayed_When_Playing</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PLAYING</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}

	composeTestRule.onNodeWithContentDescription(
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.cd_pause)
	).assertIsDisplayed()
}</code></pre>

<p>When this test runs, <code>Controls</code> will be composed based on the provided <code>PlayerStatus</code> value. The tests then assert that the expected node is displayed, using the stated content description - which in this case validates that the <strong>Pause</strong> icon is displayed while our video playback represents the playing state.</p>

<h3>Testing the Play control display</h3>

<p>While the above test asserts that the <strong>Pause</strong> icon is displayed while our video is playing, we’re going to want to test the opposite scenario of that - the <strong>Play</strong> icon being displayed when the video is Paused.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Play_Control_Displayed_When_Paused</span>() {

}</code></pre>

<p>Similar to our previous tests, we’ll need to compose our <code>Controls</code> for test assertions to be performed. Because we are expecting the <strong>Play</strong> icon to be displayed when the <code>Controls</code> the in the <strong>Paused</strong> state, we’re going to need to provide the <code>PlayerStatus</code> as <code>PAUSED</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Play_Control_Displayed_When_Paused</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}
}</code></pre>

<p>When testing that the Pause icon was displayed, we used the expected content description to assert that the UI was being composed as expected. In this scenario, we need to take the same approach, except this time we are expecting the content description for the play state to be in place. For this reason, we’ll still use the <code>onNodeWithContentDescription</code> function to locate a node using the provided description, except this time using the content description for the play icon.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Play_Control_Displayed_When_Paused</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}

	composeTestRule.onNodeWithContentDescription(
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.cd_play)
	).assertIsDisplayed()
}</code></pre>

<p>With this in place, we assert that the node is displayed using the <code>assertIsDisplayed</code> function, validating that the Play icon is composed when our <code>Controls</code> represents the <code>PAUSED</code> state.</p>

<h3>Testing the control state toggle</h3>

<p>Aside from the visual composition of our <code>Controls</code>, there is also a key piece of behaviour that would be important to assert - the toggling of the player status when the playback button is clicked. When the playback button is clicked, an event is triggered and propagated to the parent composable - this is used to toggle the playback status of the video. If this wasn’t working as expected, then we’d have some pretty big problems with our video player - so we’ll write a test to ensure that this event is triggered as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Toggle_Play_State_Triggered</span>() {

}</code></pre>

<p>We’ll also need to compose some UI for our tests to perform assertions against.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Toggle_Play_State_Triggered</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> { }
		)
	}
}</code></pre>

<p>Now, because we want to assert that the <code>togglePlayingState</code> callback is triggered as expected, we’re going to need to provide an implementation for this. Although we haven’t been providing a value for this I’m previous tests, we can’t perform assertions that this function is triggered without providing an implementation for it. So here we’re going to provide a mock implementation of this callback - allowing us to verify that it is triggered as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Toggle_Play_State_Triggered</span>() {
	<span class="syntax-all syntax-keyword">val</span> togglePlayingState<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> togglePlayingState
		)
	}
}</code></pre>

<p>As previously mentioned, this callback is triggered whenever the playback button in the <code>Controls</code> is clicked. We’re going to need to simulate this behaviour within our tests so that the callback is triggered - so we’ll retrieve the node for the playback button using the tag that we previously defined, followed by using the <code>performClick</code> function to perform a click interaction on the node.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Toggled_Play_State_Triggered</span>() {
	<span class="syntax-all syntax-keyword">val</span> togglePlayingState<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> togglePlayingState
		)
	}
	composeTestRule.onNodeWithTag(
		<span class="syntax-all syntax-entity">TAG_CONTROL_BUTTON</span>
	).performClick()
}</code></pre>

<p>When this interaction takes place, it would be expected that our <code>togglePlayingState </code> callback is triggered - if it’s not, then it would mean that our playback button isn’t quite working as expected. We have a mock implementation of this callback in place, so we can use this to verify interactions. </p>

<p>For this we’re going to utilise the mockito <code>verify</code> functionality - this allows us to assert that our callback has been triggered within the scope of our test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Toggled_Play_State_Triggered</span>() {
	<span class="syntax-all syntax-keyword">val</span> togglePlayingState<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">Controls</span>(
			playerStatus <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PlayerStatus</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
			togglePlayingState <span class="syntax-all syntax-keyword">=</span> togglePlayingState
		)
	}
	composeTestRule.onNodeWithTag(
		<span class="syntax-all syntax-entity">TAG_CONTROL_BUTTON</span>
	).performClick()

	verify(togglePlayingState).invoke()
}</code></pre>

<p>Here this <code>verify</code> block will assert that our callback is invoked a single time. If this callback is not invoked, or if it is invoked multiple times from the single click event, then the test will fail. Otherwise, the test will be marked as a success as the callback will be triggered from the click event as expected.</p>

<hr />

<h2>Testing the Player</h2>

<p>Now that we have tests in place for our <code>Controls</code> composable, we’re going to need to write some tests for the top-level video player composable. This allows us to perform assertions to ensure that both the video player and controls are displayed on the screen as expected. </p>

<p>We’ll go ahead and start by creating a new test class, VideoTest, along with defining the test rule that will be used to launch our test composable and perform assertions against it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// VideoTest.kt
</span>
<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">VideoTest</span> {

	<span class="syntax-all syntax-keyword">@get:Rule
</span>	<span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>What we want to do in these tests is locate the nodes within our composable hierarchy that represent the controls and player, followed by asserting that they are displayed. So that we do this, we’ll need to add some more tags that can be assigned to these composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_VIDEO_PLAYER</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_VIDEO_PLAYER&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CONTROLS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_CONTROLS&quot;</span>
}</code></pre>

<p>In our first test, we’re going to assert that the controls are being composed inside of our <code>Video</code>, so we’ll need to start by assigning the <code>TAG_CONTROLS</code> tag to the parent container inside of the <code>Controls</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Controls.kt
</span>
<span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier
        .fillMaxWidth()
        .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface)
        .testTag(<span class="syntax-all syntax-entity">TAG_CONTROLS</span>),
    contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
)</code></pre>

<p>With this tag in place, we can now locate the node that represents the controls using <code>onNodeWithTag</code>, followed by asserting that it is displayed on the screen using <code>assertIsDisplayed</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Controls_Displayed_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Video</span>()
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_CONTROLS</span>
    ).assertIsDisplayed()
}</code></pre>

<p>For the next test, we’re going to take a similar approach, asserting that the video player is displayed. We’ll need to start by adding the tag to the <code>Playback</code> composable - we can assign this via the modifier that is passed into this composable within the <code>VideoPlayer</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// VideoPlayer.kt
</span>
<span class="syntax-all syntax-entity">Playback</span>(
	<span class="syntax-all syntax-entity">Modifier</span>
    	.fillMaxSize()
        .clickable(
        	onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> controlsClickLabel)
        ) {
        	controlsVisible <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>controlsVisible
        }
        .testTag(<span class="syntax-all syntax-entity">TAG_VIDEO_PLAYER</span>),
    videoState.playerStatus, context, exoPlayer
)</code></pre>

<p>Now that this tag is being assigned to our composable, we can take the same approach as the previous test. Here we’ll use the <code>TAG_VIDEO_PLAYER</code> tag to locate the node, followed by asserting its visibility via the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Video_Player_Is_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Video</span>()
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_VIDEO_PLAYER</span>
    ).assertIsDisplayed()
}</code></pre>

<hr />

<p>With all of these tests in place, we’ve covered a lot of different cases that help to ensure our UI is working as expected. We’ve not only tested that composables are being composed based on the information that they are provided with, but also that they triggered the expected callbacks and trigger state manipulations within our composables. While the tests here aren’t extensive, we’ve been able to learn not only what options are available to us while testing composables, but also the approaches that we can take when doing so.</p>

<h1>Building a Messaging UI</h1>

<p>Messaging is a feature that we see in many applications - whether it’s SMS apps, social media apps or any other kind of conversational tool, messaging provides ways for our users to communicate with one another. These types of UIs tend to have a lot of consistent features across them, providing an interesting implementation for us to tackle with Jetpack Compose. Not only do we need to think about the different types of messages that are being rendered on screen, but also provide support for the user to compose messages to be sent via the messaging feature.</p>

<p>With this in mind, we’re going to build out a messaging feature using jetpack compose. We’ll not only display the different types of text/image messages from a conversation but also allow the user to send messages to be added to the conversation. Building this will give us a space to think about the different constraints that are involved when it comes to building a messaging UI, while also giving us some intricate logic to implement when it comes to specific messaging features (such as @ mentioning contacts).</p>

<figure><img src="message.png"/></figure>

<p>When it comes to this screen, we need to configure and handle several different things.</p>

<ul>
	<li>Build out a list that supports the display of messages</li>
	<li>Separate these messages by sent date via the use of sticky headers</li>
	<li>Handle the state when there are no messages that exist in a conversation</li>
	<li>Support both text and image message formats</li>
	<li>Add clarity around message information, making it clear what is a sent/received message as well as allowing the sent time of a message to be revealed</li>
	<li>Allow the user to compose messages to be added to the conversation</li>
	<li>Allow the user to unsend messages that they have sent in the conversation</li>
	<li>Support @ mentions so that users in the conversation can be tagged, while also supporting the highlighting of these tags within the UI</li>
	<li>Ensure that all of the above features remain accessible for all users of our messaging application, specifically via the use of accessibility services</li>
</ul>

<p>We can see here that there’s a collection of things here that we’re going to want to tackle. Don’t worry though, we’ll approach this incrementally so that we will start with a functional messaging app, building out its feature set piece by piece to add value for our users. With all this in mind, let’s get started with building out our messaging app!</p>

<h1>Defining the Messaging State</h1>

<p>Within our messaging screen, we’re going to be displaying a list of grouped message items - each item will be used to represent the contents of a message item, with there being some similarities between how each is composed. While each of these items is going to be used to represent the messages from a conversation, the state of our screen is going to be made up of several different variables.</p>

<ul>
	<li>A list of items that represent that messages within the conversation</li>
	<li>The list of contacts that are available to the user for tagging</li>
	<li>The currently selected message within the conversation, if any</li>
</ul>

<p>While there are going to be a few different things to build out in the UI, there isn’t too much state for us to model at this point. Let’s start to take the above requirements and build out a class that will represent the state of our composable UI. We’ll start by creating a new class to hold the state of our screen:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationState</span>()</code></pre>

<hr />

<h2>Modelling Messages</h2>

<p>With our messaging screen, we’re going to be displaying a list of messages - each item will represent the same message UI component but will be tailored to the message that is being represented. We’re going to start here by creating a new class, <code>Message</code>, that will be used to hold the various pieces of information for a message item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">direction</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MessageDirection</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">dateTime</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Calendar</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">sender</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">@DrawableRes</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">image</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">altText</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>We can see here that various fields are going to be holding information around any given message</p>

<ul>
	<li><strong>id</strong>: the unique ID belonging to the message item</li>
	<li><strong>dateTime</strong>: the time which the message was sent</li>
	<li><strong>sender</strong>: the name of the contact that sent the message</li>
	<li><strong>message</strong>: the textual content of the message, if any</li>
	<li><strong>image</strong>: the image content of the message, if any</li>
	<li><strong>altText</strong>: the content description for describing the image</li>
</ul>

<p>💡 In a real application you’d likely use some form or URL or URI for an image - to keep the project focused, we’re using a drawable resource here. This allows us to focus on some of the aspects involved with image loading within another project of the book.</p>

<p>We can see from this that there is sufficient information for us to be able to build out the content for each of the message items. When it comes to the representation of a message within our UI it’ll also be helpful to know whether the message was <strong>received</strong> or <strong>sent</strong>. To define this within our <code>Message</code> we’re going to create a new enum that will allow us to define the supported message directions to be used by a <code>Message</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MessageDirection</span> {
    <span class="syntax-all syntax-entity">RECEIVED</span>, <span class="syntax-all syntax-entity">SENT</span>
}</code></pre>

<p>With this in place, we can now slot this into our <code>Message</code> class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">direction</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MessageDirection</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">dateTime</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Calendar</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">sender</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">@DrawableRes</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">image</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">altText</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>Now that the <code>Message</code> class is defined, we can go ahead and add a list of <code>Message</code> items to the state class that we defined earlier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt; <span class="syntax-all syntax-keyword">=</span> emptyList()
)</code></pre>

<p>For this project, we’re not going to focus too much on the different states of the screen (empty, error, content etc). We’re also going to want to have a collection of messages to be displayed in our UI - we don’t have any form of web resource that we can query here (or want to implement that), so we’re going to create a factory class that will build a list of <code>Message</code> items. Feel free to structure the content of these how you like, or simply copy this over from the sample project.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> MessageFactory {

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeMessages</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt; {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
            <span class="syntax-all syntax-entity">Message</span>(
                <span class="syntax-all syntax-string">&quot;0&quot;</span>,
                <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>,
                <span class="syntax-all syntax-entity">Calendar</span>.getInstance().<span class="syntax-all syntax-constant">also</span> {
                    it.add(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">DAY_OF_YEAR</span>, <span class="syntax-all syntax-keyword">-</span><span class="syntax-all syntax-constant">5</span>)
                    it.set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">HOUR_OF_DAY</span>, <span class="syntax-all syntax-constant">5</span>)
                },
                <span class="syntax-all syntax-string">&quot;Joe Birch&quot;</span>,
                <span class="syntax-all syntax-string">&quot;Hey!&quot;</span>
            ),
            <span class="syntax-all syntax-entity">Message</span>(
                <span class="syntax-all syntax-string">&quot;1&quot;</span>,
                <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">RECEIVED</span>,
                <span class="syntax-all syntax-entity">Calendar</span>.getInstance().<span class="syntax-all syntax-constant">also</span> {
                    it.add(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">DAY_OF_YEAR</span>, <span class="syntax-all syntax-keyword">-</span><span class="syntax-all syntax-constant">5</span>)
                    it.set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">HOUR_OF_DAY</span>, <span class="syntax-all syntax-constant">5</span>)
                },
                <span class="syntax-all syntax-string">&quot;Joe Birch&quot;</span>,
                <span class="syntax-all syntax-string">&quot;Hey!&quot;</span>
            ),
            <span class="syntax-all syntax-entity">Message</span>(
                <span class="syntax-all syntax-string">&quot;2&quot;</span>,
                <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">RECEIVED</span>,
                <span class="syntax-all syntax-entity">Calendar</span>.getInstance().<span class="syntax-all syntax-constant">also</span> {
                    it.add(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">DAY_OF_YEAR</span>, <span class="syntax-all syntax-keyword">-</span><span class="syntax-all syntax-constant">4</span>)
                    it.set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">HOUR_OF_DAY</span>, <span class="syntax-all syntax-constant">4</span>)
                },
                <span class="syntax-all syntax-string">&quot;Joe Birch&quot;</span>,
                <span class="syntax-all syntax-string">&quot;How is Roxy? 😊&quot;</span>
            ),
            <span class="syntax-all syntax-entity">Message</span>(
                <span class="syntax-all syntax-string">&quot;4&quot;</span>,
                <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>,
                <span class="syntax-all syntax-entity">Calendar</span>.getInstance().<span class="syntax-all syntax-constant">also</span> {
                    it.add(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">DAY_OF_YEAR</span>, <span class="syntax-all syntax-keyword">-</span><span class="syntax-all syntax-constant">2</span>)
                },
                <span class="syntax-all syntax-string">&quot;Joe Birch&quot;</span>,
                <span class="syntax-all syntax-string">&quot;She is doing great!&quot;</span>
            ),
            <span class="syntax-all syntax-entity">Message</span>(
                <span class="syntax-all syntax-string">&quot;5&quot;</span>,
                <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>,
                <span class="syntax-all syntax-entity">Calendar</span>.getInstance().<span class="syntax-all syntax-constant">also</span> {
                    it.add(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">DAY_OF_YEAR</span>, <span class="syntax-all syntax-keyword">-</span><span class="syntax-all syntax-constant">2</span>)
                },
                <span class="syntax-all syntax-string">&quot;Joe Birch&quot;</span>,
                image <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.drawable.roxy
            )
        )
    }

}</code></pre>

<p>💡 For the image resource of the last message, you’ll find this over in the sample project drawable directory.</p>

<p>We can then use this factory directly within our state class, allowing a list of messages to be populated by default.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt; <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages()
)</code></pre>

<hr />

<h2>Modelling Contacts</h2>

<p>Aside from the messages that represent the current state of the screen, we also want access to the contacts which the user has access - this is what will be used for the contact tagging functionality within the messaging feature. We’ll start here by creating a new class, <code>Contact</code>. This will hold a single field in the form of a contact <code>name</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Contact</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">name</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)</code></pre>

<p>Similar to our <code>Message</code> items, we’re going to want to have a list of contacts available for us to model our UI from. For this, we’ll create another factory that will be used to generate a list of <code>Contact</code> items for us to plug into our state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> ContactFactory {

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeContacts</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt; {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
            <span class="syntax-all syntax-entity">Contact</span>(<span class="syntax-all syntax-string">&quot;Joe&quot;</span>),
            <span class="syntax-all syntax-entity">Contact</span>(<span class="syntax-all syntax-string">&quot;Ellie&quot;</span>),
            <span class="syntax-all syntax-entity">Contact</span>(<span class="syntax-all syntax-string">&quot;Anna&quot;</span>),
            <span class="syntax-all syntax-entity">Contact</span>(<span class="syntax-all syntax-string">&quot;Rachel&quot;</span>),
            <span class="syntax-all syntax-entity">Contact</span>(<span class="syntax-all syntax-string">&quot;Ross&quot;</span>),
            <span class="syntax-all syntax-entity">Contact</span>(<span class="syntax-all syntax-string">&quot;Mark&quot;</span>),
            <span class="syntax-all syntax-entity">Contact</span>(<span class="syntax-all syntax-string">&quot;Jake&quot;</span>)
        )
    }
}</code></pre>

<p>We’ll then use this to generate a list of <code>Contact</code> items for the <code>contacts</code> data within our state class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt; <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages(),
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt; <span class="syntax-all syntax-keyword">=</span> 
		<span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
)</code></pre>

<hr />

<h2>Modelling the Selected Message</h2>

<p>When it comes to the various messaging features, one of the things we’ll be supporting is the deletion of a message. This means that the user will need to be able to select a message so that we can display a collection of options for it. We’re going to make this a part of our global state, as these options are going to be something that blocks the current UI until the user decides to either execute an action (or dismiss the options). For this we can add a new field to our state, <code>selectedMessage</code>, which will represent the currently selected message from a conversation (if any).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt; <span class="syntax-all syntax-keyword">=</span> 	
		<span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages(),
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt; <span class="syntax-all syntax-keyword">=</span> 
		<span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts(),
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">selectedMessage</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>With this in place, we now support the selecting of a <code>Message</code> to execute an action. When the message is unselected, this state item can be marked as null to represent that there is no longer a selected message in the list.</p>

<hr />

<p>With all of this in place, we now have a class that can be used to represent the state of our UI. Over the next few sections of this chapter, we’ll utilise this state when building out our UI, modifying its values as interactions with composables take place, triggering recompositions to reflect any state changes.</p>

<h1>Creating the Messaging ViewModel</h1>

<p>Now that we have the state modelled for our Messaging screen, we can start thinking about the ViewModel that will be used to manage that state and provide a way to orchestrate it to the user interface. </p>

<hr />

<h2>Setting up the ViewModel</h2>

<p>Before we can get started here, we’re going to add a new dependency to our project that will give us access to the Android Lifecycle ViewModel class:</p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span></code></pre>

<p>💡 You aren’t required to use a ViewModel when working with compose. For the sake of these exercises, it helps us to keep things simple and follow an approach that many developers are familiar with.</p>

<p>Next, we’ll create a new ViewModel, called <code>ConversationViewModel</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

}</code></pre>

<p>This <code>ViewModel</code> is going to need to hold a reference to the state of our screen. For this we’re going to utilise <code>StateFlow</code> - this allows us to create a state-holder observable flow that will emit the default state we provide to it, along with any updates that occur during its lifetime. Here we’ll create a new <code>MutableStateFlow</code> instance, providing a reference to our <code>ConversationState</code> class as the default value for our <code>StateFlow</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

	<span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">ConversationState</span>())

}</code></pre>

<p>With this in place, we now have a StateFlow reference that is holding a reference to our authentication state, initialising it with a new instance of the state class and relying on the defaults that the constructor provides.</p>

<hr />

<h2>Manipulating state using events</h2>

<p>While this state is now in place, we need to start thinking about the different ways in which it can be manipulated - whenever something is changed in our UI (message sent, message removed etc), we’ll want to update the state within our ViewModel so that the observing UI can reflect those changes. </p>

<p>For when this is the case, we’re going to model some events that can be triggered in our composable UI and in turn these events will be used to manipulate the state within the view model. This allows us to have a single way of our composable UI communicating with the ViewModel, rather than needing to pass the entire ViewModel or many references to separate functions which could be used to trigger state changes. Instead, we can pass a single function reference to our composable UI which can then be used to trigger these events in the ViewModel. For these events we’re going to need to define different types that can be triggered, so we’ll go ahead and create a new sealed class to represent these.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ConversationEvent.kt
</span><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationEvent</span> {

}</code></pre>

<h3>Handling message sending</h3>

<p>With this sealed class in place, we can start to think about using it to represent the different events that can occur. We’re going to start by handling the scenario where the user sends a message - we’ll call this event <code>SendMessage</code>, declaring a <code>message</code> argument to be used for the content of the message.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationEvent</span> {

    <span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SendMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) : 	
		<span class="syntax-all syntax-entity">ConversationEvent</span>()

}</code></pre>

<p>With this event in place, this can now be triggered from our composable UI to cause a state change within our view model. For that to happen though, we need to write this logic inside of our ViewModel. When a message is to be sent, we’re going to want to create a new instance of the <code>Message</code> class that represents the data that has been provided. We’ll create a new function called <code>buildMessage</code> which will be used to build out our <code>Message</code> reference:</p>

<ul>
	<li><strong>id</strong>: for the ID we’ll simply use the number of messages in our list, this means that the ID will incrementally increase every time a message is sent</li>
	<li><strong>direction</strong>: because we are sending a message, the direction, in this case, will always be <code>SENT</code></li>
	<li><strong>dateTime</strong>: for the sent time of the message, we’ll fetch the current representation of time using the <code>Calendar</code> class to use the time from</li>
	<li><strong>sender</strong>: because we are sending a message, this is always going to represent the current user. So for this, we’ll simply send “me”</li>
	<li><strong>message</strong>: for the message content we are going to pass the <code>message</code> argument that is provided to our function</li>
	<li><strong>image</strong>: we are not going to be supporting the sending of image messages, so we don’t send a value for this</li>
	<li><strong>altText</strong>: we are not going to be supporting the sending of image messages, so we don’t send a value for this</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildMessage</span>(<span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span> {
	<span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-entity">Message</span>(
		uiState.value.messages.count().toString(),
		<span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>, 
		<span class="syntax-all syntax-entity">Calendar</span>.getInstance(), 
		<span class="syntax-all syntax-string">&quot;me&quot;</span>,
		message
	)
}</code></pre>

<p>With this function in place, we’re going to use this to create a <code>Message</code> to be added to the list of messages. In a real scenario, we would be sending this data to an API, so we’re going to need to model this message list modification ourselves. Here we’ll want to take the current list of messages, convert the list to a mutable list so that we can modify its contents, add the result of our <code>buildMessage</code> as an item of this list, followed by converting the list back to an immutable list. With this in place, we can now update the state of our screen, creating a modified version of the existing state using the kotlin <code>copy</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>) {
	<span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
		<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">SendMessage</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    messages <span class="syntax-all syntax-keyword">=</span> uiState.value.messages
						.toMutableList().<span class="syntax-all syntax-constant">apply</span> {
                        	add(buildMessage(
								authenticationEvent.message))
                    }.toList()
                )
            }
	}
}

<span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildMessage</span>(<span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span> {
	<span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-entity">Message</span>(
		uiState.value.messages.count().toString(),
		<span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>, 
		<span class="syntax-all syntax-entity">Calendar</span>.getInstance(), 
		<span class="syntax-all syntax-string">&quot;me&quot;</span>,
		message
	)
}</code></pre>

<p>💡 The copy function in Kotlin copies the existing class reference, replacing any values that have been provided as arguments to the function.</p>

<h3>Handling message unsending</h3>

<p>As well as having the ability to send a message, we’re also going to allow a user to unsend any messages that they have sent. To support this we’re going to add a new event, <code>UnsendMessage</code>. This is going to need to allow an <code>id</code> to be provided, which represents the <code>id</code> of the message that is being unsent.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationEvent</span> {

    <span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SendMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) : 	
		<span class="syntax-all syntax-entity">ConversationEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">UnsendMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>()

}</code></pre>

<p>When a message is unsent, we’re going to want to remove it from the list of messages that is currently in our state. Again, this would be handled by an API in the real world, but we’re going to need to model this ourselves. What we’ll do here is take a similar approach as we did for sending a message, but instead we will need to remove the item whose <code>id</code> matches the specified <code>id</code>. We can do this by locating the index of the first item that satisfies those conditions, using the <code>indexOfFirst</code> kotlin function. This will give us the index of the first item that matches our check, which we can then use for the <code>removeAt</code> function to remove the item from the list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">messagesExcluding</span>(<span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt; {
	<span class="syntax-all syntax-keyword">return</span> uiState.value.messages
		.toMutableList().<span class="syntax-all syntax-constant">apply</span> {
			removeAt(
				uiState.value.messages.indexOfFirst {
					it.id <span class="syntax-all syntax-keyword">==</span> authenticationEvent.id
				}
			)
		}.toList()
}</code></pre>

<p>With this function in place, we can now hook this up to the <code>UnsendMessage</code> event. For this, we’ll want to use our <code>messagesExcluding</code> function to create the new list of messages based on the removal, followed by updating the <code>messages</code> value in our state with the result.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>) {
	<span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
		...,
		<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">UnsendMessage</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    messages <span class="syntax-all syntax-keyword">=</span> messagesExcluding(
						authenticationEvent.id)
                )
            }
	}
}</code></pre>

<h3>Handling message selection</h3>

<p>Alongside the sending and unsending of messages, we’ll also need to add support for message selection via the <code>ConversationEvent</code>. This is so that a message can be selected and the options for that message can be invoked, which will allow the user to trigger the <code>UnsendMessage</code> event that we previously modelled. To select a message, we’ll need to know the <code>id</code> of the message being selected - we’ll allow this to be provided through a new <code>SelectMessage</code> event.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationEvent</span> {

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">UnsendMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>()

    <span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SendMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) : 	
		<span class="syntax-all syntax-entity">ConversationEvent</span>()

	<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SelectMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>()
}</code></pre>

<p>We’ll then want to handle this event inside of our <code>handleEvent</code> function. For this, we’ll want to set the corresponding message as the <code>selectedMessage</code> within our state. For this, we’ll use the existing list of messages to <code>find</code> the corresponding message whose <code>id</code> matches the one provided through the event. Once this is found, the result (which is the corresponding <code>Message</code>) will be assigned to the <code>selectedMessage</code> in our state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>) {
	<span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
		...,
		<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">SelectMessage</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
			uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
				selectedMessage <span class="syntax-all syntax-keyword">=</span> uiState.value.messages.find { it.id <span class="syntax-all syntax-keyword">==</span> authenticationEvent.id }
            )
        }
	}
}</code></pre>

<h3>Handling message unselection</h3>

<p>Because a message can be selected, we’ll also need to support a message being unselected. When a message is selected, a dialog of options will be shown on the screen, this will be shown based on there being a <code>selectedMessage</code> value in the state. We’ll create a new <code>UnselectMessage</code> event type that can then be used to clear the selected message so that the dialog can be hidden.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationEvent</span> {

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">UnsendMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>()

    <span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SendMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) : 	
		<span class="syntax-all syntax-entity">ConversationEvent</span>()

	<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SelectMessage</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> UnselectMessage <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>()
}</code></pre>

<p>Then within our <code>handleEvent</code> function, we’re going to want to handle this <code>UnselectMessage</code> event type. Within this block, we’ll want to update our state so that there is no longer a selected message - which can be done by assigning a null value to the <code>selectedMessage</code> field.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">authenticationEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>) {
	<span class="syntax-all syntax-keyword">when</span> (authenticationEvent) {
		...,
		<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">UnselectMessage</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                selectedMessage <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
            )
        }
	}
}</code></pre>

<hr />

<p>With this implemented, we are now managing the state of our messaging screen and providing the required entry points for our UI layer to manipulate the state based on user interaction. Our view model is now ready to be plugged into a composable UI, which we’ll create in the next section of this chapter!</p>

<h1>Creating the Messaging UI</h1>

<p>With the view model and state management all in place, we’re ready to move on and start implementing the composable UI for our Messaging app. </p>

<figure><img src="intro-6.png"/></figure>

<p>When we’re finished building this UI, we’re going to end up with something that looks like the following:</p>

<figure><img src="message-1.png"/></figure>

<p>This UI will give our users a screen that displays a list of pre-existing messages, grouped by sticky date headers - the user will also be able to send messages to be added to that list. Building this UI will allow us to work with a range of compose features while adding some subtle niceties to the UI in the process.</p>

<hr />

<h2>Setting up the entry point</h2>

<p>Before we can get start building our project, we’re going to need to add a couple of dependencies that we’re going to need. We’ll start here by adding these to the <code>build.gradle</code> file for our new project:</p>

<pre><code class="code-highlighted code-kt">implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.foundation:foundation:$compose_version&quot;</span>
implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui:$compose_version&quot;</span>
implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material:$compose_version&quot;</span>
implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material-icons-extended:$compose_version&quot;</span>
implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span></code></pre>

<p>The current release of this book is building against 1.1.0 of compose - be sure to check compatibly if using a newer version.</p>

<ul>
	<li><strong>foundation</strong>: provides foundational composables, such as layouts and commonly required modifiers</li>
	<li><strong>ui</strong>: provides access to ui related composables, such as drawing and general components</li>
	<li><strong>material</strong>: provides access to compose material UI components</li>
	<li><strong>material-icons-extended</strong>: provides access to an extended collection of iconography</li>
	<li><strong>lifecycle-viewmodel-compose</strong>: provides functionality for providing view models directly inside of composables</li>
</ul>

<p>With these added to our project, we’re now ready to start building out our UI. We’re going to start here by building the access point to our feature - this is how the messaging feature will initially be composed within our user interface. To make this an argument-less access point, we’re going to start with a new composable function, <code>Messaging</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messaging.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messaging</span>()</code></pre>

<p>While you won’t see anything visual just yet, you’ll want to compose this <code>Messaging</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Messaging</code> when running the project.</p>

<p>Before we get started with any composition of messaging specific UI, we’re going to start by declaring the use of the <code>MaterialTheme</code> composable, this will be in place ready to wrap any composition and apply the expected material theming to our project. This isn’t a requirement, but if not provided then you would need to manually style each composable to adhere to material requirements. We’re not going to be doing any theme customisation here, so this will be using the default colors.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messaging.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messaging</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        ...
    }
}</code></pre>

<p>We can see here that we currently have a blank <code>content</code> block, this means that nothing is currently going to be composed in our UI. A mentioned previously, this is just an argument-less entry point to our feature, but we’re going to need access to the state configuration that we set up over the last few chapters. Here, we’re going to utilise the ViewModel related dependency that we added to our project. Using its <code>viewModel()</code> function, we’ll go ahead and retrieve an instance of the <code>ConversationViewModel</code>. This will return an existing reference to the ViewModel, creating a new one if it does not currently exist.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messaging.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messaging</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        ...
    }
}</code></pre>

<p>With this in place, we have our ViewModel, as well as access to our state through this ViewModel. Now though, we need to set ourselves up to be able to compose UI based on this state. Here we’re going to create a separate composable function that takes the <code>ConversationState</code> class, composing UI from it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Conversation.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Conversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationState</span>
)</code></pre>

<p>💡 Declaring a Modifier argument for your composable functions allows the layout constraints of the composable to be delegated to the parent. This helps to keep your composables reusable, as they are not being constrained for a specific scenario.</p>

<p>Not only does having this separate composable keep the responsibilities of our composable functions smaller, but it also will help us with testing later on. Having this separate <code>Conversation</code> composable with a <code>ConversationState</code> argument means that we can provide state within our tests, perform asserts based on the expected composition from our state. Testing against an argument-less composable function would require us to interact with the UI to manipulate the state, which adds friction during the testing process.</p>

<p>Now that we have this composable in place, we’re ready to compose this inside of our <code>Messaging</code> composable. We can provide two arguments to our <code>Conversation</code> - <code>modifier</code> and <code>state</code>, which the second is <strong>required</strong>. For the <code>modifier</code>, we’ll simply utilise the <code>fillMaxSize</code> modifier - which will instruct the contained composable to use all of the size that it has available to it.</p>

<p>We’ll also need to provide a reference to a <code>ConversationState</code>, which we’ll access through our <code>ConversationViewModel</code>. Here we’re going to use the <code>collectAsState()</code> - because our state is represented within our ViewModel as a <code>StateFlow</code>, we’re going to want to collect the events from here. <code>collectAsState()</code> allows us to collect the emissions from our <code>StateFlow</code> as composable state, meaning that our composables can be recomposed accordingly whenever the state is changed. We’ll need to access the <code>value</code> from the<code>StateFlow</code> and pass this directly to the <code>state</code> argument of our <code>Conversation</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messaging</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">Conversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            state <span class="syntax-all syntax-keyword">=</span> viewModel.uiState.collectAsState().value
        )
    }
}</code></pre>

<p>At this point, we won’t be able to see anything being composed within our UI, but we’re all set up ready to start building out our messaging interface.</p>

<hr />

<h2>Setting up the Conversation feed</h2>

<figure><img src="1-20.png"/></figure>

<p>Now that we have our <code>Conversation</code> being composed at the root of our Messaging screen, we can start to think about building out the composables that are going to make up the different parts of our conversational UI. Within this UI we’re going to display a vertical stack of composables, so we’re going to start here by composing a <code>Column</code>, passing the <code>Modifier</code> that has been provided to our composable function. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Conversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationState</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
    ) {
        
    }
}</code></pre>

<p>From within our <code>Messaging</code> composable we are passing the <code>fillMaxWidth()</code> modifier, meaning that our <code>Conversation</code> is going to fill all of the available space both horizontally and vertically.</p>

<p>Because we’re using a <code>Column</code>, any children that we compose within the <code>content</code> area are going to be stacked horizontally. Let’s start by taking a look at the first child we’ll compose here.</p>

<h3>Creating a header for our screen</h3>

<figure><img src="2-19.png"/></figure>

<p>We’re going to be adding an app bar to our screen in the form of a <code>TopAppBar</code>. While it would be more than OK to do so, won’t be using the <code>Scaffold</code> composable here - we don’t have much of a need for the other functionality that compose offers, so we’ll just rely on this being composed as the first child of our <code>Column</code> for now. We will also be exploring some animations later in this chapter, so relying on our own parent container implementation will make this simpler.</p>

<p>We’ll start here by defining a new composable that will house our app bar, <code>Header</code>, which will take <code>Modifier</code> and provide the default <code>Modifier</code> if one is not provided.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>Next, we’re going to compose a <code>TopAppBar</code> inside of our composable function, using the <code>Modifier</code> argument from our composable as the <code>modifier</code> for this app bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">TopAppBar</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
       
    }
}</code></pre>

<p>💡 The TopAppBar provides us with an App Bar implementation for displaying key information and actions for the current context of the screen.</p>

<p>From this app bar we’re going to be displaying two things:</p>

<ul>
	<li>A close icon that will exit the messaging app</li>
	<li>A title that will represent the current conversation name (this will be static for examples sake)</li>
</ul>

<p>We’ll start here with the close icon, which we’ll need to add a content description for to our <code>strings.xml</code> file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_close_conversation&quot;</span>&gt;
	Close Conversation
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>💡Content Descriptions allow us to provide a textual description for visual elements, used by accessibility services to provide additional context to users.</p>

<p>With this content description in place, we can add the composable that will both house the close icon, as well as provide the click functionality for closing the messaging screen. For this we’re going to utilise the <code>IconButton</code> composable, this allows us to use built-in button support in the form of an icon. We’ll start here by providing a composable for the <code>content</code> of our <code>IconButton</code>, composing an <code>Icon</code>. We’ll use the <code>Icons.Default.Close</code> icon from the material package, along with setting the content description by retrieving the string resource we defined above via the <code>stringResource</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">TopAppBar</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {

        }) {
            <span class="syntax-all syntax-entity">Icon</span>(
                imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Close</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_close_conversation)
            )
        }
    }
}</code></pre>

<p>💡The IconButton allows us to provide clickable icons that adhere to minimum sizing constraints for intractable components, making them fully accessible for our users.</p>

<p>With the above in place, we’ll also want to provide functionality for the <code>onClick</code> argument of our <code>IconButton</code>. We’ll want to pass this event up to the parent composable to be handled, so we’ll pass in a lambda function to our <code>Header</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With this lambda function now in place, we can trigger this within the implementation of the <code>IconButton</code> <code>onClick</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">TopAppBar</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_HEADER</span>)
    ) {
        <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
            onClose()
        }) {
            <span class="syntax-all syntax-entity">Icon</span>(
                imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Close</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_close_conversation)
            )
        }
    }
}</code></pre>

<p>With this in place, we now have a <code>TopAppBar</code> implementation that is displaying a close icon at the start.</p>

<figure><img src="head_1.png"/></figure>

<p>The icon alone leaves our app bar feeling kind of empty, so we’re going to go ahead and add a title. Ideally, this would be a dynamic value that is provided by the current conversations, but for our project, we’ll need to add a new string resource to represent this title.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;title_chat&quot;</span>&gt;Group Chat&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With this resource in place, we can now compose this using the <code>Text</code> composable. We’ll again use the <code>stringResource</code> composable function to retrieve the string value from our resources to provide for the <code>text</code> argument, along with setting the size of this text using the <code>fontSize</code> argument, providing a value of <code>18.sp</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TopAppBar</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
            onClose()
        }) {
            <span class="syntax-all syntax-entity">Icon</span>(
                imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Close</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_close_conversation)
            )
        }
        <span class="syntax-all syntax-entity">Text</span>(
			text <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.title_chat), 
			fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp
		)
    }
}</code></pre>

<p>Now that we’ve completed the implementation of our <code>Header</code> composable, we just need to compose this within our UI. We’ll add this as a child of our column, passing the <code>fillMaxWidth</code> modifier so that our app bar fills the available width. For now, we won’t be implementing the closing of our messaging feature, so we’ll leave this implementation blank for now.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Conversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-entity">Header</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            onClose <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-comment">// close messaging app
</span>            }
        )
    }
}</code></pre>

<p>With this <code>Header</code> now being composed in our UI, we can see an app bar implementation at the top of our screen, displaying the name of the current conversation.</p>

<figure><img src="head_2.png"/></figure>

<hr />

<h2>Displaying Messages</h2>

<p>Now that our header is being displayed, we’re going to want to show the key part of our messaging feature - the message list! For our messaging list, we’re going to need to build up a collection of different components:</p>

<ul>
	<li>An empty state that will be used when there are no messages</li>
	<li>The list that will be used to display a collection of messages</li>
	<li>The items that make up the messages within the list</li>
	<li>Sticky headers that will be used to group messages by date</li>
</ul>

<figure><img src="oneee.png"/></figure>

<p>In order to build all of the above, we’ll need to start by building out the composable that will be used to house all of the above, <code>Messages</code>. This is going to take a <code>modifier</code> argument, along with a list of <code>Message</code> instances - this will also be a nullable type, as there may not always be messages available to display.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {

}</code></pre>

<h3>Handling the Empty State</h3>

<figure><img src="3-16.png"/></figure>

<p>As mentioned above, we marked the <code>messages</code> argument as nullable. Aside from being null, this list of <code>Message</code> types could also be empty - in either of these scenarios, were going to want to display some form of empty state to the user. This is going to be a simple composable that displays a message to the user that there are no messages to display on the screen. We’ll add a string resource to our <code>strings.xml</code> file that will be used to represent this message.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_no_messages&quot;</span>&gt;
	No messages to display
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then create a new composable that will be used to represent our empty state. We’ll call this <code>EmptyConversaton</code> and again allow for a <code>Modifier</code> to be provided to the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmptyConversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>We’ll then use a <code>Box</code> composable as the container for the content of this empty view. We previously used the <code>Column</code> that is used to stack children vertically - when it comes to the <code>Box</code> composable, children are stacked on the z-axis which can allow for children to overlap. When working with single child containers, the <code>Box</code> is a great unsettled container.</p>

<p>Inside of this <code>Box</code>, we’re going to place a single child composable in the form of a <code>Text</code> composable. For this we’ll simply provide a value for the <code>text</code> argument, retrieving the string resource that we previously defined using the <code>stringResource</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">EmptyConversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
			id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_no_messages))
    }
}</code></pre>

<p>With this composable created, we now have a UI component that can be used to represent an empty state within our messaging UI.</p>

<figure><img src="emptyy.png"/></figure>

<p>The last thing left to do here is to compose this within our <code>Messages</code> composable. We’ll only want to do this when our <code>messages</code> reference is either null or empty, so we’ll wrap the composition of this composable in an <code>if</code> check that will perform this conditional check.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (messages.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">EmptyConversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
        )
    }
}</code></pre>

<p>When this is conditional check is satisfied, the <code>EmptyConversation</code> will be composed, otherwise, our <code>Messages</code> composable will display as blank.</p>

<h3>Displaying message items</h3>

<p>At this point we have our empty state being composed when required, but what about when we have messages to display? If the conditional check for null or empty <code>messages</code> is not satisfied, then we’re going to want to compose the list of messages.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (messages.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">EmptyConversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
        )
    } <span class="syntax-all syntax-keyword">else</span> {
		<span class="syntax-all syntax-comment">// display messages
</span>	}
}</code></pre>

<p>At this point, we’re going to focus on just displaying a list of messages with no further decorations or heading, but there’s going to be a couple of things that we’re going to need to build this out. Essentially, we’ll need to build a <code>Message</code> composable that takes a <code>Message</code> reference and composes the content of it - this could contain either text or an image for the message comment, as well as the time at which the message was received. We’ll need to start here by defining a new composable function, <code>Message</code>, that takes a <code>Modifier</code> as well as a <code>Message</code> to be used for composition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
)</code></pre>

<p>Our message is going to initially consist of two child composables - the body of the message (which will be either the text or an image), along with the time that the message was received. We’re going to want to stack these vertically, displaying the received time underneath the body of the message. </p>

<figure><img src="4-12.png"/></figure>

<p>With those requirements, we’ll need to use the <code>Column</code> composable, passing the modifier that was provided to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

    }
}</code></pre>

<h3>Creating the Message Body composable</h3>

<figure><img src="5-9.png"/></figure>

<p>Inside of this <code>Message</code> composable we’re going to what to compose the body of the provided <code>Message</code> instances. This is going to contain a bit of conditional logic, so to help keep things a little tidier here we’re going to split this out into a separate composable function, <code>MessageBody</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageBody</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
)</code></pre>

<p>Again, we allow a <code>Modifier</code> to be provided here to apply some constraints to the <code>MessageBody</code>, as well as providing the <code>Message</code> that we want to compose the body for. Inside of this composable function, we’re going to want to compose the body that the message contains - this is going to be either text or an image. We’ll first focus on composing the text for our message body - if the <code>message</code> property of our <code>Message</code> instance is not null, then this means that there is some text to display. In this case, we’ll compose a <code>Text</code> composable using this <code>message</code> property. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageBody</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (message.message <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>) {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            text <span class="syntax-all syntax-keyword">=</span> message.message
        )
    }
}</code></pre>

<p>When this <code>message</code> property is available, we’ll be able to see this text composed within our UI.</p>

<figure><img src="1-21.png"/></figure>

<p>In these cases that the <code>message</code> property is null, we’re going to want to check if there is an <code>image</code> property that we can compose. When this <code>image</code> property is not null then we’ll use the <code>Image</code> composable to display it within our message body. When composing this <code>mage</code> we’ll:</p>

<ul>
	<li>Fix the <code>size</code> to <code>120dp</code></li>
	<li>Set the bitmap of the composable to the image from our <code>Message</code></li>
	<li>Apply the content description using the <code>altText</code> of the <code>Message</code></li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageBody</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (message.message <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>) {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            text <span class="syntax-all syntax-keyword">=</span> message.message
        )
    } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">if</span> (message.image <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>) {
        <span class="syntax-all syntax-entity">Image</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier.size(<span class="syntax-all syntax-constant">120</span>.dp),
            bitmap <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BitmapFactory</span>.decodeResource(
                <span class="syntax-all syntax-entity">LocalContext</span>.current.resources, message.image
            ).asImageBitmap(),
            contentDescription <span class="syntax-all syntax-keyword">=</span> message.altText
        )
    }
}</code></pre>

<p>At this point, we can now also view a composed image within our UI when the <code>image</code> property has a value assigned to it.</p>

<figure><img src="imagee.png"/></figure>

<h3>Composing the Message Body composable</h3>

<p>Now that we have this <code>MessageBody</code> composable created and ready to go, we can compose it inside of our <code>Message</code> composable - let’s add it directly as a child of our <code>Column</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> parentModifier) {
        <span class="syntax-all syntax-entity">MessageBody</span>(
            message <span class="syntax-all syntax-keyword">=</span> message
        )
    }
}</code></pre>

<p>Within our <code>Message</code> composable, we’ll now be able to see the content of our <code>Message</code> being composed inside of this composable, via the <code>MessageBody</code> composable. At this point, things don’t look too different from what we previously saw in the screenshots for this composable, based on the <code>Message</code> being provided to the composable.</p>

<figure><img src="1-22.png"/></figure>

<p>We’re going to want to style our <code>Message</code> a bit so that it sits within the list of messages quite nicely. We want to create a container effect for our message so that the message is sitting inside a kind of padded box - giving it more prominence within our UI. For this we’re going to utilise the <code>Box</code> composable, using a couple of modifiers to apply this kind of styling.</p>

<p>We’ll make use of the <code>background</code> modifier to create a rounded box, followed by some padding to crate some visual spacing between the edges of the box and the content of our message. Now that our <code>MessageBody</code> is composed inside of this <code>Box</code>, we’re going to want to ensure that this is aligned in the center of this parent container. For the <code>MessageBody</code>, we&#39;ll go ahead and use the <code>align</code> modifier to align this in the <code>Center</code> of the parent composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {

    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .background(
                    <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">LightGray</span>,
                    <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">6</span>.dp)
                )
                .padding(<span class="syntax-all syntax-constant">8</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">MessageBody</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>)
                message <span class="syntax-all syntax-keyword">=</span> message
            )
        }
    }
}</code></pre>

<p>At this point, we now have our <code>MessageBody</code> being composed inside of this rounded box, position in the center and now appearing more prominent as a UI component.</p>

<figure><img src="2-20.png"/></figure>

<h3>Displaying the message sent time</h3>

<figure><img src="6-7.png"/></figure>

<p>We’re currently using the <code>Column</code> composable to contain the content of our <code>Message</code>, but we’re currently only composing a single child inside of it. As originally planned, we were going to utilise this <code>Column</code> to display the time that the message was sent. To do this we’ll use the <code>dateTime</code> property on the <code>Message</code> reference that is being passed to our composable function.</p>

<p>This reference is currently of the <code>Calendar</code> type, which we can’t directly use to display information within our UI. Instead, we’re going to need to take the time that this <code>Calendar</code> represents, and format it into a human-readable representation. We’re going to want to show this in an <strong>hour : minute</strong> format (e.g 12:00pm), so we’ll need to utilise the <code>SimpleDataFormat</code> class which will allow us to parse our <code>Calendar</code> time into a string of this format.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;hh:mm&quot;</span>)</code></pre>

<p>Within our composable, we don’t want this to be instantiated upon every recomposition of a <code>Message</code>, so we’re going to wrap this in <code>remember</code> </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember { <span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;hh:mm&quot;</span>) }</code></pre>

<p>💡 Remember allows us to persist values across compositions, avoiding classes being re-instantiated in cases where there has been no reason for change.</p>

<p>With this now in place we can use the <code>format</code> function to take the <code>Date</code> from our <code>Calendar</code> and parse it into the format that we have stated. We can then apply this directly to a <code>Text</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Text</span>(
	text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(message.dateTime.time)
)</code></pre>

<p>With this formatting now in place, we can slot this into our parent <code>Column</code> so that it is composed directly beneath our <code>MessageBody</code> content. In this process, we’ll also apply some padding to the top of our <code>Text</code> composable, along with overriding the <code>fontSize</code> to a value of <code>12sp</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {
	<span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember { <span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;hh:mm&quot;</span>) }
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .background(
                    <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">LightGray</span>,
                    <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">6</span>.dp)
                )
                .padding(<span class="syntax-all syntax-constant">8</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">MessageBody</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>),
                message <span class="syntax-all syntax-keyword">=</span> message
            )
        }
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
        	text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(message.dateTime.time),
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
        )
	}
}</code></pre>

<p>With this in place, we can now see the sent time of the message being set within our message content.</p>

<figure><img src="3-17.png"/></figure>

<h3>Composing the list of Messages</h3>

<figure><img src="lazy.png"/></figure>

<p>With all of the above in place, we now have a <code>Message</code> composable that can be used to display the content of the messages that are provided to the <code>Messages</code> composable function.</p>

<p>When these messages are provided to our composable function, we don’t exactly know how many are going to be provided. If this is many, then we want to ensure that we can optimally provide this - if we compose this inside of a <code>Column</code>, we’ll be composing all of these <code>Message</code> composables in one go, which isn’t going to be a very optimal experience in our UI. </p>

<p>To compose this efficiently, we’re going to use the <code>LazyColumn</code> composable. This allows us to compose items of a list in a way that ensure only what is needed at any time is actually composed. We can see this as a kind of smart composition, as messages won’t be composed until they are required (as in, coming into visibility) within our list. When composing this <code>LazyColumn</code>, we’ll also need to provide a reference to a <code>LazyListState</code> - this holds information on the current state of our <code>LazyColumn</code> and can be retrieved using the <code>rememberLazyListState</code> composable function. For now, we’ll pass this directly to the <code>state</code> argument, as we don’t need to interact with this state in any other way.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">LazyColumn</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
	state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
) {
            
}</code></pre>

<p>We can then slot this into our <code>Messages</code> composable, where we’ll also utilise the <code>contentPadding</code> argument to apply some padding to the top area of our <code>LazyColumn</code> content. Alongside this we’ll also provide a value for the <code>verticalArrangement</code> - this will be in the form of <code>spacedBy</code>, which allows us to declare how much spacing should be applied between each child of the list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (messages.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">EmptyConversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
        )
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState(),
            contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp),
			verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.spacedBy(<span class="syntax-all syntax-constant">16</span>.dp)
        ) {
            
        }
    }
}</code></pre>

<p>With this <code>LazyColumn</code> defined, we’re ready to compose our list of messages. When composing content inside of a <code>LazyColumn</code>, it needs to be done so within a <code>LazyListScope</code> - which can be achieved using one of the <code>items</code> extension functions. When using this <code>items</code> function we can provide a list that will then be used to build a collection of scoped items that are compatible with the <code>LazyColumn</code>.</p>

<pre><code class="code-highlighted code-kt">items(messageList) { message <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-comment">// compose message content
</span>}</code></pre>

<p>Within this block we can then compose our <code>Message</code> composable, passing in the current <code>Message</code> reference that is being provided as the <code>itemContent</code> of the <code>items</code> function call. This will mean that now for every item in the <code>messageList</code> reference, a <code>Message</code> composable will be composed when required by our <code>LazyColumn</code>. We’ll instruct this composable to fill the maximum width that is available to it by using the <code>fillMaxWidth</code> modifier, along with adding a <code>Spacer</code> beneath this composable to create some visual space between the different items in our list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (messages.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">EmptyConversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
        )
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState(),
            contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp),
			verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.spacedBy(<span class="syntax-all syntax-constant">16</span>.dp)
        ) {
            items(messageList) { message <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">Message</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
                    message <span class="syntax-all syntax-keyword">=</span> message
                )
            }
        }
    }
}</code></pre>

<p>Finally, we’ll need to compose our <code>Messages</code> composable inside of our <code>Conversation</code>, adding this beneath the previously added <code>Header</code> composable. Alongside providing the message from our state reference to the <code>messages</code> argument, we’ll assign a <code>weight</code> of <code>1f</code> so that the composable fills all of the available space within the <code>Conversation</code>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Conversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
    ) {
        <span class="syntax-all syntax-entity">Header</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            onClose <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-comment">// finish activity
</span>            }
        )
        <span class="syntax-all syntax-entity">Messages</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
            messages <span class="syntax-all syntax-keyword">=</span> state.messages
        )
    }
}</code></pre>

<p>With this added to our composition, we will now be able to see the messages from our state being composed within our UI.</p>

<figure><img src="tmp.png"/></figure>

<h3>Adding clarity to Sent and Received messages</h3>

<p>Now that we have a collection of messages being composed within our UI, we can start to think about how we can improve things visually. One thing that might stand out here is that it’s quite hard to differentiate what is a sent message and what is a received message. A common pattern here is to have sent and received messages aligned to opposite sides of the screen - so we’re going to adopt this here within our UI. To do so, we’ll need to hop on back over to our <code>Message</code> composable. Because we are telling the parent <code>Column</code> composable to fill the maximum width that it has available, we’ll want to align the child <code>Box</code> composable so that it will be aligned to either side of the parent <code>Column</code>. For this, we can use the <code>direction</code> of the current <code>Message</code> reference, along with the <code>Alignment</code> object which will allow us to align the composable accordingly. First, let’s calculate an <code>Alignment</code> based on this <code>direction</code>. If our direction is equal to <code>MessageDirection.SENT</code> then we’ll want to align the composable at the <code>End</code> of the <code>Column</code>, otherwise we’ll position it at the <code>Start</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> alignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
	message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
) {
	<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">End</span>
} <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span></code></pre>

<p>With this alignment calculated, we can now apply it to our <code>Box</code> composable, using the <code>align</code> modifier. We’ll also need to apply this modifier to the <code>Text</code> composable that is displaying the sent time so that it is also aligned accordingly. With this applied to the composables, the elements will be aligned accordingly on the horizontal axis of the <code>Column</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {

    <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember { <span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;hh:mm&quot;</span>) }
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {

		<span class="syntax-all syntax-keyword">val</span> alignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>) {
            <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">End</span>
        } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span>

        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
				.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment)
                .background(
                    <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">LightGray</span>,
                    <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">6</span>.dp)
                )
                .padding(<span class="syntax-all syntax-constant">8</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">MessageBody</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>),
                message <span class="syntax-all syntax-keyword">=</span> message
            )
        }
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
				.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment)
				.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
        	text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(message.dateTime.time),
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
        )
	}
}</code></pre>

<p>With this alignment now applied, we’ll be able to see our message content align to the corresponding side of the <code>Column</code>.</p>

<figure><img src="1-23.png"/></figure>

<p>We may notice here though, our message items are pressed quite tightly against the edges of our composable - which doesn’t look too great. What we’ll do here is add some padding to the parent container on the horizontal axis. To calculate this padding we’re going to again utilise the <code>direction</code> - because the <code>SENT</code> messages online need padding at the end and <code>RECEIVED</code> messages only need padding at the start. So here we’ll build a new modifier reference by chaining onto the <code>Modifier</code> that is provided to our composable function, assign some padding to it and then continue to pass this as the <code>modifier</code> argument for our <code>Column</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {

	<span class="syntax-all syntax-keyword">val</span> parentModifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
		message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
	) {
        modifier.padding(end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)
    } <span class="syntax-all syntax-keyword">else</span> modifier.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)

    <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember { <span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;hh:mm&quot;</span>) }
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> parentModifier) {

		<span class="syntax-all syntax-keyword">val</span> alignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>) {
            <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">End</span>
        } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span>

        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
				.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment)
                .background(
                    <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">LightGray</span>,
                    <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">6</span>.dp)
                )
                .padding(<span class="syntax-all syntax-constant">8</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">MessageBody</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>),
                message <span class="syntax-all syntax-keyword">=</span> message
            )
        }
        <span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
				.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment)
				.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
        	text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(message.dateTime.time),
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
        )
	}
}</code></pre>

<p>With this padding applied, we can see that our <code>Message</code> items now sit nicely within our UI and are no longer pressed against the edges of our composable.</p>

<figure><img src="2-21.png"/></figure>

<h3>Showing and hiding the message sent time</h3>

<p>Looking at our message feed, it’s fair to say that some users might find it cluttered. While we have a couple of UI components that are showing for each message, some of those elements don’t need to be displayed all of the time. For example, the sent time on our messages is always visible - this is something that we don’t need to show all of the time. A common pattern in messaging apps is to only show the sent time when the message is tapped - we’re going to implement this behaviour for our message items.</p>

<p>We’re going to need to start by adding some state to our composable function that will track whether the sent time should be shown or not. We’ll create a new mutable state reference for a simple boolean value, wrapping this in <code>remember</code> so that the value is persisted across recompositions. We’re going to need this at the highest point of our <code>Message</code> composable because it is going to need to be read by our <code>Column</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>,
    <span class="syntax-all syntax-parameter">onLongPress</span><span class="syntax-all syntax-keyword">:</span> (id<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> parentModifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
		message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
	) {
        modifier.padding(end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)
    } <span class="syntax-all syntax-keyword">else</span> modifier.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)

    <span class="syntax-all syntax-keyword">var</span> displaySentTime by remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }

	...
}</code></pre>

<p>With this state in place, we’re going to need to add an interaction listener to our <code>Column</code>. For this we’re going to utilise the <code>pointerInput</code> - this allows us to listen for common interaction events on our composables. Later on, in this chapter, we’re going to require some functionality that is provided by these listeners, so we’re also going to utilise this here to detect tap events. Within the pointer input block, we’re now going to utilise the <code>detectTapGestures</code> extension function, allowing us to implement listeners for the events that we want to receive. Here we’ll implement the listener for tap events on our composable, <code>onTap</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> parentModifier
        .pointerInput(<span class="syntax-all syntax-constant">Unit</span>) {
            detectTapGestures(
                onTap <span class="syntax-all syntax-keyword">=</span> {

                }
            )
        }
) {
	...
}</code></pre>

<p>Within this <code>onTap</code> callback we can then toggle the state value that we previously defined to the opposite of itself.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> parentModifier
        .pointerInput(<span class="syntax-all syntax-constant">Unit</span>) {
            detectTapGestures(
                onTap <span class="syntax-all syntax-keyword">=</span> {
                    displaySentTime <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>displaySentTime
                }
            )
        }
) {
	...
}</code></pre>

<p>With this value now being toggled when our composable is tapped, we can then simply wrap the composition of the sent time in a conditional check. This would result in the sent time only being composed when <code>displaySentTime</code> is <strong>true</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">if</span> (displaySentTime) {
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
		text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(message.dateTime.time),
		fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
     )
}</code></pre>

<p>However, we can go one step further here. With the above, the change in the composition will appear suddenly to the user - if we could animate this in and out of view for the user, this would be a much nicer visual experience. To achieve this, we’re going to utilise the <code>AnimatedVisibility</code> composable - this allows us to animate a composable in and out of visibility by utilising the <code>visible</code> argument. Here we are simply going to place our existing <code>Text</code> composable for the sent time into the body of our <code>AnimatedVisibility</code> composable, providing our <code>displaySentTime</code> state for the value of the <code>visible</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">AnimatedVisibility</span>(
	visible <span class="syntax-all syntax-keyword">=</span> displaySentTime
) {
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
			.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment)
			.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
		text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(message.dateTime.time),
		fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
	)
}</code></pre>

<p>We also need to lift out the <code>align</code> modifier that we previously applied to our sent time composable. This is because the <code>AnimatedVisibility</code> composable is now the container for that, so any alignment will need to be applied to this parent instead of the child that is contained inside of it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">AnimatedVisibility</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment),
	visible <span class="syntax-all syntax-keyword">=</span> message.displaySentTime
) {
	<span class="syntax-all syntax-entity">Text</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
		text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(message.dateTime.time),
		fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
	)
}</code></pre>

<p>We can now slot this into our <code>Message</code> composable, which will give us something that looks like the following.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {
    <span class="syntax-all syntax-keyword">val</span> parentModifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
		message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
	) {
        modifier.padding(end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)
    } <span class="syntax-all syntax-keyword">else</span> modifier.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)

    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> parentModifier) {

        <span class="syntax-all syntax-keyword">val</span> alignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
			message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
		) {
            <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">End</span>
        } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span>

        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
                .align(alignment <span class="syntax-all syntax-keyword">=</span> alignment)
                .background(
                    <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">LightGray</span>,
                    <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">6</span>.dp)
                )
                .padding(<span class="syntax-all syntax-constant">8</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">MessageBody</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>),
                message <span class="syntax-all syntax-keyword">=</span> message
            )
        }

        <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember {
            <span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;hh:mm&quot;</span>)
        }
        <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .align(alignment <span class="syntax-all syntax-keyword">=</span> alignment),
            visible <span class="syntax-all syntax-keyword">=</span> message.displaySentTime
        ) {
            <span class="syntax-all syntax-entity">Text</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
                text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(
					message.dateTime.time),
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.s
            )
        }
    }
}</code></pre>

<p>With this in place, we’ll now be able to tap a message and see its sent time animate between visibilities.</p>

<figure><img src="3-18.png"/></figure>

<h3>Creating Sticky Date Headers</h3>

<figure><img src="head.png"/></figure>

<p>At this point, we have our messages displayed within the list, along with a nice animation to show/hide the time that the message was sent. Aside from using the sent time, we often see messaging apps collate messages into groups, using heading to depict the grouping for messages - for example, grouping messages by dates and then showing a header to indicate the date that that grouping of messages was received. This concept gives us a great opportunity to implement this behaviour in compose, so we’re now going to display headings for message dates. For this, we’re going to want to show a date header above the <strong>first message for a given date</strong>, but before we can do this we’re going to need to group our messages by sent date.</p>

<p>For this we’re going to create a new function, <code>groupMessagesByDate</code>. This keeps the logic outside of our composable function, also making it easier for us to test this code also. Here we’re going to utilise the Kotlin <code>groupBy</code> function that allows us to take a list of items, followed by generating a <code>Map</code> that represents the grouped items. Each group will be represented by the <code>key</code> of the map entry and we’ll want this <code>key</code> to also represent the date of the group, which we will then use for our header.</p>

<p>When using the <code>groupBy</code> function we need to implement a <code>keySelector</code> block, this is what is used to calculate the <code>key</code> for each item in the provided list - this key is what will then be used to generate the map for our list of items. An issue here though is that within our <code>keySelector</code> we can’t just reference the <code>dateTime</code> of our message - this is because even if a message is on the same date, it’s likely to have been sent at a different hour, minute or second than another. This would result in the grouping creating multiple <code>Map</code> entries for messages that were sent on the same date, but just at a different time within that date. To ensure that this comparison is only performed on the day, month and year of our <code>Calendar</code>, we’re going to go ahead and clear the other properties that might be checked against.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">groupMessagesByDate</span>(
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Map</span>&lt;<span class="syntax-all syntax-entity">Calendar</span>, <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;&gt; {
    <span class="syntax-all syntax-keyword">return</span> messages.groupBy {
        it.dateTime.<span class="syntax-all syntax-constant">apply</span> {
            set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">HOUR_OF_DAY</span>, <span class="syntax-all syntax-constant">0</span>)
            set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">MINUTE</span>, <span class="syntax-all syntax-constant">0</span>)
            set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">SECOND</span>, <span class="syntax-all syntax-constant">0</span>)
            set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">MILLISECOND</span>, <span class="syntax-all syntax-constant">0</span>)
        }
    }
}</code></pre>

<p>In this function, we’re taking a list of messages and grouping them by the <code>dateTime</code> property. When performing this grouping, we’re setting the hour, minute, second and millisecond properties to <code>0</code> - this means that when performing the group, we are essentially only grouping based on the day, month and year. When displaying the sent time within the composable we are accessing the <code>date</code> time field from the <code>Message</code> instance, so resetting these values here does not interfere with the value that we are going to display.</p>

<p>With this function in place, we’ll need to start by calling it and providing the list of messages from our state and keep a reference to this that can be used by our list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> grouped <span class="syntax-all syntax-keyword">=</span> groupMessagesByDate(messages)</code></pre>

<p>Now that we have this group, we can loop through each entry of the map, continuing to compose the <code>Message</code> values that are contained within the map entry, which would result in the same composition that we were previously seeing within our UI.</p>

<pre><code class="code-highlighted code-kt">grouped.onEachIndexed { index, entry <span class="syntax-all syntax-keyword">-&gt;</span>
	items(entry.value) { message <span class="syntax-all syntax-keyword">-&gt;</span>
		<span class="syntax-all syntax-entity">Message</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			message <span class="syntax-all syntax-keyword">=</span> message
    	)
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
	}
}</code></pre>

<p>Now that we’re looping through each entry with our map, we’re looping through each group that contains messages grouped by date. This means that for each group, we’re going to want to draw a header. This header is going to be represented by a composable, so we’re going to need to create a new composable function, <code>MessageHeader</code>. When it comes to this header, there are going to be a couple of different ways that it’s going to be represented.</p>

<ul>
	<li>When the date represents a day that is not the current date, the date that the message was sent will be displayed</li>
	<li>When the date represents the current day, a “Today” label will be displayed</li>
</ul>

<p>With that in mind, the composable is going to need to know the <code>Calendar</code> that it is composing a header for, along with a flag to signify whether the header is representing the date for <strong>today</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageHeader</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">isToday</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">date</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Calendar</span>
}</code></pre>

<p>We’ll start by configuring the label that is going to be displayed within the header. In the cases where we are working with today’s date, we’re going to need to show a “Today” label. For this, we’ll need to add a string to our <code>strings.xml</code> resources file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_today&quot;</span>&gt;Today&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Then if the <code>isToday</code> flag is represented as <strong>true</strong>, we can go ahead and assign this label to a variable reference, retrieving this using the <code>stringResource</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isToday) {
	stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_today)
} <span class="syntax-all syntax-keyword">else</span> {
	
}</code></pre>

<p>In these cases where we aren’t working with today’s date, we’ll need to show the actual date. Here we’re going to show this in a day-month-year style, which we’re going to need to use the <code>SimpleDateFormat</code> class to achieve. We’ll configure this class to format our date in the required format by using the <strong>“dd MMM yyyy”</strong> pattern, followed by using this class to format the <code>Date</code> from the <code>Calendar</code> reference that is provided to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isToday) {
	stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_today)
} <span class="syntax-all syntax-keyword">else</span> {
	<span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember { 
		<span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;dd MMM yyyy&quot;</span>) 
	}
	dateFormat.format(date.time)
}</code></pre>

<p>With this logic in place, we can now display this inside of our header using a <code>Text</code> composable. We’ll start by setting the value of our label to the <code>Text</code> composable, along with assigning a <code>fontSize</code> of <code>14sp</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
    text <span class="syntax-all syntax-keyword">=</span> label,
    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">14</span>.sp
)</code></pre>

<figure><img src="e.png"/></figure>

<p>Next, we’ll need to enforce our header to use the full width of the composable, for which we’ll use the <code>fillMaxWidth</code> modifier. Now that our composable is filling the whole with, we’ll also need to ensure that our text value is aligned into the center of the composable. For this, we’ll need to set the <code>textAlign</code> to <code>TextAlign.Center</code>, which will align the <code>text</code> into the center of the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
    text <span class="syntax-all syntax-keyword">=</span> label,
    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">14</span>.sp,
    textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
)</code></pre>

<figure><img src="ee.png"/></figure>

<p>Alongside the sizing constraints, we’ll also need to style the background color of our composable. For this we’re going to use a modified version of the <code>onSurface</code> theme color - we’ll modify this by copying the value of the color and overriding the <code>alpha</code> value that is used for it. This will help to ensure that our header remains within the theming of our application, while also adapting the color to our requirements.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
    	.background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(
        	alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.05f</span>
      	))
        .padding(vertical <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
    text <span class="syntax-all syntax-keyword">=</span> label,
    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">14</span>.sp,
    textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
)</code></pre>

<p>With this in place, we now have a <code>MessageHeader</code> composable function that can be used to display a header for a given <code>Calendar</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageHeader</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
    <span class="syntax-all syntax-parameter">isToday</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">date</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Calendar</span>
) {
    <span class="syntax-all syntax-keyword">val</span> label <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (isToday) {
        stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.label_today)
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;dd MMM yyyy&quot;</span>)
        dateFormat.format(date.time)
    }

    <span class="syntax-all syntax-entity">Text</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(
            	alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.05f</span>
        	))
            .padding(vertical <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
        text <span class="syntax-all syntax-keyword">=</span> label,
        fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">14</span>.sp,
        textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
    )
}</code></pre>

<figure><img src="eeee.png"/></figure>

<p>Now that we have our composable defined, we can go ahead and compose it within our <code>LazyColumn</code>. The <code>LazyColumn</code> contains a <code>stickyHeader</code> which can be used to compose content that is to be used as a sticky header. Anything that is composed here will be pinned within the UI, even while the user is scrolling through the list - but when the next header is reached within the list, this will replace the currently pinned one. We’ll go ahead and use this function, composing our <code>MessageHeader</code> inside of it.</p>

<pre><code class="code-highlighted code-kt">grouped.onEachIndexed { index, entry <span class="syntax-all syntax-keyword">-&gt;</span>

	stickyHeader {
		<span class="syntax-all syntax-entity">MessageHeader</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			isToday <span class="syntax-all syntax-keyword">=</span> isToday(entry.key),
			date <span class="syntax-all syntax-keyword">=</span> entry.key
		)
	}

	items(entry.value) { message <span class="syntax-all syntax-keyword">-&gt;</span>
		<span class="syntax-all syntax-entity">Message</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
			message <span class="syntax-all syntax-keyword">=</span> message
    	)
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
	}
}</code></pre>

<p>We can now slot all of the content that we’ve defined for sticky headers into our <code>Messages</code> composable, which should result in a composable that looks like the following.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (messages.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">EmptyConversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
        )
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-keyword">val</span> state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> state,
            contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp),
			verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.spacedBy(<span class="syntax-all syntax-constant">16</span>.dp)
        ) {
			<span class="syntax-all syntax-keyword">val</span> grouped <span class="syntax-all syntax-keyword">=</span> groupMessagesByDate(messages)
            grouped.onEach { entry <span class="syntax-all syntax-keyword">-&gt;</span>

                stickyHeader {
                    <span class="syntax-all syntax-entity">MessageHeader</span>(
                        isToday <span class="syntax-all syntax-keyword">=</span> isToday(entry.key),
                        date <span class="syntax-all syntax-keyword">=</span> entry.key
                    )
                }

                items(entry.value) { message <span class="syntax-all syntax-keyword">-&gt;</span>
                    <span class="syntax-all syntax-entity">Message</span>(
                        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
                        message <span class="syntax-all syntax-keyword">=</span> message
                    )
                }
            }
        }
    }
}</code></pre>

<p>With this in place, we will now be able to see our list of messages within the UI, this time accompanied by sticky headers that represent the current dates of the messages.</p>

<figure><img src="mess.png"/></figure>

<hr />

<h2>Supporting Message Creation</h2>

<figure><img src="input.png"/></figure>

<p>While we are currently displaying messages within our UI, these ones are coming from our pre-existing state. In a real messaging app we would be receiving and sending messages in real-time, seeing our UI update as this happens. While we’re not communicating with a remote API for our messaging app, we can simulate this locally. In this section we’re going to add an input bar that allows our users to send text-based messages, seeing them appear within the message list once they’ve been sent.</p>

<p>For this we’re going to create a new composable that allows us to support the input of text, we’ll create a new file <code>InputBar.kt</code> and create a new composable function, <code>InputBar</code>. As well as taking a <code>Modifier</code> argument, this is going to take a <code>sendMessage</code> lambda that allows the send message event to be sent from our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// InputBar.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>The content of our composable is going to be quite minimal - it’s going to display an input field that allows our user to input textual content. However, we’re going to want this to have some separation with wherever this is placed within our UI, so we’re also going to utilise a <code>Divider</code> composable to add a breaking line at the top of our input bar. Because of this, we’ll need to have a parent <code>Column</code> composable that will be used to house this <code>Divider</code> along with the input bar that we will also add here shortly.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// InputBar.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Divider</span>()
		
    }
}</code></pre>

<p>With this in place, we can now add the <code>TextField</code> composable that will enable input for our messaging feature. Before we define this input field, we’re going to need to create a state object that will be used to hold the content that has been input by the user. For this we’re going to explore using the <code>TextFieldValue</code> class - while we could use strings directly here, we’re later going to need this <code>TextFieldValue</code>. This class not only holds the current text that is to be rendered inside of the composable, but also other information that is used for its composition. We’ll create a new piece of mutable state here, wrapping it in <code>remember</code> so that the state is persisted across compositions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">var</span> textState by remember { 
	mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
}</code></pre>

<p>Now that we’ve defined this state we can go ahead and compose <code>TextField</code> within our <code>InputBar</code> composable. We’ll set the <code>value</code> to the <code>textState</code> reference that we previously defined, along with updating the value of our <code>textState</code> within the <code>onValueChange</code> implementation for our <code>TextField</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> textState by remember { 
		mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
	}
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Divider</span>()
        <span class="syntax-all syntax-entity">TextField</span>(
           	value <span class="syntax-all syntax-keyword">=</span> textState,
            onValueChange <span class="syntax-all syntax-keyword">=</span> {
                textState <span class="syntax-all syntax-keyword">=</span> it
            }
    	)
    }
}</code></pre>

<p>At this point, we now have an input field being composed within our <code>InputBar</code>.</p>

<figure><img src="11111.png"/></figure>

<p>We might notice here though that things aren’t looking quite right within our UI, the <code>TextField</code> is very narrow! To resolve this we’re going to utilise the <code>fillMaxWidth</code> modifier so that the composable uses the full width that is available to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> textState by remember { 
		mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
	}
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Divider</span>()
        <span class="syntax-all syntax-entity">TextField</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
           	value <span class="syntax-all syntax-keyword">=</span> textState,
            onValueChange <span class="syntax-all syntax-keyword">=</span> {
                textState <span class="syntax-all syntax-keyword">=</span> it
            }
    	)
    }
}</code></pre>

<p>We can see now that our composable is filling the maximum width, resulting in a better visual representation for our UI.</p>

<figure><img src="Group%2011.png"/></figure>

<p>When viewing our input bar, it isn’t super clear what it is used for. We can improve things here slightly by adding a label for our input, this will help to give some context to the users as to what our input bar is to be used for - in this case, sending a message. For this, we’ll add a new string to our <code>strings.xml</code> resource file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;hint_send_message&quot;</span>&gt;Send a message…&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With this now defined we can go ahead and compose some text within the <code>placeholder</code> of our <code>TextField</code>. For this, we’ll simply use a <code>Text</code> composable and apply the string resource that we have just defined. Because we are defining a label here, we don’t need it to be so prominent within our UI - for this reason, we can take the color that would be used (<code>onSurface</code>) and override the <code>alpha</code> value. For the <code>alpha</code> we’ll use the <code>ContentAlpha.medium</code> - which as per the documentation is:</p>

<blockquote>
<p>A medium level of content alpha, used to represent medium emphasis text such as placeholder text in a TextField.</p>
</blockquote>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> textState by remember { 
		mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
	}
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Divider</span>()
        <span class="syntax-all syntax-entity">TextField</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            value <span class="syntax-all syntax-keyword">=</span> textState,
			onValueChange <span class="syntax-all syntax-keyword">=</span> {
                textState <span class="syntax-all syntax-keyword">=</span> it
            },
            placeholder <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">Text</span>(
					text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.hint_send_message), 
					color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface
						.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentAlpha</span>.medium)
				)
            }
    	)
    }
}</code></pre>

<p>At this point, we now have a placeholder within our <code>TextField</code> which adds some clarity as to what our input field is to be used for.</p>

<figure><img src="place.png"/></figure>

<p>For the theming of the composable, you may have noticed that the background of the input bar is using a modified version of the <code>onSurface</code> color. Where we’re using this input field within our UI, this doesn’t look too great. Instead, we’re going to override the color that’s being used so that instead the <code>surface</code> color is used.</p>

<p>To achieve this we need to provide a <code>TextFieldColors</code> reference to the <code>colors</code> argument of the <code>TextField</code> composable. To build an instance of this class we can utilise the <code>TextFieldDefaults.textFieldColors</code> function - this will apply the default <code>TextField</code> colors, allowing us to override the colors that we desire. Here we’re going to override the <code>backgroundColor</code> value, using the <code>surface</code> color from our theme to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> textState by remember { 
		mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
	}
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Divider</span>()
        <span class="syntax-all syntax-entity">TextField</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            value <span class="syntax-all syntax-keyword">=</span> textState,
			onValueChange <span class="syntax-all syntax-keyword">=</span> {
                textState <span class="syntax-all syntax-keyword">=</span> it
            },
            placeholder <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">Text</span>(
					text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.hint_send_message), 
					color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface
						.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentAlpha</span>.medium)
				)
            },
            colors <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextFieldDefaults</span>.textFieldColors(
                backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface
            )
    	)
    }
}</code></pre>

<p>Now, we can see that our input field has a bit more of a natural style, which will fit in nicer with the rest of our UI.</p>

<figure><img src="ddd.png"/></figure>

<p>While at this point this user can enter content into our input field, they aren’t able to do anything with that content. So that the user can send the message that they’ve entered, we’re going to add an icon that allows the user to do so. For this, we’ll utilise the <code>trailingIcon</code> argument of the <code>TextField</code> to compose an <code>IconButton</code> that will be used to send the message.</p>

<pre><code class="code-highlighted code-kt">trailingIcon <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">IconButton</span>(
		onClick <span class="syntax-all syntax-keyword">=</span> {

		}
	) {
		
	}
}</code></pre>

<p>So that our <code>IconButton</code> is functional, we’re going to compose an <code>Icon</code> within the content of the <code>IconButton</code>. When doing so, we’ll utilise the <code>Icons.Default.Send</code> icon to display a familiar icon for sending content.</p>

<pre><code class="code-highlighted code-kt">trailingIcon <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">IconButton</span>(
		onClick <span class="syntax-all syntax-keyword">=</span> {

		}
	) {
		<span class="syntax-all syntax-entity">Icon</span>(
			imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Send</span>,
			contentDescription <span class="syntax-all syntax-keyword">=</span> ...
		)
	}
}</code></pre>

<p>We’ll also need to add a content description for this composable. We’ll start by adding this to our <code>strings.xml</code> file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_send_message&quot;</span>&gt;Send message&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Along with retrieving the string value for this using the <code>stringResource</code> function, followed by passing this to the <code>contentDescription</code> argument for our composable.</p>

<pre><code class="code-highlighted code-kt">trailingIcon <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">IconButton</span>(
		onClick <span class="syntax-all syntax-keyword">=</span> {

		}
	) {
		<span class="syntax-all syntax-entity">Icon</span>(
			imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Send</span>,
			contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_send_message)
		)
	}
}</code></pre>

<p>Within our composable, we’ll now be able to see a ’send’ button.</p>

<figure><img src="dd.png"/></figure>

<p>However, at this point, the button isn’t doing anything. When the <code>onClick</code> callback is triggered, we’ll need to use the <code>sendMessage</code> lambda that is provided to our composable function. When using this, we’ll pass the value of our <code>textState</code> reference - this will represent the current content of the input field. We’ll then want to essentially reset our <code>textState</code> - this is because once the message has been sent, the input content is redundant. So here we’ll set our <code>textState</code> value to a new instance of the <code>TextFieldValue</code> class.</p>

<pre><code class="code-highlighted code-kt">trailingIcon <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">IconButton</span>(
		onClick <span class="syntax-all syntax-keyword">=</span> {
			sendMessage(textState.text)
			textState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextFieldValue</span>()
		}
	) {
		<span class="syntax-all syntax-entity">Icon</span>(
			imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Send</span>,
			contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_send_message)
		)
	}
}</code></pre>

<p>While it’s now possible to send messages, we’re not going to want to allow the user to click this icon in all cases. For example, if no content has been entered into the field then we don’t want to allow the user to hit the send button. This is going to involve two small tweaks to our composable code.</p>

<p>We’ll start by setting the <code>enabled</code> state of our <code>IconButton</code>. Here, the <code>IconButton</code> will only be enabled if the value of our state is not empty. For this we can utilise the Kotlin <code>isNotEmpty()</code> function to assert whether the input content is empty, followed by providing this for the <code>enabled</code> argument of the <code>IconButton</code> composable.</p>

<p>To make it visually clear to the user that the <code>IconButton</code> is disabled, we’ll want to modify the color of the icon based on the enabled state. To implement this we’ll need to provide a color value for the <code>tint</code> argument, which we’ll do so conditionally based on the input content. Again using the <code>isNotEmpty()</code> check on our state value, we’ll provide a color based on whether there is content that has been entered. If there is content then we’ll use the <code>primary</code> color from our theme, otherwise, we’ll use a modified version of the <code>onSurface</code> - applying the <code>disabled</code> alpha value from the material <code>ContentAlpha</code>.</p>

<pre><code class="code-highlighted code-kt">trailingIcon <span class="syntax-all syntax-keyword">=</span> {
	<span class="syntax-all syntax-entity">IconButton</span>(
		onClick <span class="syntax-all syntax-keyword">=</span> {
			sendMessage(textState.text)
			textState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextFieldValue</span>()
		},
		enabled <span class="syntax-all syntax-keyword">=</span> textState.text.isNotEmpty()
	) {
		<span class="syntax-all syntax-entity">Icon</span>(
			imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Send</span>,
			contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
				id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_send_message),
			tint <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (textState.text.isNotEmpty()) {
				<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary
			} <span class="syntax-all syntax-keyword">else</span> {
				<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface
					.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentAlpha</span>.disabled)
			}
		)
	}
}</code></pre>

<p>With this in place, we’ll now be able to see our <code>IconButton</code> enabled or disabled based on the current state of our content, along with the <code>Icon</code> themed accordingly. We just need to slot this into the <code>TextField</code> composable within our <code>InputBar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> textState by remember { 
		mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
	}
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        <span class="syntax-all syntax-entity">Divider</span>()
        <span class="syntax-all syntax-entity">TextField</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            value <span class="syntax-all syntax-keyword">=</span> textState,
			onValueChange <span class="syntax-all syntax-keyword">=</span> {
                textState <span class="syntax-all syntax-keyword">=</span> it
            },
            placeholder <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">Text</span>(
					text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.hint_send_message), 
					color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Gray</span>
				)
            },
            colors <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextFieldDefaults</span>.textFieldColors(
                backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface
            ),
            trailingIcon <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">IconButton</span>(
                    onClick <span class="syntax-all syntax-keyword">=</span> {
						sendMessage(textState.text)
                        textState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextFieldValue</span>()
                    },
                    enabled <span class="syntax-all syntax-keyword">=</span> textState.text.isNotEmpty()
                ) {
                	<span class="syntax-all syntax-entity">Icon</span>(
                		imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Send</span>,
                		contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
							id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_send_message),
                    	tint <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
							textState.text.isNotEmpty()) {
                    		<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary
                   		} <span class="syntax-all syntax-keyword">else</span> {
                    		<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface
								.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentAlpha</span>.disabled)
                  		}
                	)
            	}
        	}
    	)
    }
}</code></pre>

<p>With this now being composed, we’ll currently see our <code>InputBar</code> composed like so.</p>

<figure><img src="d.png"/></figure>

<p>At this point, we just need to compose our <code>InputBar</code> inside of our <code>Conversation</code> composable. With our <code>Messages</code> composing using up the available pace, we can compose our <code>InputBar</code> underneath this and it will be pushed to the bottom of the screen. When composing our <code>InputBar</code> we’ll use the <code>fillMaxWidth</code> modifier to fill the available width of the composable, along with implementing the <code>sendMessage</code> callback. Within this callback implementation, we’ll want to trigger the <code>handleEvent</code> lambda that is provided to our <code>Conversation</code> composable, passing the <code>SendMessage</code> event when doing so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Conversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
    ) {
        <span class="syntax-all syntax-entity">Header</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            onClose <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-comment">// finish activity
</span>            }
        )
        <span class="syntax-all syntax-entity">Messages</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
            messages <span class="syntax-all syntax-keyword">=</span> state.messages,
            handleEvent
        )
        <span class="syntax-all syntax-entity">InputBar</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            sendMessage <span class="syntax-all syntax-keyword">=</span> { message <span class="syntax-all syntax-keyword">-&gt;</span>		
				handleEvent(
					<span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">SendMessage</span>(message))
			}
        )
    }
}</code></pre>

<p>Our <code>Conversation</code> composable will now include the <code>InputBar</code> in its composition, allowing the user to send messages in the given conversation.</p>

<figure><img src="1414.png"/></figure>

<hr />

<h2>Supporting @ mentions</h2>

<figure><img src="ment.png"/></figure>

<p>Now that our input bar has been created, we’re going to add some support to allow users to @ mention their contacts. This means that a user will be able to type the @ character and see a list of contacts to select from, adding their name to the chat when clicked. For this, we’re going to create a new composable function, <code>Mentions</code> that is going to need to take a couple of arguments.</p>

<ul>
	<li><strong>modifier</strong>: used to apply modifiers from the point of composition</li>
	<li><strong>contacts</strong>: the list of contacts that are available to tag</li>
	<li><strong>query</strong>: the search query to use when displaying contacts</li>
	<li><strong>onMentionClicked</strong>: a lambda for handling the selection of a contact</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Mentions</span>.kt

<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Mentions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onMentionClicked</span><span class="syntax-all syntax-keyword">:</span> (mention<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Within this function, we’re going to need to filter out the provided contacts based on the provided <code>query</code>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter {
	
}</code></pre>

<p>For this, we can utilise the <code>Contact</code> name to do so, but to ensure this works correctly we’re first going to need to strip the “@“ mention symbol from the query string. This is because the user would have entered the “@“ character to trigger the mention functionality, so if this is passed to out composable then we’re going to need to remove it before comparisons (as the contact name won’t include this). We’ll create a new function, <code>stripMentionSymbol</code>, inside of a <code>textUtil.kt</code> file. This will take the provided string and remove any “@“ from the string, returning a blank string if this provided text is <strong>null</strong>.</p>

<pre><code class="code-highlighted code-kt">textUtil.kt

<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">stripMentionSymbol</span>(<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>) <span class="syntax-all syntax-keyword">=</span> 
	text?.replace(<span class="syntax-all syntax-string">&quot;@&quot;</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>) <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span></code></pre>

<p>With this function in place, we can now use this to generate a query string that does not include an “@“ symbol. When calling this function we’ll also convert our initial query string to lowercase, as this will avoid any discrepancies when performing comparisons.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter { contact <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> withoutMentionSymbol <span class="syntax-all syntax-keyword">=</span> stripMentionSymbol(
		query?.lowercase())
	...
}</code></pre>

<p>Now that we have an equivalent of our query string without the “@“ mention symbol, we can use this within the predicate of our filter. Here we’ll simply want to assert whether the <code>name</code> of the <code>Contact</code> starts with our stripped query representation, again using <code>lowercase</code> here to avoid any discrepancies. So now for example, if the query is representative of “Jo”, then contacts beginning with that will be returned and represented within our <code>mentions</code> list (for example, “Joseph”, “Jolene”).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter { contact <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> withoutMentionSymbol <span class="syntax-all syntax-keyword">=</span> stripMentionSymbol(
		query?.lowercase())
	contact.name.lowercase().startsWith(withoutMentionSymbol)
}</code></pre>

<p>Now that we have these filtered contacts to display as mentions, we can plug this logic into our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Mentions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onMentionClicked</span><span class="syntax-all syntax-keyword">:</span> (mention<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter {
        <span class="syntax-all syntax-keyword">val</span> withoutMentionSymbol <span class="syntax-all syntax-keyword">=</span> stripMentionSymbol(
			query?.lowercase())
        it.name.lowercase().startsWith(withoutMentionSymbol)
    }
}</code></pre>

<p>At this point we don’t have any visual representation of these contacts, so we’ll want to take these mentions and display them within the composable for selection. Here we’re going to use a <code>LazyRow</code>, which has the same implementation details as the <code>LazyColumn</code> that we used for composing the list of messages - the key difference is that the children are composed in a <strong>horizontal</strong> fashion, as opposed to vertical. Within our <code>LazyRow</code> we’ll again use the <code>items</code> function to create a collection of <code>LazyListScope</code> scoped children from our <code>mentions</code> reference. For each item, we’ll simply use <code>Text</code> composable to compose the contacts <code>name</code> within the UI component.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">LazyRow</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	items(mentions) { contact <span class="syntax-all syntax-keyword">-&gt;</span>
		<span class="syntax-all syntax-entity">Text</span>(
			text <span class="syntax-all syntax-keyword">=</span> contact.name
        )
    }
}</code></pre>

<p>This will now be composing a collection of contact names inside of the <code>LazyRow</code>.</p>

<figure><img src="1-24.png"/></figure>

<p>At this point, we’re only displaying contact names to our users - they can’t yet be interacted with. Here we’re going to utilise the <code>clickable</code> modifier to handle click events on our composable, triggering the <code>onMentionClicked</code> lambda when the composable is clicked. When triggering this, we’ll need to provide the @ mention string back to the parent composable - which we’ll do by appending the selected contact name to the “@“ symbol. We’ll also want to use the <code>padding</code> to ensure that the composable has a big enough touch target for user interaction.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">LazyRow</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	items(mentions) { contact <span class="syntax-all syntax-keyword">-&gt;</span>
		<span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            	.clickable {
                	onMentionClicked(<span class="syntax-all syntax-string">&quot;@</span><span class="syntax-all syntax-entity">${contact.name}</span><span class="syntax-all syntax-string">&quot;</span>)
            	}
                .padding(<span class="syntax-all syntax-constant">16</span>.dp),
			text <span class="syntax-all syntax-keyword">=</span> contact.name
        )
    }
}</code></pre>

<p>With this in place, our composable is now showing clickable contacts within the <code>LazyRow</code> implementation.</p>

<figure><img src="2-22.png"/></figure>

<p>While this click interaction is in place, it’s not currently done so in a way that is accessible to all users. If a user has enabled accessibility services on their device, then talkback will not currently be able to describe what this click action will trigger - only that there is a click action available. We’re going to add a click action label here so that talkback will be able to communicate what this click interaction will do. We’re going to define a new resource in our <code>strings.xml</code> file, using a format argument that will allow us to format the string using the contact name.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_mention_contact&quot;</span>&gt;Mention %s&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Using this string resource, we can construct a string that uses the contact name to give context for the click action - shown below by the <code>clickLabel</code> variable. We can then pass this variable reference to the <code>onClickLabel</code> argument of the <code>clickable</code> modifier, which will then be used to describe the click interaction via accessibility services.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">LazyRow</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
	items(mentions) { contact <span class="syntax-all syntax-keyword">-&gt;</span>
		<span class="syntax-all syntax-keyword">val</span> clickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_mention_contact, contact.name)
		<span class="syntax-all syntax-entity">Text</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            	.clickable(onClickLabel <span class="syntax-all syntax-keyword">=</span> clickLabel) {
                	onMentionClicked(<span class="syntax-all syntax-string">&quot;@</span><span class="syntax-all syntax-entity">${contact.name}</span><span class="syntax-all syntax-string">&quot;</span>)
            	}
                .padding(<span class="syntax-all syntax-constant">16</span>.dp),
			text <span class="syntax-all syntax-keyword">=</span> contact.name
        )
    }
}</code></pre>

<p>💡 Click labels do not change anything visually for our composable but are just used by accessibility services to describe the available action.</p>

<p>With this all in place, we should now have a <code>Mentions</code> composable function that is representative of the following composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Mentions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onMentionClicked</span><span class="syntax-all syntax-keyword">:</span> (mention<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter {
        <span class="syntax-all syntax-keyword">val</span> withoutMentionSymbol <span class="syntax-all syntax-keyword">=</span> stripMentionSymbol(
			query?.lowercase())
        it.name.lowercase().startsWith(withoutMentionSymbol)
    }
 	<span class="syntax-all syntax-entity">LazyRow</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		items(mentions) { contact <span class="syntax-all syntax-keyword">-&gt;</span>
			<span class="syntax-all syntax-keyword">val</span> clickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_mention_contact, contact.name)
			<span class="syntax-all syntax-entity">Text</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            		.clickable(onClickLabel <span class="syntax-all syntax-keyword">=</span> clickLabel) {
                		onMentionClicked(<span class="syntax-all syntax-string">&quot;@</span><span class="syntax-all syntax-entity">${contact.name}</span><span class="syntax-all syntax-string">&quot;</span>)
            		}
                	.padding(<span class="syntax-all syntax-constant">16</span>.dp),
				text <span class="syntax-all syntax-keyword">=</span> contact.name
            )
        }
    }
}</code></pre>

<p>At this point, our composable function will be composing a collection of contact names based on the current query that is provided to it.</p>

<figure><img src="2-23.png"/></figure>

<p>We’re going to make a small tweak here so that there is some visual separation between the mentions bar and any content that might be displayed outside of it. Here we’ll start by moving our <code>LazyRow</code> into a <code>Column</code>, along with the previously assigned <code>Modifier</code> so that this is at the higher point within our composable. We’ll then add a <code>Divider</code> as the first child of our <code>Column</code>, creating the visual separation that we are looking for.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Mentions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onMentionClicked</span><span class="syntax-all syntax-keyword">:</span> (mention<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter {
        <span class="syntax-all syntax-keyword">val</span> withoutMentionSymbol <span class="syntax-all syntax-keyword">=</span> stripMentionSymbol(
			query?.lowercase())
        it.name.lowercase().startsWith(withoutMentionSymbol)
    }
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-entity">Divider</span>()
        <span class="syntax-all syntax-entity">LazyRow</span> {
            items(mentions) { contact <span class="syntax-all syntax-keyword">-&gt;</span>
				<span class="syntax-all syntax-keyword">val</span> clickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_mention_contact, contact.name)
                <span class="syntax-all syntax-entity">Text</span>(
					modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            			.clickable(onClickLabel <span class="syntax-all syntax-keyword">=</span> clickLabel) {
                			onMentionClicked(
								<span class="syntax-all syntax-string">&quot;@</span><span class="syntax-all syntax-entity">${contact.name}</span><span class="syntax-all syntax-string">&quot;</span>)
            			}
                		.padding(<span class="syntax-all syntax-constant">16</span>.dp),
					text <span class="syntax-all syntax-keyword">=</span> contact.name
            	)
            }
        }
    }
}</code></pre>

<figure><img src="3-19.png"/></figure>

<h3>Composing the Mentions bar</h3>

<p>Now that our <code>Mentions</code> composable has been implemented, we’re ready to compose this within our <code>Input</code> bar. </p>

<p>When we created the <code>Mentions</code> bar we added support to pass a <code>query</code> value as an argument, this is what will be used to determine what contacts should be displayed. A complexity here with the mentions bar is that we can’t just pass the current value of our input field state - as this would be the entire string that has been entered into the message bar. The mentions bar is essentially offering autocomplete functionality, so the <code>query</code> value will represent the current <strong>word</strong> that is currently being entered by the user. However, a user might not currently be entering a word - they might have moved the input cursor back to a previously entered word that begins with the “@“ symbol, so we need to account for this case too. Both of these scenarios can be represented by the concept of the currently selected word, because if a word is currently being entered, then it is also going to be the currently selected word within the input bar. With this in mind, we’re going to create a new function in our <code>textUtils.kt</code> file that allows us to fetch the currently selected word from a <code>TextFieldValue</code> reference.</p>

<p>The <code>TextFieldValue</code> contains everything that we need to be able to get the currently selected word. Not only does it contain the current value of the input, but it also contains information about the current selection within the <code>TextFieldValue</code>. This means that using the starting selection of the <code>TextFieldValue</code> we can loop through the individual words that make up the <code>TextFieldValue</code> text value, fetching the word whose position aligns with the current starting selection of our input field value. We’ll break this down to understand this further, but this function would be represented like so:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">selectedWord</span>(<span class="syntax-all syntax-parameter">textState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">TextFieldValue</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> {
    <span class="syntax-all syntax-keyword">val</span> startSelection <span class="syntax-all syntax-keyword">=</span> textState.selection.start
    <span class="syntax-all syntax-keyword">var</span> position <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>

    <span class="syntax-all syntax-keyword">for</span> (currentWord <span class="syntax-all syntax-keyword">in</span> textState.text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>)) {
        position <span class="syntax-all syntax-keyword">+=</span> currentWord.length <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>
        <span class="syntax-all syntax-keyword">if</span> (textPosition <span class="syntax-all syntax-keyword">&gt;=</span> startSelection) <span class="syntax-all syntax-keyword">return</span> currentWord
    }
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">null</span>
}</code></pre>

<p>We’re going to start by pulling out the current start of the <code>TextFieldValue</code> selection and assigning this to a variable reference. This adds a bit of clarity to our function, allowing us to reference <code>startSelection</code> where applicable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> startSelection <span class="syntax-all syntax-keyword">=</span> textState.selection.start</code></pre>

<p>Next, we’re going to set up some variables that will be used within our loop. While looping through the words of our string, we’re going to need to keep a track of the current position that we are at within the over string value from our <code>TextFieldValue</code>. For example, if we are currently at the third word within our loop, the position of our text would be the sum of the word lengths before that third word. We’ll need to keep a track of this outside of our loop, so we’ll define a new variable called <code>textPosition </code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">var</span> textPosition <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span></code></pre>

<p>Next, we’ll loop through each word that makes up the <code>text</code> representation of our <code>TextFieldValue</code>. We’ll use the Kotlin <code>split</code> function that will take our string and return us a list of words based on the delimiter that we provide. Here we split out string by a space (represented by “ “), so we’ll end up with a collection of words that make up our string.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">for</span> (currentWord <span class="syntax-all syntax-keyword">in</span> textState.text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>))</code></pre>

<p>When performing this loop we’ll need to keep a track of where we’re currently at within our <code>TextFieldValue</code> <code>text</code> value. This is because we can’t guarantee that <code>startSelection</code> represents the start of a word (it could be in the middle) - <code>textPosition</code> will always represent the start of a word as the length of the previous word (+ 1 for the space) will always represent the start of the next word. We + 1 for a space here because we’ve split out string into individual words, so we need to account for the spaces that have been removed.</p>

<pre><code class="code-highlighted code-kt">textPosition <span class="syntax-all syntax-keyword">+=</span> currentWord.length <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span></code></pre>

<p>Now that we have the above in place, we can check whether the current <code>textPosition</code> is greater than or equal to the <code>startSelection</code> of our <code>TextFieldValue</code>. If this is the case, then it means that the current word that we are at the loop is the currently selected word. </p>

<p>For example, let’s imagine we have the phrase “Hello Joe” - and the user’s selection is currently between the O and the E of “Joe”. This would mean the <code>startSelection</code> would represent 8. During our loop, the first word would be represented by “Hello” - at this point our <code>textPosition</code> would represent 6 (hello = 5 + 1 for the length of a space). This would mean that the start selected is greater than the current <code>textPosition</code>, so that word would be classified as selected by the user. </p>

<p>For the next word of our loop, we would end up with a <code>textPosition</code> of 9 because we’ve added the length of the word “Joe” and 1 for the space. Even though there is no space in the string after “Joe”, this does not matter for our checks and saves us unnecessarily complicating our logic. At this point, the current text position would be 9, which would be greater than the <code>startSelection</code> value - this would mean that we are currently at the word that is selected by the user, so we can return it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">if</span> (textPosition <span class="syntax-all syntax-keyword">&gt;=</span> startSelection) <span class="syntax-all syntax-keyword">return</span> currentWord</code></pre>

<p>However, if no word is found that is selected then we still want to return a value - so we’ll return <strong>null</strong> outside of our loop.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">null</span></code></pre>

<p>Now that our composable is able to infer the selected word from our <code>TextFieldValue</code> reference, we’re going to look at composing our <code>Mentions</code> composable. Before we can do this though, we’re going to need a reference to a <code>Contact</code> list to pass to our <code>Mentions</code>. This is currently a part of our <code>ConversationState</code>, so we’ll need to pass this in from our parent composable. We’ll start here by adding a new <code>List&lt;Contact&gt;</code> argument to our <code>InputBar</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">InputBar</span>.kt

<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;
)</code></pre>

<p>Followed by passing the <code>contacts</code> value from our state within our <code>Conversation</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Conversation</span>.kt

<span class="syntax-all syntax-entity">InputBar</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	sendMessage <span class="syntax-all syntax-keyword">=</span> { message <span class="syntax-all syntax-keyword">-&gt;</span>
		handleEvent(<span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">SendMessage</span>(message))
	},
	contacts <span class="syntax-all syntax-keyword">=</span> state.contacts
)</code></pre>

<p>With this in place, we can no compose a minimal implementation of our <code>Mentions</code> composable. Here we:</p>

<ul>
	<li>enforce the composable to fill the maximum width that is available to it using the <code>fillMaxWidth</code> modifier.</li>
	<li>provide the list of <code>Contact</code> types that are passed in from the parent composable</li>
	<li>use our <code>selectedWord</code> function to provide a query for the mentions bar</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Mentions</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	contacts <span class="syntax-all syntax-keyword">=</span> contacts,
	query <span class="syntax-all syntax-keyword">=</span> selectedWord(textState)
) { result <span class="syntax-all syntax-keyword">-&gt;</span>
                
}</code></pre>

<p>We can then compose this inside of our <code>InputBar</code> composable above the <code>Divider</code> that is used for our <code>TextField</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;
) {
    <span class="syntax-all syntax-keyword">var</span> textState by remember { 
		mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
	}
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-entity">Mentions</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            contacts,
            selectedWord(textState)
        ) { result <span class="syntax-all syntax-keyword">-&gt;</span>
                
        }
        <span class="syntax-all syntax-entity">Divider</span>()
        <span class="syntax-all syntax-entity">TextField</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            value <span class="syntax-all syntax-keyword">=</span> textState,
			onValueChange <span class="syntax-all syntax-keyword">=</span> {
                textState <span class="syntax-all syntax-keyword">=</span> it
            },
            placeholder <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">Text</span>(
					text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.hint_send_message), 
					color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Gray</span>
				)
            },
            colors <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextFieldDefaults</span>.textFieldColors(
                backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface
            ),
            trailingIcon <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-entity">IconButton</span>(
                    onClick <span class="syntax-all syntax-keyword">=</span> {
						sendMessage(textState.text)
                        textState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextFieldValue</span>()
                    },
                    enabled <span class="syntax-all syntax-keyword">=</span> textState.text.isNotEmpty()
                ) {
                	<span class="syntax-all syntax-entity">Icon</span>(
                		imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Send</span>,
                		contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
							id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_send_message),
                    	tint <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
							textState.text.isNotEmpty()) {
                    		<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary
                   		} <span class="syntax-all syntax-keyword">else</span> {
                    		<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface
								.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentAlpha</span>.disabled)
                  		}
                	)
            	}
        	}
    	)
    }
}</code></pre>

<p>We’ll come to implementing the <code>onMentionClicked</code> shortly, we’re first going to look at conditional composition for our <code>Mentions</code> composable. We’re not always going to want this to be composed within our UI, we’re only going to want it shown when the user is entering (or has selected) a word that begins with the “@“ character.</p>

<p>To show and hide the mentions bar accordingly, we’re going to first need to define some logic that will depict the visibility of the bar. To start here, we’re going to utilise <code>derivedStateOf</code> - this allows us to calculate some state based on the values of other state within our composable. Here we’ll simply add a statement that will return whether or not the currently entered value in the input bar is empty or not. We don’t want to show the mentions bar if there is no content currently entered, so this will ensure that the bar is always displayed when expected. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> showMentions by derivedStateOf {
	textState.text.isNotEmpty()
}</code></pre>

<p>This alone though isn’t quite enough - our mentions bar will always compose the contacts that are provided to it but from our <code>InputBar</code> composable we’re only going to want to display mentions under specific conditions. We&#39;re going to create a new function, <code>inputShouldTriggerSuggestions </code> inside of our <code>textUtils.kt</code> file that will help us with this.</p>

<pre><code class="code-highlighted code-kt">textUtils.kt

<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">inputShouldTriggerSuggestions</span>(
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>
) <span class="syntax-all syntax-keyword">=</span> query <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span> <span class="syntax-all syntax-keyword">&amp;&amp;</span> query.startsWith(&#39;<span class="syntax-all syntax-keyword">@&#39;)</span> <span class="syntax-all syntax-keyword">&amp;&amp;</span> 
	<span class="syntax-all syntax-keyword">!</span>contacts.any { it.name <span class="syntax-all syntax-keyword">==</span> stripMentionSymbol(query) }</code></pre>

<p>Here, the query will represent the currently selected word within our input field. Based on that input, we have a couple of checks to determine if the mentions bar should be displayed:</p>

<ul>
	<li>if the provided query is null then it means there is no input, so we don’t want to show the mentions bar</li>
	<li>if the query does not start with the “@“ character, we don’t want too how the mentions bar</li>
	<li>if the query (without the “@“ symbol), matches the name of the contact completely, then we’re not going to want to show the mentions bar if the contact name has been fully entered. For example, if I have entered “@Joe” then I don’t need the contacts bar to show me the autocomplete for the “Joe” contact.</li>
</ul>

<p>With this in place, we can now add this to our derived <code>showMentions</code> state. This means that now, <code>showMentions</code> will be calculated based on not only the empty state of the entered text but also whether the currently selected word matches the requirements that are defined by our <code>inputShouldTriggerSuggestions</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> showMentions by derivedStateOf {
	textState.text.isNotEmpty() <span class="syntax-all syntax-keyword">&amp;&amp;</span> 
		inputShouldTriggerSuggestions(contacts, selectedWord(textState))
}</code></pre>

<p>We can then place this state within our <code>InputBar</code> composable and use it to conditional compose our <code>Mentions</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;
) {
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-keyword">var</span> textState by remember { 
			mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
		}
		<span class="syntax-all syntax-keyword">val</span> showMentions by derivedStateOf {
        	textState.text.isNotEmpty() <span class="syntax-all syntax-keyword">&amp;&amp;</span> 
				matchesContact(contacts, selectedWord(textState))
    	}
		<span class="syntax-all syntax-keyword">if</span> (showMentions) {
			<span class="syntax-all syntax-entity">Mentions</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            	contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            	query <span class="syntax-all syntax-keyword">=</span> selectedWord(textState)
        	) { result <span class="syntax-all syntax-keyword">-&gt;</span>
            	   
        	}
		}
        <span class="syntax-all syntax-entity">Divider</span>()
        ...
    }
}</code></pre>

<p>At this point, we haven’t implemented the <code>onMentionClicked</code> lambda which will be used to handle completing the input for the selected contact name within the input field. For this, we’re going to need to adjust the content of our <code>TextFieldValue</code> and have this reflected in the composition of our <code>TextField</code>. Because we’re autocompleting text for the selected contact, we can’t simply just append the contact name to our text input - this could also happen at any point within our input string, not just necessarily at the end. We’re going to need to define a bit of logic here, so we’ll go ahead and create a new extension function for <code>TextFieldValue</code> - using an extension function here allows us to directly manipulate the content of our <code>TextFieldValue</code> reference.</p>

<p>This function is going to need to know where it should start the replacement, where it should end it, as well as the content that should be used during the replacement. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> TextFieldValue.<span class="syntax-all syntax-entity">replaceText</span>(
    <span class="syntax-all syntax-parameter">start</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">end</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">replaceWith</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">TextFieldValue</span> {

}</code></pre>

<p>We’re going to start here by replacing the text within the given range with the content that is to be used in the replacement process, <code>replaceWith</code>. Here we’ll use the Kotlin <code>replaceRange</code> function to replace the content of our current text represented at the <code>start</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> TextFieldValue.<span class="syntax-all syntax-entity">replaceText</span>(
    <span class="syntax-all syntax-parameter">start</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">end</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">replaceWith</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">TextFieldValue</span> {
    <span class="syntax-all syntax-keyword">val</span> newText <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">this</span>.text.replaceRange(
        start,
        end,
        replaceWith
    )
}</code></pre>

<p>Next ,we need to ensure that the selection of the <code>TextFieldValue</code> is set correctly. We’ve replaced some range of our text with a new value that could be longer than the previous text that existed, so we’ll need to update the selection accordingly. For this we’ll calculate what the selection would be for the end of the new word that was inserted - this will be equal to the <code>start</code> value with the addition of the length of the replaced text. Well then use this calculated value to create a <code>TextRange</code> instance to provide to our <code>TextFieldValue</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> TextFieldValue.<span class="syntax-all syntax-entity">replaceText</span>(
    <span class="syntax-all syntax-parameter">start</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">end</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">replaceWith</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">TextFieldValue</span> {
    <span class="syntax-all syntax-keyword">val</span> newText <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">this</span>.text.replaceRange(
        start,
        end,
        replaceWith
    )
    <span class="syntax-all syntax-keyword">val</span> endOfNewWord <span class="syntax-all syntax-keyword">=</span> start <span class="syntax-all syntax-keyword">+</span> replaceWith.length
	<span class="syntax-all syntax-keyword">val</span> range <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextRange</span>(endOfNewWord, endOfNewWord)
}</code></pre>

<p>With the above in place, we can now use these calculated values to return a modified version of the <code>TextFieldValue</code> that is currently being accessed. Here we’ll use the <code>copy</code> function so that we can create a copied installed, overriding the values that we desire. Here we’ll pass our <code>newText</code> value that represents our modified version of the text value, along with the <code>TextRange</code> instance that we created above that will be used to state the currently selected from the <code>TextFieldValue</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> TextFieldValue.<span class="syntax-all syntax-entity">replaceText</span>(
    <span class="syntax-all syntax-parameter">start</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">end</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">replaceWith</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">TextFieldValue</span> {
    <span class="syntax-all syntax-keyword">val</span> newText <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">this</span>.text.replaceRange(
        start,
        end,
        replaceWith
    )
    <span class="syntax-all syntax-keyword">val</span> endOfNewWord <span class="syntax-all syntax-keyword">=</span> start <span class="syntax-all syntax-keyword">+</span> replaceWith.length
    <span class="syntax-all syntax-keyword">val</span> range <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextRange</span>(endOfNewWord, endOfNewWord)

    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">this</span>.copy(text <span class="syntax-all syntax-keyword">=</span> newText, selection <span class="syntax-all syntax-keyword">=</span> range)
}</code></pre>

<p>With this in place, we now have a function that can be called when a <code>Contact</code> is selected from our <code>Mentions</code> composable to modify the current state of our input field.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;
) {
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-keyword">var</span> textState by remember { 
			mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
		}
		<span class="syntax-all syntax-keyword">val</span> showMentions by derivedStateOf {
        	textState.text.isNotEmpty() <span class="syntax-all syntax-keyword">&amp;&amp;</span> 
				matchesContact(contacts, selectedWord(textState))
    	}
		<span class="syntax-all syntax-keyword">if</span> (showMentions) {
			<span class="syntax-all syntax-entity">Mentions</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            	contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            	query <span class="syntax-all syntax-keyword">=</span> selectedWord(textState)
        	) { result <span class="syntax-all syntax-keyword">-&gt;</span>
            	query?.<span class="syntax-all syntax-constant">let</span> {
                    textState <span class="syntax-all syntax-keyword">=</span> textState.replaceText(
                        ...
                    )
                }   
        	}
		}
        <span class="syntax-all syntax-entity">Divider</span>()
        ...
    }
}</code></pre>

<p>We still need to provide values for the required arguments of our input.</p>

<ul>
	<li><strong>start</strong>: this is going to be the start index of the current word that we want to replace</li>
	<li><strong>end</strong>: this is going to be the end index of the current word</li>
	<li><strong>replaceWith</strong>: this is going to represent the name of the contact that was selected</li>
</ul>

<p>With the above in mind, this means that we’ll be inserting a new word to replace the word within the provided <code>start</code> and <code>end</code> indexes. Even if the new word is longer than the one being replaced, the content outside of those indexes will be untouched. </p>

<p>Before we can do this we’ll need to modify the <code>onMentionClicked</code> lambda for our <code>Mentions</code> composable. We’re going to need the currently selected word to calculate the indexes mentioned above (which are represented by the <code>query</code> argument), so we’ll pass this back up to the parent to save us fetching it again.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Mentions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">onMentionClicked</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>, mention<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We can then modify the point where we call <code>onMentionClicked</code> to pass back the <code>query</code> value. Now even though the <code>Mentions</code> composable declares this as a nullable type, at the point where our lambda is triggered this will never be null. So here we’ll use the <code>!!</code> operation as it saves the parent needing to add null safety that isn’t required.</p>

<pre><code class="code-highlighted code-kt">.clickable(onClickLabel <span class="syntax-all syntax-keyword">=</span> clickLabel) {
	onMentionClicked(query<span class="syntax-all syntax-keyword">!!</span>, <span class="syntax-all syntax-string">&quot;@</span><span class="syntax-all syntax-entity">${contact.name}</span><span class="syntax-all syntax-string">&quot;</span>)
}</code></pre>

<p>Now within the implementation of <code>onMentionClicked</code>, we can satisfy the requirements for the <code>replaceText</code> function call. We’ll need to start by getting the index for the provided <code>query</code> value - this will return us the starting index of the selected word, which we can then pass to the <code>start</code> argument of the <code>replaceText</code> function. Next, the <code>end</code> is going to be calculated by using this <code>startIndex</code> and adding the length of the <code>query</code> value. These two calculations will give us the range of our selected word within the current representation of the <code>TextFieldValue</code> text. Finally, for <code>replaceWith</code>, we will simply pass <code>result</code>, which is the contact that was selected from our <code>Mentions</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Mentions</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
	contacts <span class="syntax-all syntax-keyword">=</span> contacts,
	query <span class="syntax-all syntax-keyword">=</span> selectedWord(textState)
) { query, result <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> startIndex <span class="syntax-all syntax-keyword">=</span> textState.text.indexOf(query)
	textState <span class="syntax-all syntax-keyword">=</span> textState.replaceText(
		start <span class="syntax-all syntax-keyword">=</span> startIndex,
		end <span class="syntax-all syntax-keyword">=</span> startIndex <span class="syntax-all syntax-keyword">+</span> query.length, 
		replaceWith <span class="syntax-all syntax-keyword">=</span> result
	)   
}</code></pre>

<p>With the above implementation, we can slot this into our <code>InputBar</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;
) {
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
		<span class="syntax-all syntax-keyword">var</span> textState by remember { 
			mutableStateOf(<span class="syntax-all syntax-entity">TextFieldValue</span>()) 
		}
		<span class="syntax-all syntax-keyword">val</span> showMentions by derivedStateOf {
        	textState.text.isNotEmpty() <span class="syntax-all syntax-keyword">&amp;&amp;</span> 
				matchesContact(contacts, selectedWord(textState))
    	}
		<span class="syntax-all syntax-keyword">if</span> (showMentions) {
			<span class="syntax-all syntax-entity">Mentions</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            	contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            	query <span class="syntax-all syntax-keyword">=</span> selectedWord(textState)
        	) { query, result <span class="syntax-all syntax-keyword">-&gt;</span>
            	<span class="syntax-all syntax-keyword">val</span> startIndex <span class="syntax-all syntax-keyword">=</span> textState.text.indexOf(query)
                textState <span class="syntax-all syntax-keyword">=</span> textState.replaceText(
                    start <span class="syntax-all syntax-keyword">=</span> startIndex,
                    end <span class="syntax-all syntax-keyword">=</span> startIndex <span class="syntax-all syntax-keyword">+</span> query.length, 
					replaceWith <span class="syntax-all syntax-keyword">=</span> result
                )   
        	}
		}
        <span class="syntax-all syntax-entity">Divider</span>()
        ...
    }
}</code></pre>

<p>With this in place, we’ll now be able to view autocomplete options for our given <code>Contact</code> instances, allowing us to @ mention these contacts within our message input. Once the contacts are displayed, selecting a contact will now add this to the message content.</p>

<figure><img src="mentions.png"/></figure>

<hr />

<h2>Supporting Mention Highlighting</h2>

<p>Now that we’ve added @ mentions to our <code>InputBar</code> composable, our user can mention contacts within the chat. In apps that support this kind of behaviour, it’s usual to highlight these words that have been entered for @ mentions or similar things (such as hashtags). To be able to support this we’re going to need to build a function that will take our string and format in a way that applies highlighting to words that start with the @ symbol. </p>

<p>We’ll create a new function, <code>buildAnnotatedStringWithColor</code>, that will take some text as well as a color that will be used when highlighting any @ mentions. The process to do this will involve using an <code>AnnotatedString</code>, which we will also need to return from the function. This <code>AnnotatedString</code> class is used to construct a text that contains multiple types of styling.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildAnnotatedStringWithColor</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, 
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span> {

}</code></pre>

<p>Within this function we’re going to need to loop through the words that are contained within <code>text</code>, this is so that we can check which ones are @ mentions and style them accordingly. We’ll start by using the kotlin <code>split</code> function to split up our <code>text</code> using a space delimiter.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildAnnotatedStringWithColor</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, 
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span> {
	<span class="syntax-all syntax-keyword">val</span> words<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-constant">String</span>&gt; <span class="syntax-all syntax-keyword">=</span> text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>)
}</code></pre>

<p>Now that we have our list of words, we are ready to start building our styled string. We need to start here by creating a new <code>AnnotatedString</code> <code>Builder</code> - this will allow us to build a string word by word with the corresponding styling.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildAnnotatedStringWithColor</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, 
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span> {
	<span class="syntax-all syntax-keyword">val</span> words<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-constant">String</span>&gt; <span class="syntax-all syntax-keyword">=</span> text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>)

	<span class="syntax-all syntax-keyword">val</span> builder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>.<span class="syntax-all syntax-entity">Builder</span>()
}</code></pre>

<p>With this builder in place, we can loop through our <code>words</code> to start building the string. We’re going to use the <code>forEachIndexed</code> operation here, as we’re going to need access to the current <code>index</code> of the loop soon. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildAnnotatedStringWithColor</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, 
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span> {
	<span class="syntax-all syntax-keyword">val</span> words<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-constant">String</span>&gt; <span class="syntax-all syntax-keyword">=</span> text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>)

	<span class="syntax-all syntax-keyword">val</span> builder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>.<span class="syntax-all syntax-entity">Builder</span>()
	words.forEachIndexed { index, word <span class="syntax-all syntax-keyword">-&gt;</span>
        
    }
}</code></pre>

<p>With this loop in place, we can append our first word to the builder instance. Here, we’re going to check if the current <code>word</code> starts with an @ symbol - if so, this is an @ mention so we’re going to want to style it accordingly. Here we’re going to use the <code>withStyle</code> on our <code>AnnotatedString.Builder</code> that allows us to apply a style before appending a word. For the <code>style</code> of this function, we’re going to provide an instance of the <code>SpanStyle</code> class, passing the <code>color</code> argument that was provided to our function. Then when we call <code>append</code> within the <code>block</code> of <code>withStyle</code>, our <code>word</code> will be appended to the builder with the <code>SpanStyle</code> styling applied to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildAnnotatedStringWithColor</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, 
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span> {
	<span class="syntax-all syntax-keyword">val</span> words<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-constant">String</span>&gt; <span class="syntax-all syntax-keyword">=</span> text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>)

	<span class="syntax-all syntax-keyword">val</span> builder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>.<span class="syntax-all syntax-entity">Builder</span>()
	words.forEachIndexed { index, word <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-keyword">if</span> (word.startsWith(<span class="syntax-all syntax-string">&quot;@&quot;</span>)) {
            builder.withStyle(
				style <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SpanStyle</span>(color <span class="syntax-all syntax-keyword">=</span> color)
			) {
                append(word)
            }
        }
    }
}</code></pre>

<p>Otherwise, if the word does not start with an @ symbol then we will simply use the <code>append</code> function to append the current <code>word</code> to our builder. Here we are not applying any kind of styling because the word is not an @-mention, so the word will be added un-styled.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildAnnotatedStringWithColor</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, 
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span> {
	<span class="syntax-all syntax-keyword">val</span> words<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-constant">String</span>&gt; <span class="syntax-all syntax-keyword">=</span> text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>)

	<span class="syntax-all syntax-keyword">val</span> builder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>.<span class="syntax-all syntax-entity">Builder</span>()
	words.forEachIndexed { index, word <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-keyword">if</span> (word.startsWith(<span class="syntax-all syntax-string">&quot;@&quot;</span>)) {
            builder.withStyle(
				style <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SpanStyle</span>(color <span class="syntax-all syntax-keyword">=</span> color)
			) {
                append(word)
            }
        } <span class="syntax-all syntax-keyword">else</span> {
            builder.append(word)
        }
    }
}</code></pre>

<p>After appending each word we’re going to want to add back the spaces in-between each word that was removed during our <code>split</code> operation - this is where the <code>index</code> value is going to come in useful. If we are not at the last word within our <code>words</code> list during the loop, then we’ll want to append a space (“ “) to our builder.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildAnnotatedStringWithColor</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, 
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span> {
	<span class="syntax-all syntax-keyword">val</span> words<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-constant">String</span>&gt; <span class="syntax-all syntax-keyword">=</span> text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>)

	<span class="syntax-all syntax-keyword">val</span> builder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>.<span class="syntax-all syntax-entity">Builder</span>()
	words.forEachIndexed { index, word <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-keyword">if</span> (word.startsWith(<span class="syntax-all syntax-string">&quot;@&quot;</span>)) {
            builder.withStyle(
				style <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SpanStyle</span>(color <span class="syntax-all syntax-keyword">=</span> color)
			) {
                append(word)
            }
        } <span class="syntax-all syntax-keyword">else</span> {
            builder.append(word)
        }
		<span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">&lt;</span> words.count() <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">1</span>) builder.append(<span class="syntax-all syntax-string">&quot; &quot;</span>)
    }
}</code></pre>

<p>At this point we have a function that is looping through each of the words in our <code>text</code> argument, styling each one accordingly. All that is left to do now is to return an <code>AnnotatedString</code> from the function, which we can do by calling <code>toAnnotatedString()</code> on our <code>AnnotatedString.Builder</code> reference that we have been using to construct our highlighted content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">buildAnnotatedStringWithColor</span>(
	<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, 
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span> {
	<span class="syntax-all syntax-keyword">val</span> words<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-constant">String</span>&gt; <span class="syntax-all syntax-keyword">=</span> text.split(<span class="syntax-all syntax-string">&quot; &quot;</span>)

	<span class="syntax-all syntax-keyword">val</span> builder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>.<span class="syntax-all syntax-entity">Builder</span>()
	words.forEachIndexed { index, word <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-keyword">if</span> (word.startsWith(<span class="syntax-all syntax-string">&quot;@&quot;</span>)) {
            builder.withStyle(
				style <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SpanStyle</span>(color <span class="syntax-all syntax-keyword">=</span> color)
			) {
                append(word)
            }
        } <span class="syntax-all syntax-keyword">else</span> {
            builder.append(word)
        }
		<span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">&lt;</span> words.count() <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">1</span>) builder.append(<span class="syntax-all syntax-string">&quot; &quot;</span>)
    }
	<span class="syntax-all syntax-keyword">return</span> builder.toAnnotatedString()
}</code></pre>

<p>With this function in place, we’re not going to apply it to two of our composables so that @ mentions can be highlighted. We’ll start by highlighting the content within the <code>MessageBody</code> composable that we created earlier. That way, any mentions will be highlighted in the messages that are shown with our UI. Instead of directly passing the <code>message</code> value from our <code>Message</code> into the <code>Text</code> composable, we’re going to use our <code>buildAnnotatedStringWithColor</code> function to provide the value here instead. When calling this function we’ll pass the <code>message</code> value from the <code>Message</code> reference, along with the <code>primary</code> color from the theme of our app.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">MessageBody</span>.kt

<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageBody</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (message.message <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>) {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            text <span class="syntax-all syntax-keyword">=</span> buildAnnotatedStringWithColor(
                text <span class="syntax-all syntax-keyword">=</span> message.message,
                color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary
            )
        )
    } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">if</span> (message.image <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>) {
        <span class="syntax-all syntax-entity">Image</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier.size(<span class="syntax-all syntax-constant">120</span>.dp),
            bitmap <span class="syntax-all syntax-keyword">=</span> message.image.asImageBitmap(),
            contentDescription <span class="syntax-all syntax-keyword">=</span> message.altText
        )
    }
}</code></pre>

<p>With this in place, we can now see @ mentions being highlighted within the body of our messages.</p>

<figure><img src="high.png"/></figure>

<p>Next, we’re going to highlight the @ mentions when they are being entered into the message input bar, so we’ll need to hop over to our <code>InputBar</code> composable. Because we’re working with a <code>TextField</code> composable here, things are going to look a little different. Instead, we’ll need to provide a way to style the current input of the <code>TextField</code> using its <code>visualTransformation</code> argument, in the form of a <code>VisualTransformation</code> type. Here we’re going to create our own implementation of a <code>VisualTransformation</code> that will allow us to apply our mention highlighting. We’ll create a new class, <code>MentionHighlightTransformation</code>, implementing the <code>VisualTransformation</code> interface. When implementing this interface, we’ll need to override the <code>filter</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MentionHighlightTransformation</span>() <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VisualTransformation</span> {

    <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">filter</span>(
		<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span>
	)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">TransformedText</span> {
        ...
    }
}</code></pre>

<p>Before we can go on any further and add the use of our <code>buildAnnotatedStringWithColors</code> function, we know that this is going to need a color. To keep our new class flexible, we’ll allow for a <code>Color</code> to be passed in via the class constructor.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MentionHighlightTransformation</span>(
	<span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)</code></pre>

<p>Next, we’ll need to implement the body of the <code>filter</code> function so that the instance of a <code>TransformedText</code> can be returned. For this, we need to provide the transformed text to be contained in the class. For this, we’re going to use the <code>buildAnnotatedStringWithColor</code> function to build a value. The <code>filter</code> function provides us with the text from our input field as an argument, so we’ll pass this directly to our <code>buildAnnotatedStringWithColor</code> function. We’ll also pass the <code>color</code> that is provided via the constructor of our <code>MentionHighlightTransformation</code> class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MentionHighlightTransformation</span>(
	<span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
) <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VisualTransformation</span> {

    <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">filter</span>(
		<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span>
	)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">TransformedText</span> {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-entity">TransformedText</span>(
            buildAnnotatedStringWithColors(
				text.toString(), color),
            <span class="syntax-all syntax-entity">OffsetMapping</span>.<span class="syntax-all syntax-entity">Identity</span>
        )
    }
}</code></pre>

<p>With this in place, we can provide an instance of our <code>MentionHighlightTransformation</code> class to the <code>visualTransformation</code> argument, providing the <code>primary</code> color of our theme for the <code>color</code> argument in the <code>MentionHighlightTransformation</code> constructor.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// InputBar.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">InputBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">sendMessage</span><span class="syntax-all syntax-keyword">:</span> (message<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">contacts</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Contact</span>&gt;
) {
    ...
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        ...
        <span class="syntax-all syntax-entity">TextField</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
                .weight(<span class="syntax-all syntax-constant">1f</span>),
            visualTransformation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MentionHighlightTransformation</span>(
				<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary),
            ...
        )
    }
}

<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MentionHighlightTransformation</span>(
	<span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
) <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">VisualTransformation</span> {

    <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">filter</span>(
		<span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">AnnotatedString</span>
	)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">TransformedText</span> {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-entity">TransformedText</span>(
            buildAnnotatedStringWithColors(
				text.toString(), color),
            <span class="syntax-all syntax-entity">OffsetMapping</span>.<span class="syntax-all syntax-entity">Identity</span>
        )
    }
}</code></pre>

<p>Now when using @ mentions inside of our <code>TextField</code>, we’ll be able to see these highlighted via our custom <code>visualTransformation</code>.</p>

<figure><img src="@.png"/></figure>

<hr />

<h2>Deleting Messages</h2>

<p>At this point, we have a pretty functional messaging UI that allows the user to view a collection of messages, as well as compose messages to send while also being able to tag contacts. After sending messages though, a user might want to remove what they sent, deleting their message from the chat. To support this we’re going to add a small piece of functionality that allows that user to select a message and delete it from the conversation.</p>

<p>Within our <code>ConversationState</code> there is the <code>selectedMessage</code> field - this is what we’re going to be using to allow the user to perform this delete action on a given message. Currently, though, we’re never actually setting this field - before we can display the options that allow the user to perform actions on a message, they’ll need to be a message assigned to this <code>selectedMessage</code> property. To support this, we’re going to add long-press gesture detection to the message items in our list</p>

<p>We’ll start here by adding a new lambda argument to our <code>Message</code> composable, allowing us to pass these long-press events up to the parent composable. When we trigger this, we’ll simply pass the id of the message that has been selected by the user.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>,
    <span class="syntax-all syntax-parameter">onLongPress</span><span class="syntax-all syntax-keyword">:</span> (id<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Then, we’re going to need to modifier the <code>pointerInput</code> modifier implementation that we previously put in place. We are currently only providing an implementation for the <code>onTap</code> gesture, so we’re going to extend this and also add an implementation for the <code>onLongPress</code> gesture. We’re going to only allow the user to trigger actions on messages that they’ve sent, as being able to delete a message that they’ve received isn’t a common UX pattern. So here, if the given <code>direction</code> of the message is equal to <code>MessageDirection.SENT</code>, we’ll trigger the provided <code>onLongPress</code> lambda and pass the <code>id</code> of the selected message.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Message.kt
</span>
<span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> parentModifier
	.pointerInput(<span class="syntax-all syntax-constant">Unit</span>) {
		detectTapGestures(
			onLongPress <span class="syntax-all syntax-keyword">=</span> {
				<span class="syntax-all syntax-keyword">if</span> (
					message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
				) {
                        onLongPress(message.id)
                    }
                },
                onTap <span class="syntax-all syntax-keyword">=</span> { ... }
            )
        }
) {
	...
}</code></pre>

<p>The parent of the <code>Message</code> composable is the <code>Messages</code> composable - while we will be receiving this <code>onLongPress</code> event, there won’t be any way to handle it here. The <code>Messages</code> composable isn’t hooked into the event functions that we have in place for other composables, so we’ll again need to pass this up to the next parent where it can be handled. So here, we’ll also need to add a new lambda argument to the <code>Messages</code> composable which will match what we previously added to <code>Message</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">onMessageSelected</span><span class="syntax-all syntax-keyword">:</span> (messageId<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With this in place, we can now implement the <code>onLongPress</code> lambda during the composition of our <code>Message</code> composable, followed by using this to trigger the <code>onMessageSelected</code>. Here we’ll directly pass the <code>id</code> of the message that was received from the lambda.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span>
items(entry.value) { message <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-entity">Message</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
		message <span class="syntax-all syntax-keyword">=</span> message,
		onLongPress <span class="syntax-all syntax-keyword">=</span> { messageId <span class="syntax-all syntax-keyword">-&gt;</span>
			onMessageSelected(messageId)
		}
	)
}</code></pre>

<p>Finally, we’ll then need to implement the <code>onMessageSelected</code> at the point we compose <code>Messages</code>, which is being done within the <code>Conversation</code> composable. Here within the body of <code>onMessageSelected</code>, we’ll want to trigger the <code>handleEvent</code> lambda that the <code>Conversation</code> composable has access to, triggering the <code>SelectMessage</code> event which we instantiate using the received message <code>id</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Conversation.kt
</span>
<span class="syntax-all syntax-entity">Messages</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize().weight(<span class="syntax-all syntax-constant">1f</span>),
	messages <span class="syntax-all syntax-keyword">=</span> state.messages,
	onMessageSelected <span class="syntax-all syntax-keyword">=</span> { messageId <span class="syntax-all syntax-keyword">-&gt;</span>
    	handleEvent(<span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">SelectMessage</span>(messageId))
    }
)</code></pre>

<p>With all of the above in place, we now have an implementation that allows for a user to mark a message as selected - it is at this point that we will need to show some form of UI to reflect this. Here we’re going to create a new composable function, <code>MessageActions</code>, which will be used to display the available actions to the user. We’ll add three arguments to our composable function here:</p>

<ul>
	<li><strong>modifier</strong>: the modifier that will be used to apply modifications to the actions composable</li>
	<li><strong>onDismiss</strong>: a lambda that will be triggered when the dialog is dismissed. This will allow us to remove the currently selected message from our state</li>
	<li><strong>onUnsendMessage</strong>: for now, our dialog will only be supporting the ability to trigger an <strong>unsend message</strong> event. This lambda will allow us to pass this event up to the parent.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageActions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onDismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onUnsendMessage</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Inside of this, we’re going to compose a <code>Dialog</code>. This is a composable from the compose UI package that allows us to show a system dialog to users, which is intended to sit on top of all other content on the screen. When composed in this way, an overlay will be used to bring focus to the dialog on the screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageActions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onDismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onUnsendMessage</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Dialog</span>(
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            ...
        }
    ) {
        
    }
}</code></pre>

<p>The <code>Dialog</code> composable has two required arguments, <code>onDismissRequest</code> and <code>content</code>. The second, <code>content</code> is used to provide a composable which we want to be used for the composition of the dialog body. On the other hand, <code>onDismissRequest</code> is used to handle any requests to dismiss the dialog - which must be handled to ensure that our UI is recomposed without the dialog. Here we’ll simply trigger the <code>onDismiss</code> lambda that is provided to our <code>MessageActions</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageActions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onDismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onUnsendMessage</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Dialog</span>(
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            onDismiss()
        }
    ) {
        
    }
}</code></pre>

<p>Next, we can move on to composing the content area of our <code>Dialog</code>. We’re only going to be showing a single child here, so it will suffice to compose a <code>Box</code> here. For this, we’ll also want to set the background using the <code>surface</code> color from our application theme.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageActions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onDismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onUnsendMessage</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Dialog</span>(
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            onDismiss()
        }
    ) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
                .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface)
        ) {
            
        }
    }
}</code></pre>

<p>Within this box, we’re going to add a single button that will be used to trigger the unsend message event. This button is going to need to portray that action to the user, so we’ll need to start by adding a new string to our <code>strings.xml</code> resource file to represent this.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;action_unsend_message&quot;</span>&gt;Unsend Message&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Within our <code>Box</code> we can then go ahead and compose a <code>TextButton</code>. This button will be used to display an action to the user in the form of the unsend message action. Here we’ll need to provide an implementation for <code>onClick</code>, along with the <code>content</code> for the composable body. Within <code>onClick</code> we’ll simply want to trigger the <code>onUnsendMessage</code> lambda that is provided to our composable function.</p>

<p>Within the <code>content</code> we’ll want to provide the composable that is to be composed inside of our <code>TextButton</code>. Here we’re going to compose a <code>Text</code> composable, followed by providing the string resource that we defined above for the <code>text</code> argument of this. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageActions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onDismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onUnsendMessage</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Dialog</span>(
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            onDismiss()
        }
    ) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
                .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface)
        ) {
            <span class="syntax-all syntax-entity">TextButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                onUnsendMessage()
            }) {
                <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.action_unsend_message))
            }
        }
    }
}</code></pre>

<p>At this point, we have a <code>Dialog</code> composable that can be used to display the <strong>unsend message</strong> action within our UI.</p>

<figure><img src="1-25.png"/></figure>

<p>As we can see though, the constraints of this dialog feel a little small within our UI. We can improve things here by applying some sizing modifiers to our <code>Box</code> composable. We’ll use the <code>sizeIn</code> modifier to apply some minimum constraints to our composable. Because we are now modifying the size of our composable, we’ll also need to ensure that any content inside of it is correctly aligned. Here we’ll use the <code>contentAlignment</code> argument of the <code>Box</code> to apply the <code>Alignment.Center</code> value to align the content into the center.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MessageActions</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">onDismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onUnsendMessage</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Dialog</span>(
        onDismissRequest <span class="syntax-all syntax-keyword">=</span> {
            onDismiss()
        }
    ) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
                .background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface)
                .sizeIn(minWidth <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">280</span>.dp, minHeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">80</span>.dp),
            contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
        ) {
            <span class="syntax-all syntax-entity">TextButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                onUnsendMessage()
            }) {
                <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.action_unsend_message))
            }
        }
    }
}</code></pre>

<p>We can see now that these additional sizing constraints complement the composition of our<code>Dialog</code>.</p>

<figure><img src="2-24.png"/></figure>

<p>With the above built out, we can now add the composition of this inside of our <code>Conversation</code> composable. We’ll want to compose this outside of the existing <code>Column</code> composable so that it appears on top of the screen content. When composing our <code>MessageActions</code> this will need to be conditional, as we only want it to be displayed to the user if there is currently a selected message. Here we’ll use the <code>selectedMessage</code> property from our <code>ConversationState</code> to have conditional composition, only composing our <code>MessageActions</code> if a message <strong>is</strong> currently selected.</p>

<p>When composing these <code>MessageActions</code> we’ll need to implement both the <code>onDismiss</code> and <code>onUnsendMessage</code> arguments. Both of these are going to be minimal work, as we’ll just need to call the <code>handleEvent</code> lambda that is provided to our <code>Conversation</code> composable.</p>

<p>For <code>onDismiss</code> we’ll want to trigger the <code>UnselectMessage</code> event. We don’t need to require any arguments to this object, as this will simply remove the currently selected message from the state. For <code>onUnsendMessage</code> we’ll trigger the <code>UnsendMessage</code> event, passing the <code>id</code> of the currently selected message in our state. This will remove the message from our messages list, triggering recomposition and removing it from our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Conversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        <span class="syntax-all syntax-entity">Header</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            onClose <span class="syntax-all syntax-keyword">=</span> {
                <span class="syntax-all syntax-comment">// finish activity
</span>            }
        )
        <span class="syntax-all syntax-entity">Messages</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>),
            messages <span class="syntax-all syntax-keyword">=</span> state.messages,
            handleEvent
        )
        <span class="syntax-all syntax-entity">InputBar</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            handleEvent,
            state.contacts
        )
    }
    <span class="syntax-all syntax-keyword">if</span> (state.selectedMessage <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>) {
        <span class="syntax-all syntax-entity">MessageActions</span>(
            onDismiss <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">UnselectMessage</span>)
            },
            onUnsendMessage <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">UnsendMessage</span>(
					state.selectedMessage.id))
            }
        )
    }
}</code></pre>

<p>With this now added to the composition for our <code>Conversation</code> composable, our users will now be able to trigger message actions from the messages list - currently allowing them to unsend a message.</p>

<figure><img src="2-25.png"/></figure>

<hr />

<h2>Improving the Message Accessibility</h2>

<p>While we’ve added support for unsending a message, as well viewing the sent time for a message in a conversation, these features aren’t currently accessible to users who might interact with the project via accessibility services. In this section, we’re going to spend a small amount of time improving the accessibility for these pieces of functionality.</p>

<h3>Supporting Accessibility actions</h3>

<p>We’re going to start here by adding support for a <code>CustomAccessibilityAction</code> to the messages in the conversation. This means that users who have talkback enabled will be able to trigger the <strong>Unsend Message</strong> action natively through the accessibility actions menu. We can provide these <code>customActions</code> via the <code>semantics</code> modifier.</p>

<p>When creating a <code>CustomAccessibilityAction</code> to show via the accessibility actions menu, we need to provide a label that will be displayed for the action. We’ll start here by retrieving the existing <code>action_unsend_message</code> string resource that we’re using in our <code>MessageActions</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span>
items(entry.value) { message <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> unSendMessageLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.action_unsend_message)
	
	<span class="syntax-all syntax-entity">Message</span>(
		...
    )
}</code></pre>

<p>Next, we’ll use this string resource to create a <code>CustomAccessibilityAction</code> instance, providing it to the semantics <code>customActions</code> property in the form of a list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span>
items(entry.value) { message <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> unSendMessageLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.action_unsend_message)
	
	<span class="syntax-all syntax-entity">Message</span>(
		<span class="syntax-all syntax-entity">Modifier</span>
			.semantics {
				customActions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(
					<span class="syntax-all syntax-entity">CustomAccessibilityAction</span>(
						unSendMessageLabel
					) {
                        ...
                        <span class="syntax-all syntax-constant">true</span>
                    }
                )
            }
            .fillMaxWidth(),
        message <span class="syntax-all syntax-keyword">=</span> message,
        onLongPress <span class="syntax-all syntax-keyword">=</span> { messageId <span class="syntax-all syntax-keyword">-&gt;</span>
        	onMessageSelected(messageId)
        }
    )
}</code></pre>

<p>You’ll notice here that we haven’t yet implemented the <code>action</code> of the <code>CustomAccessibilityAction</code>, we are just returning <code>true</code> to indicate that we have handled the action. To support the unsending of a message here, we’ll need a new lambda argument for our <code>Messages</code> composable that can be used to pass this event up to the parent composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">onMessageSelected</span><span class="syntax-all syntax-keyword">:</span> (messageId<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">unSendMessage</span><span class="syntax-all syntax-keyword">:</span> (messageId<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We can’t hen trigger this lambda within the <code>action</code> of our <code>CustomAccessibilityAction</code>, passing the <code>id</code> of the message that the action has been invoked on.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span>
items(entry.value) { message <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> unSendMessageLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.action_unsend_message)
	<span class="syntax-all syntax-entity">Message</span>(
		<span class="syntax-all syntax-entity">Modifier</span>
			.semantics {
				customActions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(
					<span class="syntax-all syntax-entity">CustomAccessibilityAction</span>(
						unSendMessageLabel
					) {
                        unSendMessage(message.id)
                        <span class="syntax-all syntax-constant">true</span>
                    }
                )
            }
            .fillMaxWidth(),
        message <span class="syntax-all syntax-keyword">=</span> message,
        onLongPress <span class="syntax-all syntax-keyword">=</span> { messageId <span class="syntax-all syntax-keyword">-&gt;</span>
        	onMessageSelected(messageId)
        }
    )
}</code></pre>

<p>This won’t quite work yet, as we’ll need to implement this lambda argument at the point we are composing our <code>Messages</code> composable. If we hop on over to the <code>Conversation</code> composable then we can implement this lambda, using the provided <code>id</code> of the message to trigger the <code>UnsendMessage</code> action through the <code>handleEvent</code> lambda.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Conversation.kt
</span>
<span class="syntax-all syntax-entity">Messages</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize().weight(<span class="syntax-all syntax-constant">1f</span>),
    messages <span class="syntax-all syntax-keyword">=</span> state.messages,
    onMessageSelected <span class="syntax-all syntax-keyword">=</span> { messageId <span class="syntax-all syntax-keyword">-&gt;</span>
    	handleEvent(<span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">SelectMessage</span>(messageId))
    },
    unSendMessage <span class="syntax-all syntax-keyword">=</span> { messageId <span class="syntax-all syntax-keyword">-&gt;</span>
      	handleEvent(<span class="syntax-all syntax-entity">ConversationEvent</span>.<span class="syntax-all syntax-entity">UnsendMessage</span>(messageId))
    }
)</code></pre>

<p>With this in place, our user will be able to access the <strong>unsend message</strong> action through the accessibility actions menu.</p>

<figure><img src="acc.png"/></figure>

<h3>Communicating the Sent Time</h3>

<p>Currently, we’re supporting the toggling of the sent time by tapping the message. To reduce the number of interactions that need to be taken by accessibility services to achieve this, we’re going to incorporate the sent time into the content that is read by talkback. To do this, we’re going to need to reformat the <code>message</code> of the corresponding <code>Message</code> reference to include the sent time, only for use by talkback.</p>

<p>To incorporate this, we’ll need to start by shifting around some of the things that we’ve already defined within our <code>Message</code> composable. First of all, the <code>dateFormat</code> reference that we have will need to be pulled up to a higher point within the composable. Currently, this is only being used for the display of the sent time, which is quite nested within the composable. However, we now need this at a higher point in the composable to be able to utilise it as a semantic property for the <code>Box</code> composable that wraps our <code>MessageBody</code>. We’ll also need to pull out the <code>format</code> operation that was being directly used for the sent time <code>Text</code> composable, assigning this to a variable reference, <code>formattedSentTime</code>. We can now use this for the <code>text</code> argument of the sent time <code>Text</code> composable, as well as have it available for reuse by our <code>MessageBody</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span>(...) {

		...

        <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember {
            <span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;hh:mm&quot;</span>)
        }
        <span class="syntax-all syntax-keyword">val</span> formattedSentTime <span class="syntax-all syntax-keyword">=</span> 	
			dateFormat.format(message.dateTime.time)
        
        <span class="syntax-all syntax-entity">Box</span>(...) {
            ...
        }
        
        <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment),
            visible <span class="syntax-all syntax-keyword">=</span> displaySentTime
        ) {
            <span class="syntax-all syntax-entity">Text</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
                text <span class="syntax-all syntax-keyword">=</span> formattedSentTime,
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
            )
        }
    }</code></pre>

<p>Now that we have this <code>formattedSentTime</code> variable, we can utilise this to provide the sent time through the accessibility services. We’ll start here by defining a new string resource that will act as a template for our sent time and message content.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;message_with_time&quot;</span>&gt;%s. %s&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Here, the first placeholder (%s) will be used for the sent time. Then after the period, we’ll format the second placeholder as the message content. This way talkback will read out the sent time, followed by the message content. We’ll go ahead by building a string representation using this description. We’ll firsts the <code>stringResource</code> composable function to retrieve our resource, followed by providing two string values that will be used to populate the placeholders - these are the <code>sentAt</code> argument that is being provided to our composable, along with the <code>message</code> property of our <code>Message</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> messageWithSentTime <span class="syntax-all syntax-keyword">=</span> stringResource(
	id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.message_with_time,
	formattedSentTime, 
	message.message <span class="syntax-all syntax-keyword">?:</span> message.altText <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
)</code></pre>

<p>Next, we’ll override the <code>text</code> semantic property of our composable, creating a new instance of an <code>AnnotatedString</code> from our built <code>messageWithSentTime</code> variable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Box</span>(	
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment)
        .semantics {
            text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>(messageWithSentTime)
        }
        .background(
            <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">LightGray</span>,
            <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">6</span>.dp)
        )
        .padding(<span class="syntax-all syntax-constant">8</span>.dp)
) {
	...
}</code></pre>

<p>Now when this composable is described by talkback, our override that we provided to the <code>text</code> semantic will be used within the description of the content. Overall, we should have a composable function that represents something like the following.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span>,
    <span class="syntax-all syntax-parameter">onLongPress</span><span class="syntax-all syntax-keyword">:</span> (id<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> parentModifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
		message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
	) {
        modifier.padding(end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)
    } <span class="syntax-all syntax-keyword">else</span> modifier.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp)

    <span class="syntax-all syntax-keyword">var</span> displaySentTime by remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }

    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> parentModifier
        .pointerInput(<span class="syntax-all syntax-constant">Unit</span>) {
            detectTapGestures(
                onLongPress <span class="syntax-all syntax-keyword">=</span> {
                    <span class="syntax-all syntax-keyword">if</span> (
						message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
					) {
                        onLongPress(message.id)
                    }
                },
                onTap <span class="syntax-all syntax-keyword">=</span> {
                    displaySentTime <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">!</span>displaySentTime
                }
            )
        }) {

        <span class="syntax-all syntax-keyword">val</span> alignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (
			message.direction <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>
		) {
            <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">End</span>
        } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span>

        <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember {
            <span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;hh:mm&quot;</span>)
        }
        <span class="syntax-all syntax-keyword">val</span> formattedSentTime <span class="syntax-all syntax-keyword">=</span> dateFormat.format(
			message.dateTime.time)

        <span class="syntax-all syntax-keyword">val</span> messageWithSentTime <span class="syntax-all syntax-keyword">=</span> stringResource(
			id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.message_with_time,
            formattedSentTime, 
			message.message <span class="syntax-all syntax-keyword">?:</span> message.altText <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
		)
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .align(alignment <span class="syntax-all syntax-keyword">=</span> alignment)
                .semantics {
                    text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">AnnotatedString</span>(messageWithSentTime)
                }
                .background(
                    <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">LightGray</span>,
                    <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">6</span>.dp)
                )
                .padding(<span class="syntax-all syntax-constant">8</span>.dp)
        ) {
            <span class="syntax-all syntax-entity">MessageBody</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>),
                message <span class="syntax-all syntax-keyword">=</span> message
            )
        }

        <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.align(alignment <span class="syntax-all syntax-keyword">=</span> alignment),
            visible <span class="syntax-all syntax-keyword">=</span> displaySentTime
        ) {
            <span class="syntax-all syntax-entity">Text</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp),
                text <span class="syntax-all syntax-keyword">=</span> formattedSentTime,
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
            )
        }
    }
}</code></pre>

<hr />

<h2>Always displaying the latest Message</h2>

<p>At this point, we have a pretty functional messaging UI, but there’s one final tweak that I want us to make. Currently, when you send a message within the UI, you’ll need to scroll to view that message when really, the UI should update to automatically scroll to the bottom of the message list. This means that the latest message will always be visible to the user. To achieve this, we’re going to need to tweak some of the approaches that we’ve previously put in place for the display of messages.</p>

<p>When it comes to always showing the latest message in the conversation, we’re going to want to display the last item in the list. However, this isn’t a straightforward operation - while we can perform a scroll event to the last item in the list, we don’t know the height of that item, so we would need to calculate an offset to be applied after the scroll has taken place. This feels overly complex, so instead, we’re going to utilise the <code>reverseLayout</code> argument of the <code>LazyColumn</code> composable to help us achieve this.</p>

<p>But why would we want to reverse the list of messages? Well, if the list of messages has been reversed, then we can scroll to the item position <code>0</code> in the list without needing to worry about any kind of offsetting based on height. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">LazyColumn</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier,
	state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState(),
	reverseLayout <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
	contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp, bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp),
	verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.spacedBy(<span class="syntax-all syntax-constant">16</span>.dp)
)</code></pre>

<p>Now that the list is reversed, we’ll notice that the message items within the conversation are now being displayed in the wrong order - this is because the <code>reverseLayout</code> argument is flipping the presentation of these items. To fix this, we’re going to modify our <code>groupMessagesByDate</code> function so that the <code>sortedByDescending</code> operation is used to sort the messages by the time that the message was sent.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">groupMessagesByDate</span>(
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Map</span>&lt;<span class="syntax-all syntax-entity">Calendar</span>, <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;&gt; {
    <span class="syntax-all syntax-keyword">return</span> messages
        .sortedByDescending {
            it.dateTime.timeInMillis
        }
        .groupBy {
            it.dateTime.<span class="syntax-all syntax-constant">apply</span> {
                set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">HOUR_OF_DAY</span>, <span class="syntax-all syntax-constant">0</span>)
                set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">MINUTE</span>, <span class="syntax-all syntax-constant">0</span>)
                set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">SECOND</span>, <span class="syntax-all syntax-constant">0</span>)
                set(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">MILLISECOND</span>, <span class="syntax-all syntax-constant">0</span>)
            }
        }
}</code></pre>

<p>At this point the messages will be displayed in the correct order, but because we’ve now reversed the layout of our items the sticky headers are being displayed at the bottom of each message group. This is a simple fix as we just need to re-order the declarations of the <code>items</code> and <code>stickyHeader</code> - this means that now each of the header items will be displayed at the top of each message group, corresponding with the now reversed item layout.</p>

<pre><code class="code-highlighted code-kt">grouped.onEach { entry <span class="syntax-all syntax-keyword">-&gt;</span>

	items(entry.value) { message <span class="syntax-all syntax-keyword">-&gt;</span>
		...
	}

	stickyHeader {
		...
	}

}</code></pre>

<p>Now that the layout ordering of our list is in place, we’re going to want to take a look at triggering the scrolling to the latest message whenever the <code>messages</code> that are provided to our composable function are changed. For this we can utilise the <code>LaunchedEffect</code> side-effect, allowing us to trigger some logic at the time of composition, conditionally.</p>

<p>When <code>LaunchedEffect</code> enters the composition, it will execute the <code>block</code> implementation that is provided to it. However, we only want to run this when the <code>messages</code> have changed - otherwise we might be executing this scroll action when it doesn’t need to be. For this, the <code>LaunchedEffect</code> also takes a <code>key</code> - this allows us to provide a value that will be used to determine if the side-effect should be run, which will only be the case when the <code>key</code> value changes. For this, we can declare the <code>LaunchedEffect</code> side-effect, passing the <code>messages</code> reference for the <code>key</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">onMessageSelected</span><span class="syntax-all syntax-keyword">:</span> (messageId<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (messages.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">EmptyConversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
        )
    } <span class="syntax-all syntax-keyword">else</span> {
        ...
        <span class="syntax-all syntax-entity">LaunchedEffect</span>(messages) {
            ...
        }
    }
}</code></pre>

<p>With this declared, we can now add the logic that will be used to trigger the scrolling of our list. For this, we’ll need to access our <code>LazyListState</code> reference from within our side-effect, so we’ll want to pull out the <code>rememberLazyListState</code> usage from our <code>LazyColumn</code> and store the result in a <code>state</code> variable reference. This means that we can then utilise the <code>scrollToItem</code> function from the <code>LazyListState</code> class, providing the index of the first item within the <code>messages</code> list - we use the first item here because the layout of our items has been reversed via the <code>reverseLayout</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">messages</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Message</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">onMessageSelected</span><span class="syntax-all syntax-keyword">:</span> (messageId<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (messages.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">EmptyConversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
        )
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-keyword">val</span> state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
        <span class="syntax-all syntax-keyword">val</span> grouped <span class="syntax-all syntax-keyword">=</span> groupMessagesByDate(messages)
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> state,
			reverseLayout <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
				top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
			),
            verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.spacedBy(<span class="syntax-all syntax-constant">16</span>.dp)
        ) { ... }
        <span class="syntax-all syntax-entity">LaunchedEffect</span>(messages) {
            state.scrollToItem(<span class="syntax-all syntax-constant">0</span>)
        }
    }
}</code></pre>

<p>With this in place, we’ll be able to send a message within our UI and see that the list is now automatically scrolled to the bottom, displaying the latest message. With this in place, our user will now always be viewing the latest message for the given conversation whenever a message is sent or received within the conversation feed.</p>

<hr />

<h2>Wrapping Up</h2>

<p>Throughout this project, we’ve now fully implemented our messaging feature - allowing our users to view the messages in a current conversation, manage those messages, as well as send new messages via the input bar. We’ve explored the composition of many different UI components, along with some intricate logic for handling @-mentions within our project.</p>

<figure><img src="message-2.png"/></figure>

<p>With all of this in place, we’ll want to ensure these components remain functional within our app. In the next chapter, we’re going to explore writing automated UI tests for these composables.</p>

<h1>Testing the Messaging UI</h1>

<p>Now that we’ve built our Messaging feature, we’re going to take a look at how we can write tests for our composables. We’re going to be writing some instrumentation tests using the compose ui-test-junit package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>)
debugImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to add mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered whenever expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:3.12.4&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependant on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		exclude <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/AL2.0&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/LGPL2.1&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
	}
}</code></pre>

<hr />

<h2>Creating a Test Data Factory</h2>

<p>Before we start writing our tests, we’re going to define some functions that will provide data for us to use during our tests. Throughout our tests, we’re going to need to create instances of the <code>Message</code> class that contains test data. We’ll create a <code>randomString</code> function that allows us to generate a random string for use in tests (such as message content), along with a <code>makeMessage</code> function that allows us to generate a <code>Message</code> instance. Having this factory allows us to simplify the use of test data in our tests, without needing to duplicate this logic throughout our project.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// TestDataFactory.kt
</span>
<span class="syntax-all syntax-keyword">object</span> TestDataFactory {

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">randomString</span>() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">UUID</span>.randomUUID().toString()

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeMessage</span>(
        <span class="syntax-all syntax-parameter">text</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
        <span class="syntax-all syntax-parameter">image</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Bitmap?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    )<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Message</span> {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-entity">Message</span>(
            randomString(),
            <span class="syntax-all syntax-entity">MessageDirection</span>.<span class="syntax-all syntax-entity">SENT</span>,
            <span class="syntax-all syntax-entity">Calendar</span>.getInstance().<span class="syntax-all syntax-constant">also</span> {
                it.add(<span class="syntax-all syntax-entity">Calendar</span>.<span class="syntax-all syntax-entity">DAY_OF_YEAR</span>, <span class="syntax-all syntax-keyword">-</span><span class="syntax-all syntax-constant">5</span>)
            },
            randomString(),
            message <span class="syntax-all syntax-keyword">=</span> text,
            image <span class="syntax-all syntax-keyword">=</span> image
        )
    }
}</code></pre>

<hr />

<h2>Testing the Conversation</h2>

<p>At a high level of our feature is the <code>Conversation</code> composable. While we have a collection of focused composables that are responsible for specific parts of our UI, this composable acts as the parent container - composing each of the child composables that make up the different parts of the messaging feature. For this reason, we’re going to write a collection of tests that will perform asserts to ensure the correct composables are displayed as expected. We’ll start here by creating a new test class, <code>ConversationTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ConversationTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the <code>ComposeContentTestRule</code> class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@get:Rule
</span><span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched in, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside of.</p>

<p>With this test class configured, we’re going to write some tests to assert that each of the expected composables is being displayed when required - which will be based on the state which is provided to the <code>Conversation</code> composable. We’ll start here by asserting that the header is being composed - the header should always be composed within the messaging screen, so we don’t need to worry about passing any specific state to it.</p>

<p>To write this first test we’ll use the <strong>@Test</strong> annotation and create a new function to test that the header is displayed by default within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header_Displayed</span>() {
    
}</code></pre>

<p>Inside of this test, we’re going to need to start by setting the composable content that is to be displayed on screen for us to assert against. Here we’ll use the test rule that we previously defined, along with its <code>setContent</code> function. This function takes a composable function as an argument, allowing us to define what is to be composed on screen for our tests. Because we’re wanting to test the <code>Conversation</code> Composable that we defined in the previous sections of this chapter, we’ll go ahead and pass the <code>Conversation</code> composable function for this composable argument. When composing the <code>Conversation</code> we’ll need to provide a reference to a <code>ConversationState</code>, along with an implementation of the <code>handleEvent</code> lambda - this will be blank as we don’t need to use this callback within our test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Conversation</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ConversationState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>So that we can locate the header within our test, we’re going to need to add a tag to the composable that we wish to perform assertions against - this tag can then be used to locate our composable within our tests. We’ll need to start here by defining a tag reference that can be accessed from both our tests and our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_HEADER</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_HEADER&quot;</span>
}</code></pre>

<p>With this tag defined, we’ll then need to add this to our <code>Header</code> composable. We’ll assign this to the top-level composable within the function, using the <code>testTag</code> modifier to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Header.kt
</span>
<span class="syntax-all syntax-entity">TopAppBar</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_HEADER</span>)
)</code></pre>

<p>Next, we’re going to locate the node within our composable hierarchy so that we can perform interactions and assertions on it. Here we’ll utilise the <code>onNodeWithTag</code> function, providing the tag that we defined above. We can then utilise the <code>assertIsDisplayed</code> function to assert that the composable is being displayed as expected within the <code>Conversation</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Header_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Conversation</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ConversationState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_HEADER</span>)
        .assertIsDisplayed()
}</code></pre>

<p>We’re going to do the same for the other composable that are expected to be displayed within the <code>Conversation</code>. To do this we’ll need to add 3 more tags to our <code>Tags.kt</code> file - one for <code>Messages</code>, one for <code>InputBar</code> and one for <code>MessageActions</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_HEADER</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_HEADER&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_MESSAGES</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_MESSAGES&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_INPUT_BAR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_INPUT_BAR&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_MESSAGE_ACTIONS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_MESSAGE_ACTIONS&quot;</span>
}</code></pre>

<p>We’ll then need to assign each of these to the top-level composable in each of the corresponding composable functions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span><span class="syntax-all syntax-entity">LazyColumn</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_MESSAGES</span>),
	state <span class="syntax-all syntax-keyword">=</span> state,
	contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp, bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp),
	verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.spacedBy(<span class="syntax-all syntax-constant">16</span>.dp)
)

<span class="syntax-all syntax-comment">// InputBar.kt
</span><span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_INPUT_BAR</span>))

<span class="syntax-all syntax-comment">// MessageActions.kt
</span><span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier
		.background(<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface)
		.sizeIn(minWidth <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">280</span>.dp, minHeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">80</span>.dp)
		.testTag(<span class="syntax-all syntax-entity">TAG_MESSAGE_ACTIONS</span>),
	contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
)</code></pre>

<p>With these tags in place, we can now proceed to write corresponding tests for each of the expected composables. We’ll start with the display of <code>Messages</code>, for which we’ll need to compose the <code>Conversation</code> and then assert that the node with the <code>TAG_MESSAGES</code> tag is displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Conversation</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ConversationState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGES</span>)
        .assertIsDisplayed()
}</code></pre>

<p>We’ll next do the same for the input bar, utilising the <code>TAG_INPUT_BAR</code> tag to locate the node to perform assertions against.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Input_Bar_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Conversation</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ConversationState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_INPUT_BAR</span>)
        .assertIsDisplayed()
}</code></pre>

<p>Finally, we’ll do the same for the <code>MessageActions</code>, using the <code>TAG_MESSAGE_ACTIONS</code> tag to locate and assert the corresponding composable. When doing this we’ll need to provide a <code>Message</code> for the <code>selectedMessage</code> value within our state - this is because the <code>MessageActions</code> will only be displayed when a message item has been marked as selected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message_Actions_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Conversation</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ConversationState</span>(
                selectedMessage <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMessage()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGE_ACTIONS</span>)
        .assertIsDisplayed()
}</code></pre>

<p>On the flip side, this means that the <code>MessageActions</code> should not be displayed when there is no selected message within our state. For this reason, we’ll go ahead and write another test, this time to assert that the <code>MessageActions</code> are <strong>, not</strong> displayed when there is no selected message. We’ll use the same <code>TAG_MESSAGE_ACTIONS</code> tag to locate the node, followed by using the <code>assertDoesNotExist</code> function to assert that the node does not exist.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message_Actions_Not_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Conversation</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ConversationState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGE_ACTIONS</span>)
        .assertDoesNotExist()
}</code></pre>

<hr />

<h2>Testing the Header</h2>

<p>Now that we have some tests in place to assert each of the composables being displayed inside of a <code>Conversation</code>, we’re going to go a step deeper and add some tests for each of the composables that make up our messaging screen. We’re going to start here by writing some tests for the <code>Header</code> composable, which we’ll need to create a new test class for, <code>HeaderTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">HeaderTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>The <code>Header</code> serves two purposes - display a title and provide a way to exit the conversation. We’re going to start here by testing that the title is displayed as expected - so we’ll create a new test called <code>Title_Displayed</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Header</span>(onClose <span class="syntax-all syntax-keyword">=</span> {})
    }
}</code></pre>

<p>Here we compose the <code>Header</code>, providing an empty implementation for the <code>onClose</code> lambda - we don’t need to use this lambda within this test, so an empty callback is fine. When it comes to the expected title within the <code>Header</code>, in our cases this is always going to be the <code>title_chat</code> string resource. For this reason, we’re going to fetch the string representation of this using the <code>InstrumentationRegistry</code> class from the android test package. This class allows us to retrieve the instrumentation that is currently running, giving us access to the current context which in turn allows us to fetch string resources.</p>

<p>Using this string value we can then locate a node that has the corresponding text, using the <code>onNodeWithText</code> function to do so. Once this returns us the <code>SemanticsNodeInteraction</code>, we can utilise the <code>assertIsDisplayed</code> function to assert that there is a node displayed that contains the specific title resource.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Header</span>(onClose <span class="syntax-all syntax-keyword">=</span> {})
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
            .targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.title_chat)
    ).assertIsDisplayed()
}</code></pre>

<p>Alongside this, we also want to assert that the close icon is displayed and triggers the expected callback. We’ll write a single test here to assert that the callback is triggered as expected - as if the close icon did not exist, then the callback would not be triggered. When composing the <code>Header</code>, we’ll pass in a <code>mock</code> lambda function for the <code>onClose</code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based on composable events.</p>

<p>With the <code>Header</code> being composed, we’ll now be able to use the retrieve the node that represents the close icon by using the <code>cd_close_conversation</code> content description. We’ll then use the <code>performClick</code> function to perform a click action on this node. When this click action is triggered, this is the point that we would expect the <code>onClose</code> to be invoked so that the parent composable can handle the authentication event. We can verify this within our test by using mockito and its <code>verify</code> function to assert that the lambda has been invoked. If this is the case, the test will succeed - otherwise, the lambda not being triggered will mean that our verification will not be satisfied and the test will fail.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Close_Listener_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onClose<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Header</span>(onClose <span class="syntax-all syntax-keyword">=</span> onClose)
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
            .context.getString(<span class="syntax-all syntax-entity">R</span>.string.cd_close_conversation)
    ).performClick()

    verify(onClose).invoke()
}</code></pre>

<hr />

<h2>Testing the Empty State</h2>

<p>When there are no messages to display, the <code>EmptyConversation</code> composable is used to portray this state to the user. We’re going to write a quick test to ensure that the <code>EmptyConversation</code> displays the correct information - otherwise this could result in causing some confusion for the user. We’ll start here by creating a new test class, <code>EmptyConversationTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">EmptyConversationTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>Within this test class, we’re going to write a single test, which will be used to assert that the expected message is displayed to the user. We’ll call this test <code>Empty_Message_Displayed</code> and start by composing the <code>EmptyConversation</code> for its content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_Message_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmptyConversation</span>()
    }
}</code></pre>

<p>We’ll then use a similar approach that we took for retrieving a node by its textual content. Here we’ll use the <code>label_no_messages</code> string resource to locate the node that has the empty message text, asserting that it is displayed via the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_Message_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">EmptyConversation</span>()
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation().context
            .getString(<span class="syntax-all syntax-entity">R</span>.string.label_no_messages)
    ).assertIsDisplayed()
}</code></pre>

<p>With this test in place, we now know that the <code>EmptyConversation</code> composable is displaying the expected message - avoiding any confusion for the user when the conversation is in an empty state.</p>

<hr />

<h2>Testing the display of Messages</h2>

<p>The main purpose of our messaging feature is to display messages to the user, so we’re going to want to write some tests to ensure that messages are being displayed as expected. We’ll start by creating a new class to hold these tests, <code>MessagesTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MessagesTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>The <code>Messages</code> composable is responsible for two things:</p>

<ul>
	<li>Displaying the empty state when the list of messages is empty</li>
	<li>Displaying a feed of messages when there are messages to display</li>
</ul>

<h3>Testing the Empty state</h3>

<p>We’re going to want to cover both of these scenarios, so we’ll continue with the theme of empty states by first putting together some tests to assert that the empty state is only composed under the specified conditions. We’ll start with the condition where the empty state should be composed within the <code>Messages</code> composable. Here we’ll need to compose the <code>Messages</code>, providing an empty list for the <code>messages</code> argument. We can prove empty lambda blocks for the remaining arguments, as we don’t need any implementations there for this test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_Messages_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Messages</span>(
            messages <span class="syntax-all syntax-keyword">=</span> emptyList(),
            onMessageSelected <span class="syntax-all syntax-keyword">=</span> { },
            unSendMessage <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>We’ll need to be able to locate the node that represents the empty state, so we’ll start by adding a new tag that can be assigned to our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_EMPTY</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_EMPTY&quot;</span>
}</code></pre>

<p>With this tag in place, we’ll now need to assign this tag to the <code>EmptyConversation</code> composable, we’ll use the <code>testTag</code> modifier to apply this to the top-level composable within the function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// EmptyConversation.kt
</span><span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_EMPTY</span>))</code></pre>

<p>With this tag in place, we can now use this to assert that the composable is being displayed under the expected conditions. In this first test, we are providing an empty list to the <code>Messages</code> composable, so it would be expected that the node with the <code>TAG_EMPTY</code> tag is being displayed. In this case, we can locate the node using this tag, followed by verifying that it is being displayed via the use of the <code>assertIsDisplayed</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_Messages_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Messages</span>(
            messages <span class="syntax-all syntax-keyword">=</span> emptyList(),
            onMessageSelected <span class="syntax-all syntax-keyword">=</span> { },
            unSendMessage <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_EMPTY</span>)
        .assertIsDisplayed()
}</code></pre>

<p>As well as asserting that the empty state is displayed, we’re also going to want to be sure that it is never displayed when messages are being provided. In this case, we’ll take the same approach as the previous test, but use our <code>MessageFactory</code> to provide a list of messages to the <code>Messages</code> composable. With this in place, we can now locate the node and use the <code>assertDoesNotExist</code> function to assert that the composable does not exist.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_Messages_Never_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Messages</span>(
            messages <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages(),
            onMessageSelected <span class="syntax-all syntax-keyword">=</span> { },
            unSendMessage <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_EMPTY</span>)
        .assertDoesNotExist()
}</code></pre>

<h3>Testing the message list display</h3>

<p>Alongside the display of the empty state, we’re also going to want to check that the list of messages is being displayed inside of the message list - along with the respective data separator. Currently, there doesn’t seem to be a reliable way to test the expected order of sticky headers and items within a <code>LazyColumn</code> - so for now we’re just going to test that the expected content is present within the composed UI, ignoring the ordering of items for now. When this changes in the compose APIs in future, we can circle back and improve our tests here.</p>

<p>For this test, we’re going to start by composing <code>Messages</code>, when doing so we’ll want to pass in a list of <code>Message</code> references that we’ll create using our <code>MessageFactory</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> messages <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Messages</span>(
            messages <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages(),
            onMessageSelected <span class="syntax-all syntax-keyword">=</span> { },
            unSendMessage <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>We’ll next want to replicate what’s happening within our composable function - this is the grouping of messages by date. When this grouping occurs we get access to not only the messages but also the date labels that represent the groupings. This means that we can assert that both of these different kinds of information are being displayed to the user. </p>

<p>After using this <code>groupMessagesByDate</code> function we’re going to want to loop through each of the entries in the generated map. We’re first going to want to assert that each of the generated date labels is being composed within the <code>LazyColumn</code>. Using the <code>TAG_MESSAGES</code> tag to locate the node that represents the list of messages, we’ll use the <code>onChildren</code> function to obtain a <code>SemanticsNodeInteraction</code> reference that represents the children of that node. Next, we’re going to want to assert that the expected date label is contained within this list of children. So that we can locate this node, we’re going to start by adding a new <code>testTag</code> to the <code>MessageHeader</code> composable. For this, we’ll use the <code>timeInMillis</code> value for the <code>Calendar</code> that is the key of the current entry.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span><span class="syntax-all syntax-entity">MessageHeader</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxWidth()
		.testTag(entry.key.timeInMillis.toString()),
	isToday <span class="syntax-all syntax-keyword">=</span> isToday(entry.key),
	date <span class="syntax-all syntax-keyword">=</span> entry.key
)</code></pre>

<p>Then we can use the <code>assertAny</code> function on the list of children to assert that any of those children match the specified <code>matcher</code>. For this <code>matcher</code>, we’ll use the <code>hasTestTag</code> function to provide a tag that we expect any of the children to have - which in this case is the <code>timeInMillis</code> value for the current entry.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> messages <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Messages</span>(
            messages <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages(),
            onMessageSelected <span class="syntax-all syntax-keyword">=</span> { },
            unSendMessage <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    groupMessagesByDate(messages).forEach { entry <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGES</span>)
            .onChildren()
            .assertAny(hasTestTag(
				entry.key.timeInMillis.toString()))
    }
}</code></pre>

<p>At this point, we know that the list of children contains each of the expected date header entries, but we still need to know about each of the <code>Message</code> items. Within this current <code>forEach</code> loop we’re also going to want to loop through each of the <code>Message</code> references that are represented for the <code>value</code> of the current map entry. Within this additional loop, we’re going to approach this the same way as the previous assertions, except this time we want to assert that the corresponding <code>Message</code> is contained within the list of children.</p>

<p>To be able to assert this, we’ll want to provide a <code>testTag</code> to the <code>Message</code>. We’ll need to start by adding a new tag to our <code>Tags.kt</code> file in the form of <code>TAG_MESSAGE_</code> - we include an <code>_</code> as a suffix so that we can append the <code>id</code> of the message onto the tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_MESSAGE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_MESSAGE_&quot;</span>
}</code></pre>

<p>With this tag in place, we can now assign it to our <code>Message</code> composable. Here we’ll use this <code>TAG_MESSAGE</code> and append the <code>id</code> of the current message onto it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messages.kt
</span>
<span class="syntax-all syntax-entity">Message</span>(
	<span class="syntax-all syntax-entity">Modifier</span>
		.semantics {
			customActions <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(
				<span class="syntax-all syntax-entity">CustomAccessibilityAction</span>(unSendMessageLabel) {
                	unSendMessage(message.id)
                	<span class="syntax-all syntax-constant">true</span>
                }
            )
		}
		.fillMaxWidth()
		.testTag(<span class="syntax-all syntax-entity">TAG_MESSAGE</span> <span class="syntax-all syntax-keyword">+</span> message.id),
	...
)</code></pre>

<p>Now that this tag has been assigned e can use the <code>hasTestTag</code> function to assert that the list of children contains a node that has the expected message tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messages_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> messages <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Messages</span>(
            messages <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MessageFactory</span>.makeMessages(),
            onMessageSelected <span class="syntax-all syntax-keyword">=</span> { },
            unSendMessage <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    groupMessagesByDate(messages).forEach { entry <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGES</span>)
            .onChildren()
            .assertAny(hasTestTag(
				entry.key.timeInMillis.toString()))

        entry.value.forEach { message <span class="syntax-all syntax-keyword">-&gt;</span>
            composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGES</span>)
                .onChildren()
                .assertAny(
					hasTestTag(<span class="syntax-all syntax-entity">TAG_MESSAGE</span> <span class="syntax-all syntax-keyword">+</span> message.id))
        }
    }
}</code></pre>

<hr />

<h2>Testing the Message</h2>

<p>When it comes to displaying a list of messages in a conversation, these are made up of individual <code>Message</code> composables. In this section, we’re going to write some separate tests to assert that the <code>Message</code> composes the provided content as expected. We’ll house these tests inside of a new test class, <code>MessageTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MessageTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’ll start here by creating a new test to assert that the textual content of a <code>Message</code> is displayed as expected. Composing the <code>Message</code> we’ll need to provide a reference to a <code>Message</code> instance - for this we’ll also need to pass a value for the <code>text</code> argument so that the textual content can be composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Text_Content_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> message <span class="syntax-all syntax-keyword">=</span> randomString()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Message</span>(
			message <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMessage(
            	text <span class="syntax-all syntax-keyword">=</span> message
        	), 
			onLongPress <span class="syntax-all syntax-keyword">=</span> { }
		)
    }
}</code></pre>

<p>So that we can locate this text within the composable, specific to the composable that is meant to be displaying it, we’re going to add another tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_TEXT</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_TEXT&quot;</span>
}</code></pre>

<p>We’ll then want to assign this to the <code>Text</code> composable inside of our <code>Message</code> using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Message.kt
</span><span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_TEXT</span>),
	text <span class="syntax-all syntax-keyword">=</span> buildAnnotatedStringWithColors(
		message.message,
		<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary
	)
)</code></pre>

<p>We can then proceed to locate the composable using this <code>TAG_TEXT</code> tag, followed by the <code>assertTextEquals</code> function to assert that the text of this composable is equal to the content that we defined when constructing the <code>Message</code> instance.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Text_Content_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> message <span class="syntax-all syntax-keyword">=</span> randomString()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Message</span>(
			message <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMessage(
            	text <span class="syntax-all syntax-keyword">=</span> message
        	), 
			onLongPress <span class="syntax-all syntax-keyword">=</span> { }
		)
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_TEXT</span>
    ).assertTextEquals(message)
}</code></pre>

<p>Other than text, our <code>Message</code> can also display an image if one is present. We’re going to take the same approach here as the previous test, so we’ll start by adding another tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_IMAGE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_IMAGE&quot;</span>
}</code></pre>

<p>Followed by assigning this to the <code>Image</code> composable within the <code>Message</code> composable, using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Message.kt
</span><span class="syntax-all syntax-entity">Image</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier
		.size(<span class="syntax-all syntax-constant">120</span>.dp)
        .testTag(<span class="syntax-all syntax-entity">TAG_IMAGE</span>),
    bitmap <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BitmapFactory</span>.decodeResource(
		<span class="syntax-all syntax-entity">LocalContext</span>.current.resources, message.image
	).asImageBitmap(),
    contentDescription <span class="syntax-all syntax-keyword">=</span> message.altText
)</code></pre>

<p>We can then go ahead and use this tag to locate the node within our tests, followed by performing the <code>assertIsDisplayed</code> check to assert that the <code>Image</code> composable is being displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Image_Body_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Message</span>(
			message <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMessage(
            	image <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.drawable.roxy
        	), 
			onLongPress <span class="syntax-all syntax-keyword">=</span> { }
		)
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_IMAGE</span>
    ).assertIsDisplayed()
}</code></pre>

<p>On the flip side, this <code>Image</code> should only be composed when there is an image present in the <code>Message</code>. So in the case when there is no image but only text, we’re going to want to test that the node tagged with <code>TAG_IMAGE</code> does not exist. In this next test, we’ll compose the content using a <code>Message</code> that only contains textual content, followed by using the <code>assertDoesNotExist</code> check to assert that the <code>Image</code> is not being composed under this condition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Image_Body_Never_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Message</span>(
			message <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMessage(
            	text <span class="syntax-all syntax-keyword">=</span> randomString()
        	), 
			onLongPress <span class="syntax-all syntax-keyword">=</span> { }
		)
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_IMAGE</span>
    ).assertDoesNotExist()
}</code></pre>

<p>Similarly, when there is only image content within the <code>Message</code> and not any text, we would also expect the <code>Text</code> composable to not exist within the composable. For this reason, we’ll write a similar test to the previous, except this time using the <code>assertDoesNotExist</code> function to assert that the node with the <code>TAG_TEXT</code> tag does not exist.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Text_Body_Never_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Message</span>(
			message <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMessage(
            	image <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.drawable.roxy
        	), 
			onLongPress <span class="syntax-all syntax-keyword">=</span> { }
		)
    }

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_TEXT</span>
    ).assertDoesNotExist()
}</code></pre>

<p>Aside from the content that is composed inside of the <code>Message</code>, there is also a lambda that is provided to the composable - this is in the form of the <code>onLongPress</code> lambda. We’ve been passing an empty block for this in the previous tests as we didn’t require any kind of interaction with it.</p>

<p>Other than providing a mock implementation of the <code>onLongPress</code> callback, we’re going to need to provide a tag to be assigned to the parent composable within the function. This is the only place we currently need to use this tag, which also allows us to demonstrate how to apply test tags without needing to define them explicitly within the composable function. So when we compose the <code>Message</code> we’ll pass the <code>testTag</code> modifier, along with the mock <code>onLongPress</code> lambda.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Long_Pressed_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> parentTag <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;parent&quot;</span>
    <span class="syntax-all syntax-keyword">val</span> onLongPress<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> message <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMessage(
        text <span class="syntax-all syntax-keyword">=</span> randomString()
    )
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Message</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(parentTag),
            message <span class="syntax-all syntax-keyword">=</span> message,
            onLongPress <span class="syntax-all syntax-keyword">=</span> onLongPress
		)
    }
}</code></pre>

<p>With this in place, we’re now going to utilise the test tag that was provided to our composable. Here we’ll use this to invoke a click event on the composable, using the <code>performTouchInput</code> function to do so. Within the block for this we’ll want to trigger the <code>longClick</code> function - when this long-click event is triggered on our composable it is expected that the <code>onLongPress</code> lambda is triggered. With this in place, we can utilise the mockito <code>verify</code> function to assert that the <code>onLongPress</code> lambda was invoked using the <code>id</code> of the <code>Message</code> that was provided to the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Long_Pressed_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> parentTag <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;parent&quot;</span>
    <span class="syntax-all syntax-keyword">val</span> onLongPress<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> message <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMessage(
        text <span class="syntax-all syntax-keyword">=</span> randomString()
    )
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Message</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(parentTag),
            message <span class="syntax-all syntax-keyword">=</span> message,
            onLongPress <span class="syntax-all syntax-keyword">=</span> onLongPress
		)
    }

    composeTestRule.onNodeWithTag(
        parentTag
    ).performTouchInput {
        longClick()
    }

    verify(onLongPress).invoke(message.id)
}</code></pre>

<hr />

<h2>Testing the Message Actions</h2>

<p>In the tests above we touched on the ability to long-press a message to view the actions that can be performed. Those actions are composed via a separate composable function, <code>MessageActions</code> - which we’re going to write some tests for also. We’ll start by creating a new test class, <code>MessageActionsTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MessageActionsTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>When it comes to the message actions, we’re currently only displaying a single action - which is used to unsend a message. We’ll start by writing a new test here, <code>Unsend_Action_Displayed</code>, to assert that this action is being displayed within the <code>MessageActions</code> composable. Within this test we’ll start by composing the <code>MessageActions</code>, providing empty blocks for both of the <code>onDismiss</code> and <code>onUnsendMessage</code> arguments.</p>

<p>We’ll then want to check that the unsend message action is being displayed. Here we’ll use the <code>action_unsend_message</code> resource to locate a node within our composition whose text matches this resource. We’ll then use the <code>assertIsDisplayed</code> function to assert that this node is displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Unsend_Action_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">MessageActions</span>(onDismiss <span class="syntax-all syntax-keyword">=</span> {}, onUnsendMessage <span class="syntax-all syntax-keyword">=</span> {})
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
            .context.getString(<span class="syntax-all syntax-entity">R</span>.string.action_unsend_message)
    ).assertIsDisplayed()
}</code></pre>

<p>We’ll next want to assert that when this node is interacted with, the expected callback is triggered. We’ll again compose the <code>MessageActions</code> but this time we’ll pass a mock implementation of the <code>unsendListener</code> lambda - this is so that we can verify this is involved when the composable is interacted with.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Unsend_Action_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> unsendListener<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">MessageActions</span>(
			onDismiss <span class="syntax-all syntax-keyword">=</span> {}, 
			onUnsendMessage <span class="syntax-all syntax-keyword">=</span> unsendListener
		)
    }
}</code></pre>

<p>We’ll again use the <code>action_unsend_message</code> string resource to locate the node that represents the <strong>unsend message</strong> action, followed by utilising the <code>performClick</code> function to invoke a click event on the located node. When this click event occurs we would expect the <code>onUnsendMessage</code> lambda to be invoked - so at this point we want to verify that this is the case by utilising the mockito verify function. This allows us to assert that the lambda is triggered as expected when the node is clicked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Unsend_Action_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> unsendListener<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">MessageActions</span>(
			onDismiss <span class="syntax-all syntax-keyword">=</span> {}, 
			onUnsendMessage <span class="syntax-all syntax-keyword">=</span> unsendListener
		)
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
            .context.getString(<span class="syntax-all syntax-entity">R</span>.string.action_unsend_message)
    ).performClick()

    verify(unsendListener).invoke()
}</code></pre>

<hr />

<h2>Testing the Input Bar</h2>

<p>Now that we know the messages and their surrounding content are being composed as expected, we’re going to move on to testing the <code>InputBar</code> composable. This allows us to assert that the composable responsible for the input and sending of messages is displayed and functioning as expected. As if this broke, our messaging app would become pretty redundant to our users! We’ll start here by creating a new test class, <code>InputBarTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">InputBarTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<h3>Testing the message sending logic</h3>

<p>We’re going to start by writing a test to assert that the <strong>Send Message</strong> icon is enabled when there is text entered. If this logic was broken, it would mean that users would be unable to send messages - so this must be working as expected. In our test, we’ll start by composing the <code>InputBar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Send_Message_Enabled_With_Text</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">InputBar</span>(
			sendMessage <span class="syntax-all syntax-keyword">=</span> {}, 
			contacts <span class="syntax-all syntax-keyword">=</span> emptyList()
		)
    }
}</code></pre>

<p>When it comes to interacting with the composables for this test, we’re going to need to be able to input text into the input field, along with asserting the enabled state of the send message icon. To be able to reference these composables, we’ll need to add some tags to these composables - we’ll start by defining some new tags within our <code>tags.kt</code> file.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_MESSAGE_INPUT</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_MESSAGE_INPUT&quot;</span>
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_SEND_MESSAGE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_SEND_MESSAGE&quot;</span>
}</code></pre>

<p>Next, we’ll want to assign these tags to the corresponding composables within our <code>InputBar</code>. For the <code>TextField</code> itself we’ll want to use the <code>testTag</code> function to assign the <code>TAG_MESSAGE_INPUT</code> tag. We’ll then also want to apply the <code>TAG_SEND_MESSAGE</code> tag to the <code>IconButton</code> that is being composed for the <code>trailingIcon</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// InputBar.kt
</span><span class="syntax-all syntax-entity">TextField</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxWidth()
        .testTag(<span class="syntax-all syntax-entity">TAG_MESSAGE_INPUT</span>),
	...,
	trailingIcon <span class="syntax-all syntax-keyword">=</span> {
		<span class="syntax-all syntax-entity">IconButton</span>(
			modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_SEND_MESSAGE</span>)
		)
	}
)</code></pre>

<p>With these tags in place, we can now locate these composables inside of our test. We’ll want to start by utilising the <code>TAG_MESSAGE_INPUT</code> tag to locate the input field, utilising the <code>performTextInput</code> function to input some text into the <code>TextField</code> composable. When this text is input, it is expected that the <strong>Send Message</strong> icon will become enabled for interaction from the user. To assert this, we’ll utilise the <code>TAG_SEND_MESSAGE</code> tag to locate the node that represents the <strong>Send Message</strong> icon, followed by the <code>assertIsEnabled</code> function to assert that this is enabled under these conditions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Send_Message_Enabled_With_Text</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">InputBar</span>(
			sendMessage <span class="syntax-all syntax-keyword">=</span> {}, 
			contacts <span class="syntax-all syntax-keyword">=</span> emptyList()
		)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGE_INPUT</span>)
        .performTextInput(<span class="syntax-all syntax-string">&quot;Hello there!&quot;</span>)

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEND_MESSAGE</span>)
        .assertIsEnabled()
}</code></pre>

<p>On the flip side, we’ll also want to assert that the <strong>Send Message</strong> icon is <strong>disabled</strong> when there is no content entered into the input field. We’ll take the previous test that we wrote, but this time we won’t input any content into the <code>TextField</code>. Instead, after composing the <code>InputBar</code> we’ll go straight into locating the node with the <code>TAG_SEND_MESSAGE</code> tag, followed by utilising the <code>assertIsNotEnabled</code> function to verify that the icon is, in fact, disabled when there is no content present in the <code>TextField</code>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Send_Message_Disabled_With_No_Text</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">InputBar</span>(
			sendMessage <span class="syntax-all syntax-keyword">=</span> {}, 
			contacts <span class="syntax-all syntax-keyword">=</span> emptyList()
		)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEND_MESSAGE</span>)
        .assertIsNotEnabled()
}</code></pre>

<p>In the case where the Send Message icon is enabled, clicking on the icon will invoke the <code>sendMessage</code> lambda that is provided to the <code>InputBar</code> composable. When composing this <code>InputBar</code> we’re going to provide a mock implementation of the <code>sendMessage</code> lambda, meaning that we will then be able to verify any interactions. We’ll again perform the same interaction with the input field by inputting some content - we’ll store this content in a <code>message</code> variable so that we can reference it during the verification step. We’ll then want to go ahead and click on the Send Message icon, when this happens the <code>sendMessage</code> lambda should be triggered. We’ll assert this via the use of the mockito <code>verify</code> function, asserting that this is invoked with the <code>message</code> content that was input into the <code>TextField</code>. With this in place, we are now able to verify that the send message logic is triggered as expected, hoisting the message content up to the parent composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Send_Message_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> message <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Hello there!&quot;</span>
    <span class="syntax-all syntax-keyword">val</span> sendMessage<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">message</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">InputBar</span>(
			sendMessage <span class="syntax-all syntax-keyword">=</span> sendMessage, 
			contacts <span class="syntax-all syntax-keyword">=</span> emptyList()
		)
    }

	composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGE_INPUT</span>)
        .performTextInput(message)
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEND_MESSAGE</span>)
        .performClick()

    verify(sendMessage).invoke(message)
}</code></pre>

<h3>Testing the display of contacts</h3>

<p>When the user is sending a message, we added support for contacts to be @-mentioned. The options for an @-mention are displayed when the user types the @ character, with the contacts being displayed based on what is currently typed for the current word in the input field. </p>

<p>When the requirements for showing the selectable contacts have not been met, we would expect the contacts to not be displayed above the input bar. So that we can ensure this is always the case, we’ll write a test to cover this scenario. We’ll start here by composing the <code>InputBar</code>, providing a list of contacts using the <code>ContactFactory</code> that we are using in the implementation of our project.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Contacts_Not_Displayed_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">InputBar</span>(
			sendMessage <span class="syntax-all syntax-keyword">=</span> {}, 
			contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
		)
    }
}</code></pre>

<p>So that we can reference the composable that it displays the contacts that can be mentioned, we’re going to need to add a new tag to our <code>tags.kt</code> file.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_MENTIONS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_MENTIONS&quot;</span>
}</code></pre>

<p>Then within the <code>InputBar</code>, we’ll go ahead and assign this tag to the <code>Mentions</code> composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// InputBar.kt
</span><span class="syntax-all syntax-keyword">if</span> (showMentions) {
    <span class="syntax-all syntax-entity">Mentions</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            .fillMaxWidth()
            .testTag(<span class="syntax-all syntax-entity">TAG_MENTIONS</span>),
        contacts <span class="syntax-all syntax-keyword">=</span> contacts,
        query <span class="syntax-all syntax-keyword">=</span> selectedWord(textState)
    ) { query, result <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-keyword">val</span> startIndex <span class="syntax-all syntax-keyword">=</span> textState.text.indexOf(query)
        textState <span class="syntax-all syntax-keyword">=</span> textState.replaceText(
            startIndex,
            startIndex <span class="syntax-all syntax-keyword">+</span> query.length, result
        )
    }
}</code></pre>

<p>With this tag in place, we can now use this to reference the composable from within our test. Using this tag, we’ll locate the corresponding node and utilise the <code>assertDoesNotExist</code> function to assert that the composable does not currently exist within our composition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Contacts_Not_Displayed_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">InputBar</span>(
			sendMessage <span class="syntax-all syntax-keyword">=</span> {}, 
			contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
		)
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_MENTIONS</span>
    ).assertDoesNotExist()
}</code></pre>

<p>On the other hand, we’re going to want to assert that the mentions <strong>are</strong> displayed under the specified conditions. Using our pre-existing <code>TAG_MESSAGE_INPUT</code> tag we’re going to use the <code>performTextInput</code> function to input the “@“ character into the input field. When this is done we would expect that the contacts for mentioning are displayed above the input bar. To assert that this is the case we’ll use the <code>TAG_MENTIONS</code> tag to locate the node that represents these selectable contacts, followed by using the <code>assertIsDisplayed</code> function to assert that this is displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Mentions_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">InputBar</span>(
			sendMessage <span class="syntax-all syntax-keyword">=</span> {}, 
			contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
		)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGE_INPUT</span>)
        .performTextInput(<span class="syntax-all syntax-string">&quot;@&quot;</span>)

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_MENTIONS</span>
    ).assertIsDisplayed()
}</code></pre>

<p>While we display the selectable contacts when the @ symbol is entered, there are going to be several conditions where we would then expect the contacts to be hidden from view. For example, if I type “@Joe” followed by a space and “hello”, the selectable contacts should no longer be shown. To ensure that this is the case we’re going to write a test that will simulate this behaviour.</p>

<p>After we’ve entered this &quot;@joe hello&quot; text into our input field using the <code>performTextInput</code> function on the node with the <code>TAG_MESSAGE_INPUT</code> tag, we can continue to assert the expected state of the contacts. Here we expect that the contacts are not visible to the user, so we’ll use the <code>assertDoesNotExist</code> function to assert that this is the case.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Mentions_Hidden</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">InputBar</span>(
			sendMessage <span class="syntax-all syntax-keyword">=</span> {}, 
			contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
		)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_MESSAGE_INPUT</span>)
        .performTextInput(<span class="syntax-all syntax-string">&quot;@joe hello&quot;</span>)

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_MENTIONS</span>
    ).assertDoesNotExist()
}</code></pre>

<p>This would be just one of the cases where we would expect the selectable contacts to be hidden after a state change. If others come to mind for you, feel free to explore writing some tests for them also!</p>

<hr />

<h2>Testing Mentions</h2>

<p>While we have tests in place for the display of contacts within the <code>InputBar</code>, we’re now going to write some tests to assert the composition of the <code>Mentions</code> composable. We’ll start here by creating a new test class, <code>MentionsTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MentionsTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’re first going to want to assert that the expected contacts are composed within the <code>Mentions</code> composable. Here we’ll need to compose <code>Mentions</code>, providing a list of <code>Contact</code> references when doing so - we’ll also need to provide the start of the @ mention <code>query</code> to trigger the matching of contact tags.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Contacts_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Mentions</span>(
            contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;@&quot;</span>,
            onMentionClicked <span class="syntax-all syntax-keyword">=</span> { _, _ <span class="syntax-all syntax-keyword">-&gt;</span>

            }
        )
    }
}</code></pre>

<p>Before we can go ahead and perform our assertions, we’re going to need to add a new tag to our <code>tags.kt</code> file.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CONTACTS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_CONTACTS&quot;</span>
}</code></pre>

<p>We’re then going to want to assert that each of the contacts within our <code>contacts</code> list is being composed inside of the <code>Mentions</code> composable. Here we’ll start by looping through each of the <code>Contact</code> within this list - for each of these we’ll want to assert that there is a composable that represents that contact. Here we’ll use our tag to locate the contacts list, locating the node at the index of the current position in our loop. For the node at this index, we would expect the text of this to equal the name of the current <code>Contact</code> in the loop. So for this, we’ll use the <code>assertTextEquals</code> function to assert that the text of this node is equal to the name. This check will occur for each of the contacts in the list, asserting that the row of contact composables is made up of the contacts that are provided to the <code>Mentions</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Contacts_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Mentions</span>(
            contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;@&quot;</span>,
            onMentionClicked <span class="syntax-all syntax-keyword">=</span> { _, _ <span class="syntax-all syntax-keyword">-&gt;</span>

            }
        )
    }

    contacts.forEachIndexed { index, contact <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTACTS</span>)
            .onChildAt(index)
            .assertTextEquals(contact.name)
    }
}</code></pre>

<p>Now that we know the contacts are being displayed when the @-mention process is triggered, we’re going to want to ensure that the contacts are filtered based on the provided query. So for example, if I provide “@j” to the composable, then only contacts starting with the letter “j” should be composed. So that we can perform this assertion in our test, we’re going to need to take our list of contacts and build a list of contacts that match our provided query. Here we’ll <code>filter</code> out any contacts that do not match our provided query - we’ll do this by utilising the <code>stripMentionSymbol</code> function that we’re already using in the composable implementation, followed by defining the acceptance criteria for the filter predicate based on whether the name of the contact starts with the query that we’ve provided.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Filtered_Contacts_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
    <span class="syntax-all syntax-keyword">val</span> query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;@j&quot;</span>
    <span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter {
        <span class="syntax-all syntax-keyword">val</span> withoutMentionSymbol <span class="syntax-all syntax-keyword">=</span> stripMentionSymbol(
				query.lowercase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())) <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        it.name.lowercase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
			.startsWith(withoutMentionSymbol)
    }
}</code></pre>

<p>With this logic in place, we can now go ahead and compose our <code>Mentions</code> just as we had done previously.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Filtered_Contacts_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
    <span class="syntax-all syntax-keyword">val</span> query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;@j&quot;</span>
    <span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter {
        <span class="syntax-all syntax-keyword">val</span> withoutMentionSymbol <span class="syntax-all syntax-keyword">=</span> stripMentionSymbol(
				query.lowercase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())) <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        it.name.lowercase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
			.startsWith(withoutMentionSymbol)
    }
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Mentions</span>(
            contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            query <span class="syntax-all syntax-keyword">=</span> query,
            onMentionClicked <span class="syntax-all syntax-keyword">=</span> { _, _ <span class="syntax-all syntax-keyword">-&gt;</span>

            }
        )
    }
}</code></pre>

<p>Now that <code>Mentions</code> are being composed, we can go ahead and loop through our <code>mentions</code> reference that we’ve built. We’ll do the same thing as the previous test for the node with the <code>TAG_CONTACTS</code> tag, asserting that the child at the index of the current item in the loop has text equal to the name of the given contact.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Filtered_Contacts_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
    <span class="syntax-all syntax-keyword">val</span> query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;@j&quot;</span>
    <span class="syntax-all syntax-keyword">val</span> mentions <span class="syntax-all syntax-keyword">=</span> contacts.filter {
        <span class="syntax-all syntax-keyword">val</span> withoutMentionSymbol <span class="syntax-all syntax-keyword">=</span> stripMentionSymbol(
				query.lowercase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())) <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        it.name.lowercase(<span class="syntax-all syntax-entity">Locale</span>.getDefault())
			.startsWith(withoutMentionSymbol)
    }
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Mentions</span>(
            contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            query <span class="syntax-all syntax-keyword">=</span> query,
            onMentionClicked <span class="syntax-all syntax-keyword">=</span> { _, _ <span class="syntax-all syntax-keyword">-&gt;</span>

            }
        )
    }

    mentions.forEachIndexed { index, contact <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTACTS</span>)
            .onChildAt(index)
            .assertTextEquals(contact.name)
    }
}</code></pre>

<p>This allows us to assert that the mentions which match the current query we are providing are all being composed within the <code>Mentions</code> bar. If we wanted to go even further here then we could test that the contacts which were filtered out from the initial list are <strong>not</strong> being composed.</p>

<p>So now that we know the contacts are being displayed as expected, we’re going to want to assert that the <code>onMentionClicked</code> lambda is triggered with the selected contact. We’ll start here by creating a mock reference for our lambda, followed by using this for the composition of <code>Mentions</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Contact_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> onMentionClicked<span class="syntax-all syntax-keyword">:</span> 
		(<span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, <span class="syntax-all syntax-parameter">mention</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
    <span class="syntax-all syntax-keyword">val</span> query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;@&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Mentions</span>(
            contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            query <span class="syntax-all syntax-keyword">=</span> query,
            onMentionClicked <span class="syntax-all syntax-keyword">=</span> onMentionClicked
        )
    }
}</code></pre>

<p>Next, we’ll want to use the <code>TAG_CONTACTS</code> tag to retrieve the child at the index <code>1</code>, followed by performing a click action on this node via the use of the <code>performClick</code> function. When this occurs we are clicking on the second contact within the row of contacts, so we would expect the lambda function to be triggered using this contact. We’ll use the mockito <code>verify</code> function to assert that this is the case - verifying that the lambda is invoked, passing the <code>query</code> that was provided to the composable function along with the @-mention representation of the selected contact name. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Contact_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> onMentionClicked<span class="syntax-all syntax-keyword">:</span> 
		(<span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>, <span class="syntax-all syntax-parameter">mention</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> contacts <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContactFactory</span>.makeContacts()
    <span class="syntax-all syntax-keyword">val</span> query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;@&quot;</span>
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Mentions</span>(
            contacts <span class="syntax-all syntax-keyword">=</span> contacts,
            query <span class="syntax-all syntax-keyword">=</span> query,
            onMentionClicked <span class="syntax-all syntax-keyword">=</span> onMentionClicked
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CONTACTS</span>)
        .onChildAt(<span class="syntax-all syntax-constant">1</span>)
        .performClick()
    verify(onMentionClicked).invoke(query, 
		<span class="syntax-all syntax-string">&quot;@&quot;</span> <span class="syntax-all syntax-keyword">+</span> contacts[<span class="syntax-all syntax-constant">1</span>].name)
}</code></pre>

<hr />

<p>With all of these tests in place, we’ve covered a lot of different cases that help to ensure our UI is working as expected. We’ve not only tested that composables are being composed based on the information that they are provided with, but also that they triggered the expected callbacks and trigger state manipulations within our composables. While the tests here aren’t extensive, we’ve been able to learn not only what options are available to us while testing composables, but also the approaches that we can take when doing so.</p>

<h1>Building an Image Gallery</h1>

<p>We see the use of Media in many different applications - whether it’s displaying media for user interaction, or providing a choice of media for the user to select, media is a common aspect of mobile applications.</p>

<figure><img src="main.png"/></figure>

<p>In this chapter, we’re going to walk through an approach to building out an image viewer feature. We’ll be creating the above image gallery screen, which allows the user to load the media from their device into the gallery and select an item to enlarge it into a full-screen preview.</p>

<p>However, for our feature to load the device media contents into the UI, our application is going to need permission to access the device media. For this reason, our feature is going to need to request permission from the user, which is something we can do using the functionality of some additional compose libraries that are offered by Google. Using this approach we’ll be able to:</p>

<ul>
	<li>Check if we have permission to access the media on the device</li>
	<li>Request permission from the user to access the media on their device</li>
	<li>Load the media from the device to display within our composables</li>
	<li>Display specific UI components for when permission to access the media has been denied, prompting the user to adjust permission from the system settings</li>
</ul>

<p>With these points, we’ll learn how to approach common media access flows for applications using Jetpack Compose. With this experience, we’ll be able to tackle media access in our applications, covering common feature sets found within the Android ecosystem. With this, let’s get started with building this image gallery!</p>

<h1>Defining the Gallery data classes</h1>

<p>When it comes to displaying images with our image gallery feature, we’re going to be displaying a grid of images - with each item in that grid representing an item of media from the storage of the device. While we aren’t going to be defining a class representation for the state of our screen (which is for examples sake, as we are not dealing with a lot of state), we’re going to define a class to hold the details for each of the retrieved items from the device storage.</p>

<p>When it comes to the modelling of this data class, we’re not actually going to need much information to display these images in the gallery feed. All we will need is the <code>Uri</code> of the media item, along with the <code>id</code> - which will be used as the key identifier for the item within our feed. With this in mind, we can simply create a new class, <code>Image</code>, adding two properties to the constructor in the form of these two pieces of data.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Image</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Long</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">uri</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Uri</span>
)</code></pre>

<p>With this class in place, we can now utilise this within our feature to model the media that is retrieved from the media store. As mentioned above, we won’t be defining state class for this feature - so this class will also be used to form the state for our composable, allowing the grid of images to be composed based on a collection of <code>Image</code> references.</p>

<h1>Creating the Gallery UI</h1>

<p>With the data classes now in place, we’re ready to move on and start implementing the composable UI for our Gallery. </p>

<figure><img src="one-1.png"/></figure>

<p>When we’re finished building this UI, we’re going to end up with something that looks like the following:</p>

<figure><img src="gallery.png"/></figure>

<p>This UI will give our users a screen that displays a grid of images from the device storage, allowing individual items to be selected and viewed in a full-screen format. Building this UI will allow us to work with several different features of compose, while also learning how to work with permission-based APIs in the compose world.</p>

<hr />

<h2>Setting up the entry point</h2>

<p>Before we can get start building our project, we’re going to need to add a couple of dependencies that we’re going to utilise. We’ll start here by adding these to the <code>build.gradle</code> file for our new project:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// provides access to the `ComponentActivity` class that can be used to compose UI components
</span>implementation &#39;androidx.activity<span class="syntax-all syntax-keyword">:</span>activity<span class="syntax-all syntax-keyword">-</span>compose<span class="syntax-all syntax-keyword">:</span><span class="syntax-all syntax-constant">1.4</span>.<span class="syntax-all syntax-constant">0</span>&#39;

<span class="syntax-all syntax-comment">// foundational classes from the Compose APIs
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.foundation:foundation:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// UI components from the Compose APIs
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Material Design components from the Compose APIs
</span>implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material:$compose_version&quot;</span>

<span class="syntax-all syntax-comment">// Provides us with utilities for requesting permissions
</span>implementation &#39;com.google.accompanist<span class="syntax-all syntax-keyword">:</span>accompanist<span class="syntax-all syntax-keyword">-</span>permissions<span class="syntax-all syntax-keyword">:</span><span class="syntax-all syntax-constant">0.22</span>.<span class="syntax-all syntax-constant">0</span><span class="syntax-all syntax-keyword">-</span>rc&#39;

<span class="syntax-all syntax-comment">// Provides image loading utilies
</span>implementation &#39;io.coil<span class="syntax-all syntax-keyword">-</span>kt<span class="syntax-all syntax-keyword">:</span>coil<span class="syntax-all syntax-keyword">-</span>compose<span class="syntax-all syntax-keyword">:</span><span class="syntax-all syntax-constant">1.4</span>.<span class="syntax-all syntax-constant">0</span>&#39;

<span class="syntax-all syntax-comment">// Tooling functionality for Composables, such as previews
</span>implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-tooling-preview:$compose_version&quot;</span>
debugImplementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-tooling:$compose_version&quot;</span></code></pre>

<p>With these added to our project, we’re now ready to start building out our UI. We’re going to start here by building the access point to our feature - this is how the Gallery feature will initially be composed within our user interface. To make this an argument-less access point, we’re going to start with a new composable function, <code>Gallery</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Gallery.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Gallery</span>() {
    
}</code></pre>

<p>While we won’t see anything visual just yet, we’ll want to compose this <code>Gallery</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Gallery</code> composable.</p>

<p>Within our <code>Gallery</code> we’re going to want to compose the content of our gallery feature. The <code>Gallery</code> itself is only going to be responsible for composing the root composable of our feature, this is so that we can keep all of the UI for our screen nested within our composable hierarchy - allowing the top-level composable to handle anything around media retrieval and system settings. For this purpose we’ll create a new composable function, <code>GalleryContent</code>, that will be used to house the different UI components that make up our feature.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GalleryContent.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {

}</code></pre>

<p>Next, we’ll hop on back over to the <code>Gallery</code> composable, composing the <code>GalleryContent</code> and enforcing it to fill the screen via the use of the <code>Modifier.fillMaxSize()</code> modifier. We’ll also wrap the composition of this using the <code>MaterialTheme</code> composable so that our composables adhere to any application theming that we apply.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Gallery</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
        )
    }
}</code></pre>

<p>With this in place, we now have a composable function that can be used to declare the UI for our feature.</p>

<hr />

<h2>Requesting storage permission</h2>

<p>Before we can start displaying media items within our UI, we need to request permission from the user so that we can read the media from the external storage of the device. For this permission management, we’re going to be utilising the <code>accompanist-permissions</code> package that we added to the dependencies for this module. This will allow us to check and request the required media access permission.</p>

<p>When it comes to this permission management, we’re going to be using the <code>PermissionState</code> interface which is provided by the accompanist package. This interface provides us access to various pieces of details around the permissions that have been granted to our application, as well as allowing us to launch the permissions request flow for specific permissions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">interface</span> <span class="syntax-all syntax-entity">PermissionState</span> {

    <span class="syntax-all syntax-keyword">val</span> permission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>

    <span class="syntax-all syntax-keyword">val</span> hasPermission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>

    <span class="syntax-all syntax-keyword">val</span> shouldShowRationale<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>

    <span class="syntax-all syntax-keyword">val</span> permissionRequested<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">launchPermissionRequest</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Unit</span>
}</code></pre>

<p>When it comes to media access, our <code>GalleryContent</code> composable is going to need access to this interface so that we can compose the UI based on the status of the required permissions. For example, if permission has not been granted to access the media on the device, then we aren’t going to want to compose the grid of images (as we won’t have access to load the images within the grid). To be able to perform the required checks, we’ll provide a reference to this interface as an argument to the <code>GalleryContent</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>
) {
    
}</code></pre>

<p>With this now specified as an argument for the <code>GalleryContent</code>, we’re going to need to provide this during composition. Within the implementation of the <code>Gallery</code> composable we’re going to need to utilise the <code>rememberPermissionState</code> composable function - this allows us to specify a permission that is required within our composables, along with remembering it across compositions. For this permission we’re going to use<code>READ_EXTERNAL_STORAGE</code> - this will grant us access to the external storage on the user’s device. When calling this <code>rememberPermissionState</code> function, we will be provided with a reference to a <code>permissionState</code>, which we can then provide when composing the <code>GalleryContent</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Gallery</span>() {
	
	<span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> rememberPermissionState(
    	<span class="syntax-all syntax-entity">Manifest</span>.<span class="syntax-all syntax-entity">permission</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-entity">READ_EXTERNAL_STORAGE</span>
	)

    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
			permissionState <span class="syntax-all syntax-keyword">=</span> permissionState
        )
    }
}</code></pre>

<p>We’ll also need to add this permission to our manifest file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">manifest</span> <span class="syntax-all syntax-entity">xmlns:android</span>=<span class="syntax-all syntax-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>
    <span class="syntax-all syntax-entity">package</span>=<span class="syntax-all syntax-string">&quot;academy.compose.gallery&quot;</span>&gt;

    &lt;<span class="syntax-all syntax-tag">uses-permission</span> <span class="syntax-all syntax-entity">android:name</span>=<span class="syntax-all syntax-string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;
	...
&lt;/<span class="syntax-all syntax-tag">manifest</span>&gt;</code></pre>

<p>Within our <code>GalleryContent</code> composable, we’re then going to want to check if the specified permission (defined by the provided <code>PermissionState</code>) needs to be requested. We’re going to do this by utilising the <code>permissionRequested</code> property - this will allow us to know if the permission has not previously been requested by our application, and it would be at this point that we want to request permission from the user.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>
) {
    <span class="syntax-all syntax-keyword">when</span> {
        <span class="syntax-all syntax-keyword">!</span>permissionState.permissionRequested <span class="syntax-all syntax-keyword">-&gt;</span> {
         		
        }
    }
}</code></pre>

<p>With this in place, we can now trigger the permission request by calling the <code>launchPermissionRequest()</code> function on the provided <code>PermissionState</code> reference.</p>

<pre><code class="code-highlighted code-kt">permissionState.launchPermissionRequest()</code></pre>

<p>We’ll then want to slot this into the <code>GalleryContent</code> composable so that the permission flow is triggered when required.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>
) {
    <span class="syntax-all syntax-keyword">when</span> {
        <span class="syntax-all syntax-keyword">!</span>permissionState.permissionRequested <span class="syntax-all syntax-keyword">-&gt;</span> {
        	permissionState.launchPermissionRequest()	
        }
    }
}</code></pre>

<p>When this point in the code is reached, the system permission request will be displayed to the user - allowing them to grant the application permission to access media on the device.</p>

<figure><img src="gallery-1.png"/></figure>

<hr />

<h2>Displaying Gallery Images</h2>

<figure><img src="gallery-2.png"/></figure>

<p>Now that we have access to the images that we want to display within our gallery, we’re going to need to create the composables that will be used to display them. </p>

<h3>Creating the Image item</h3>

<figure><img src="image.png"/></figure>

<p>We’ll start here by creating the composable which represents the selectable image within the gallery. This composable is going to take the <code>Uri</code> representing the image that is to be displayed, followed by loading it into an <code>Image</code> composable which will be displayed within the grid of images onscreen. We’ll create a new composable function, <code>GalleryImage</code>, that will take this required <code>Uri</code> as an argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryImage</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">uri</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Uri</span>
) {

}</code></pre>

<p>While we have this <code>Uri</code>, we don’t have anything for it to be loaded into. For this, we’re going to use the <code>Image</code> composable. There are several functions available for the <code>Image</code> composable - but because we’re using <strong>Coil</strong> to handle our image loading, we’re going to use the function that accepts an <code>ImagePainter</code> as an argument, as that is what our <strong>Coil</strong> usage will provide us with.</p>

<p>When composing our image, we’re going to start by assigning the provided <code>Modifier</code> to our <code>Image</code> composable, along with a <code>null</code> value for the <code>contentDescription</code> argument - this is because we won’t have access to anything that will be able to provide us with a corresponding description for each image.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryImage</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">uri</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Uri</span>
) {
    <span class="syntax-all syntax-entity">Image</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        painter <span class="syntax-all syntax-keyword">=</span> ...,
        contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
    )
}</code></pre>

<p>💡 Content descriptions help to improve the accessibility of visual elements. In the case of photos, content descriptions will usually be provided by where the image is sourced from, or generated using machine learning. We don’t have access to either of these solutions here, meaning a content description is not available for the images in our gallery.</p>

<p>The only thing that we need to provide now is the <code>painter</code> argument. For this, we’re going to utilise the <code>rememberImagePainter</code> composable function from the <strong>Coil</strong> library.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">inline</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">rememberImagePainter</span>(
    <span class="syntax-all syntax-parameter">data</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Any?</span>,
    <span class="syntax-all syntax-parameter">onExecute</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ExecuteCallback</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ExecuteCallback</span>.<span class="syntax-all syntax-entity">Default</span>,
    <span class="syntax-all syntax-parameter">builder</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ImageRequest</span>.<span class="syntax-all syntax-entity">Builder</span>.() <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> {}
)</code></pre>

<p>This allows us to provide the <code>Uri</code> of the image that we wish to load, resulting in the image being displayed inside of our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryImage</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">uri</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Uri</span>
) {
    <span class="syntax-all syntax-entity">Image</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        painter <span class="syntax-all syntax-keyword">=</span> rememberImagePainter(uri),
        contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
    )
}</code></pre>

<p>We can go a few steps further here though - for example, the image might not load right away, or might not even load at all (as in, fail to load). We can also use <strong>Coil</strong> to fade the image in once it has finished loading, as opposed to it being displayed suddenly on the screen. To achieve these desired behaviours, we’re going to utilise the <code>builder</code> block, as seen in the function definition defined above. This builder allows us to provide a collection of properties that will be used to control how the content of the composable is loaded.</p>

<p>To begin with, we’re going to apply a placeholder that will be loaded into the composable <strong>before</strong> our image media has been loaded. This provides a nice effect to our UI, as the user will see this placeholder as opposed to an empty space within the composable. We need to provide a resource to be used for this placeholder, so we’ll use the asset study to create a new resource using the vector asset wizard.</p>

<figure><img src="Screenshot%202022-02-15%20at%2015.39.29.png"/></figure>

<p>Here I’ve used the <code>ic_baseline_image_24</code> resource, providing this to the <code>placeholder</code> within the <code>builder</code> block.</p>

<pre><code class="code-highlighted code-kt">rememberImagePainter(
	<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">=</span> uri,
	builder <span class="syntax-all syntax-keyword">=</span> {
		placeholder(<span class="syntax-all syntax-entity">R</span>.drawable.ic_baseline_image_24)
	}
)</code></pre>

<p>At this point, we’ll now have a placeholder being displayed within our composable before the image is loaded. Now, when that image has been loaded, the placeholder will instantly switch to the loaded image. While this works, it doesn’t look as nice of a transition as it could. To improve this we’re going to utilise the <code>crossfade</code> function, providing <code>true</code> as the argument to depict that the crossfade effect should be applied when the image is being loaded.</p>

<pre><code class="code-highlighted code-kt">rememberImagePainter(
	<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">=</span> uri,
	builder <span class="syntax-all syntax-keyword">=</span> {
		placeholder(<span class="syntax-all syntax-entity">R</span>.drawable.ic_baseline_image_24)
		crossfade(<span class="syntax-all syntax-constant">true</span>)
	}
)</code></pre>

<p>At this point, we now have a placeholder for while our image is loading, along with the crossfade effect applied when the transitioning between the placeholder and requested image occurs. However, this is all assuming that the image succeeds to load - if something goes wrong, then the placeholder will remain in place and the user will be unaware of what has happened. To improve this, we’re going to utilise the <code>error</code> function within the builder block - this allows us to provide a resource to be displayed when this scenario does occur.</p>

<p>We’ll again need to reference an image resource, so we’ll again create a new one using the vector asset wizard (I’ve used the <code>ic_baseline_error_24</code> resource). We’ll then provide this to the <code>error</code> function as the resource to be used when the image fails to load.</p>

<pre><code class="code-highlighted code-kt">rememberImagePainter(
	<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">=</span> uri,
	builder <span class="syntax-all syntax-keyword">=</span> {
		placeholder(<span class="syntax-all syntax-entity">R</span>.drawable.ic_baseline_image_24)
		crossfade(<span class="syntax-all syntax-constant">true</span>)
		error(<span class="syntax-all syntax-entity">R</span>.drawable.ic_baseline_error_24)
	}
)</code></pre>

<p>With this configured, we can slot this into our <code>Image</code> composable usage, allowing us to now experience the defined behaviour while the image data of the composable is loaded into view.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryImage</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">uri</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Uri</span>,
    <span class="syntax-all syntax-parameter">scaleType</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ContentScale</span>
) {
    <span class="syntax-all syntax-entity">Image</span>(
        painter <span class="syntax-all syntax-keyword">=</span> rememberImagePainter(
            <span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">=</span> uri,
            builder <span class="syntax-all syntax-keyword">=</span> {
                crossfade(<span class="syntax-all syntax-constant">true</span>)
                placeholder(<span class="syntax-all syntax-entity">R</span>.drawable.ic_baseline_image_24)
                error(<span class="syntax-all syntax-entity">R</span>.drawable.ic_baseline_error_24)
            }
        ),
        contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
        contentScale <span class="syntax-all syntax-keyword">=</span> scaleType,
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    )
}</code></pre>

<p>In the composable preview, you’ll currently only be able to see the placeholder resources - but this allows us to preview how our composable is currently being represented. </p>

<figure><img src="gallery_image.png"/></figure>

<hr />

<h2>Displaying a Grid of Images</h2>

<figure><img src="one-2.png"/></figure>

<p>Now that we have a composable that can be used to represent an individual image within our gallery, we’re going to want to compose each of the individual images within a higher level gallery composable. We’re going to be displaying these images in a grid format, so we’ll start by creating a new composable function, <code>ImageGallery</code>. Alongside the default modifier, this is also going to receive a list of <code>Image</code> references as an argument which will be used to compose the images for selection.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ImageGallery.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">images</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
)</code></pre>

<p>To display the grid of images, we’re going to utilise the <code>LazyVerticalGrid</code> composable which will only compose its children as they are required - making it much more efficient than composing everything at the same time, especially when items may not even be visible to the user. When composing the <code>LazyVerticalGrid</code> we’ll pass the modifier that was provided to our <code>ImageGallery</code> composable, along with the required <code>cells</code> argument. This needs to be provided in the form of the <code>GridCells</code> type, which allows us to define how many columns should be applied to our grid. We’re going to use the <code>Fixed</code> type in the form of 2 columns.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">images</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
    ) {
            
    }
}</code></pre>

<p>💡 Alongside the Fixed type, the Adaptive type allows us to define a minimum sizing for a column - meaning that we can create more adaptive layouts by allowing our grid columns to adjust based on the available space.</p>

<p>When it comes to the items to be composed within our grid, these need to be composed using the <code>items</code> function provided through the <code>LazyListScope</code> - this is so that a unique key can be provided for each item being composed, allowing the <code>LazyVerticalGrid</code> to correctly manage the current scroll position on the screen. </p>

<p>With that said, we’ll go ahead and utilise the <code>items</code> function - this allows us to provide a list that we wish to compose items from. Along with this list of items being provided, the <code>itemContent</code> block will also be called - this is where we will declare the composition for each item that is being composed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">images</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
    ) {
        items(images) { image <span class="syntax-all syntax-keyword">-&gt;</span>
             
        }
    }
}</code></pre>

<p>When it comes to the composition of each image item within our grid, we’re going to utilise the <code>GalleryImage</code> composable that we previously defined. For this we need to provide 3 different arguments:</p>

<ul>
	<li><strong>modifier</strong>: the constraints to be applied to the composable</li>
	<li><strong>uri</strong>: the <code>uri</code> to load the image from</li>
	<li><strong>scaleType</strong>: the scaling to be applied to the loaded image</li>
</ul>

<p>For the modifier, we’re going to want to provide a fixed size, which we’ll assign via the <code>height</code> modifier at a size of <code>150.dp</code>. Alongside this, we’ll use the <code>fillMaxWidth</code> modifier to fill up all of the available width of the column the image is in.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">GalleryImage</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.height(<span class="syntax-all syntax-constant">150</span>.dp)
		.fillMaxWidth(),
	uri <span class="syntax-all syntax-keyword">=</span> ...,
	scaleType <span class="syntax-all syntax-keyword">=</span> ...
)</code></pre>

<p>💡 Using a fixed height here is OK because we are using a vertically scrolling grid. This means that while we are using a fixed height, they’ll always be available space to view the heights of each image. This wouldn’t quite work the same for a fixed width in this case, as we are using a 2 column grid - so a fixed width would either result in the image width being too small, or extending outside of the visible area of the screen.</p>

<p>The only thing now is that realistically, our images are not going to match this sizing that we have applied to our composable. This results in an odd composition of our images, causing the images to either be too large or small.</p>

<figure><img src="no_crop.png"/></figure>

<p>For this reason, we’re going to utilise the <code>scaleType</code> argument, providing a value of <code>ContentScale.Crop</code> - allowing the loaded image to be cropped to the size constraints of the composable that it is being loaded into.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">GalleryImage</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.height(<span class="syntax-all syntax-constant">150</span>.dp)
		.fillMaxWidth(),
	scaleType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentScale</span>.<span class="syntax-all syntax-entity">Crop</span>,
	uri <span class="syntax-all syntax-keyword">=</span> ...
)</code></pre>

<p>Finally, we need to provide the <code>uri</code> for the image that we wish to load. We’ll directly pass the <code>uri</code> property from the current <code>Image</code> item that we are composing for.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">GalleryImage</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.height(<span class="syntax-all syntax-constant">150</span>.dp)
		.fillMaxWidth(),
	scaleType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentScale</span>.<span class="syntax-all syntax-entity">Crop</span>,
	uri <span class="syntax-all syntax-keyword">=</span> image.uri,
)</code></pre>

<p>With this in place, we now have a <code>GalleryImage</code> being composed for each of the <code>Image</code> items that are within the <code>images</code> list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">images</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
    ) {
        items(retrieveMedia) {
            <span class="syntax-all syntax-entity">GalleryImage</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .height(<span class="syntax-all syntax-constant">150</span>.dp)
                    .fillMaxWidth(),
                uri <span class="syntax-all syntax-keyword">=</span> it.uri,
                scaleType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentScale</span>.<span class="syntax-all syntax-entity">Crop</span>
            )
        }
    }
}</code></pre>

<p>At this point, we’ll be able to preview a minimal grid of image composables being displayed. </p>

<figure><img src="gallery-3.png"/></figure>

<hr />

<h3>Allowing image selection</h3>

<figure><img src="selection.png"/></figure>

<p>Even though our grid of images is showing, we’re yet to implement the selection of images. When an image is selected we want to display it full screen, allowing the user to then return to the grid of images at any time. For this, we’re going to need to implement a couple of changes to our <code>ImageGallery</code> composable:</p>

<ul>
	<li>We’re going to need to allow an image to be clickable, followed by keeping track of what image has been selected via this click action</li>
	<li>When there is a selected image, we’ll want to display a fullscreen image composable over the top of the grid</li>
	<li>When this fullscreen image is clicked (or back is pressed), then the image grid will be returned to</li>
</ul>

<p>We’ll start by adding support for selecting an image from the gallery. This will involve applying the <code>clickable</code> modifier to our <code>GalleryImage</code> composable, enabling click interactions on this composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ImageGallery.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">images</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
    ) {
        items(images) { image <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-entity">GalleryImage</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .clickable {

                    }
                    .height(<span class="syntax-all syntax-constant">150</span>.dp)
                    .fillMaxWidth(),
                uri <span class="syntax-all syntax-keyword">=</span> it.uri,
                scaleType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentScale</span>.<span class="syntax-all syntax-entity">Crop</span>
            )
        }
    }
}</code></pre>

<p>However, at this point, the click interaction isn’t doing anything. So that we know an image has been selected (and that one has been selected), we’re going to add a piece of internal state to our composable. While this could be a piece of global state, we haven’t configured it for this feature - so we’re going to keep it as an internal piece of state within this composable for now. We’ll call this piece of state <code>selectedImage</code>, wrapping it in <code>remember</code> so that the value is persisted across recompositions. The type for this state is going to be <code>Uri</code> and also be <code>nullable</code>, this is so that when an image is not currently selected then the state can be reflected as <code>null</code>. We’ll next implement the body of the <code>clickable</code> modifier, so that the value of the <code>selectedImage</code> is updated when the composable is clicked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ImageGallery.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">images</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-keyword">var</span> selectedImage by remember { 
		mutableStateOf&lt;<span class="syntax-all syntax-entity">Uri?</span>&gt;(<span class="syntax-all syntax-constant">null</span>) 
	}
    <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
    ) {
        items(images) { image <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-entity">GalleryImage</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .clickable {
                        selectedImage <span class="syntax-all syntax-keyword">=</span> image.uri
                    }
                    .height(<span class="syntax-all syntax-constant">150</span>.dp)
                    .fillMaxWidth(),
                uri <span class="syntax-all syntax-keyword">=</span> it.uri,
                scaleType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentScale</span>.<span class="syntax-all syntax-entity">Crop</span>
            )
        }
    }
}</code></pre>

<p>When there is an image that is selected, we’re going to want to display this image over the top of the existing grid of images in an immersive fashion. To make this possible we’re going to wrap the existing <code>LazyVerticalGrid</code> in a <code>Box</code> composable, which will allow us to stack composables on the z-axis (as in, on top of one another). This means that we can create a new composable to be displayed over the existing grid, which will allow our selected image to be presented to the user.</p>

<p>We’ll start here by defining this <code>Box</code> composable, using the <code>contentAlignment</code> argument to align its children in the center, followed by placing the existing <code>LazyVerticalGrid</code> within its <code>content</code> block.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">images</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-keyword">var</span> selectedImage by remember { 
		mutableStateOf&lt;<span class="syntax-all syntax-entity">Uri?</span>&gt;(<span class="syntax-all syntax-constant">null</span>) 
	}
    <span class="syntax-all syntax-entity">Box</span>(
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
        ) {
            items(images) { image <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">GalleryImage</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                        .clickable {
                            selectedImage <span class="syntax-all syntax-keyword">=</span> it.uri
                        }
                        .height(<span class="syntax-all syntax-constant">150</span>.dp)
                        .fillMaxWidth(),
                    uri <span class="syntax-all syntax-keyword">=</span> it.uri,
                    scaleType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentScale</span>.<span class="syntax-all syntax-entity">Crop</span>
                )
            }
        }
    }
}</code></pre>

<p>Now that this <code>Box</code> is in place, we can start to think about the composable that will be displayed when there is an image that has been selected. For this we’re going to create a new composable function, <code>GalleryPreview</code>. This is going to take a nullable <code>Uri</code> that represents the currently selected image.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryPreview</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">selectedImage</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Uri?</span>
) {

}</code></pre>

<p>When it comes to displaying this image, we’re going to compose it inside of a <code>Box</code>. Because our image won’t necessarily fill the entire space inside of the box, we’re going to chain the <code>background</code> modifier onto the modifier that is provided to the function. We’ll apply the <code>Color.Black</code> value to this, meaning that any space our image does not fill will appear as black space.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryPreview</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">selectedImage</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Uri?</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
    ) {
        
    }
}</code></pre>

<p>We’re next going to want to compose the selected image so that it is visible within the preview area. Here we’ll compose our <code>GalleryImage</code>, providing the required values for the function arguments. For the <code>uri</code> we’ll simply pass the <code>image</code> argument that is provided to the <code>GalleryPreview</code> composable function. When it comes to the constraints of the composable, we’re going to pair the use of the <code>fillMaxWidth</code> modifier with <code>ContentScale.None</code> for the <code>scaleType</code> argument. Using <code>ContentScale.None</code> will mean that there will be no scaling applied to the image (compared to the cropping that was previously being applied), so in this case, we want to enforce the full width of the preview area is used. This is because the height of the image will then fill the required area and the original aspect ratio of the image will be retained.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryPreview</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">image</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Uri</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .background(<span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>)
    ) {
        <span class="syntax-all syntax-entity">GalleryImage</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            uri <span class="syntax-all syntax-keyword">=</span> image,
            scaleType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentScale</span>.<span class="syntax-all syntax-entity">None</span>
        )
    }
}</code></pre>

<p>At this point, we have a composable that can be used to display a preview of an image - all that’s left to do now is compose this within our <code>ImageGallery</code>. We’ll only want to compose this when the <code>selectedImage</code> does not represent a null value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">retrieveMedia</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-keyword">var</span> selectedImage by remember { 
		mutableStateOf&lt;<span class="syntax-all syntax-entity">Uri?</span>&gt;(<span class="syntax-all syntax-constant">null</span>) 
	}
    <span class="syntax-all syntax-entity">Box</span>(
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
        ) {
            ...
        }
		selected<span class="syntax-all syntax-entity">Image?</span>.<span class="syntax-all syntax-constant">let</span> {
        	<span class="syntax-all syntax-entity">GalleryPreview</span>(
            	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
            	selectedImage <span class="syntax-all syntax-keyword">=</span> selectedImage
        	)
		}
    }
}</code></pre>

<p>With this in place, our gallery preview will now be composed when there is a <code>Uri</code> value reflected within the <code>selectedImage</code> state. However, once the composition has taken place, there’s no way for the user to clear that state and remove the preview from view. For the first step here, we’re going to utilise the <code>clickable</code> modifier - this will allow us to clear the <code>selectedImage</code> when the composable is clicked. We can chain this onto the existing <code>fillMaxSize</code> modifier, setting the <code>selectedImage</code> state value as <code>null</code> within the body of the click action.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">retrieveMedia</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-keyword">var</span> selectedImage by remember { 
		mutableStateOf&lt;<span class="syntax-all syntax-entity">Uri?</span>&gt;(<span class="syntax-all syntax-constant">null</span>) 
	}
    <span class="syntax-all syntax-entity">Box</span>(
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
        ) {
            ...
        }
		selected<span class="syntax-all syntax-entity">Image?</span>.<span class="syntax-all syntax-constant">let</span> {
        	<span class="syntax-all syntax-entity">GalleryPreview</span>(
            	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
					.clickable {
						selectedImage <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
					},
            	selectedImage <span class="syntax-all syntax-keyword">=</span> selectedImage
        	)
		}
    }
}</code></pre>

<p>Now when this click event is triggered, the <code>selectedImage</code> state will be cleared, triggering a recomposition that will cause the <code>GalleryPreview</code> to no longer be displayed to the user - taking them back to the grid of images for selection.</p>

<figure><img src="preview.png"/></figure>

<p>One issue with this click modifier is that for users utilising accessibility features, the click functionality here will not be very accessible. While the click action is there, the screen reader has no clue what that click action does. To improve this we’re going to add a click label - that way the screen reader can communicate the intention of our click action to the user. Before we add this label we’re going to need to add a new string resources to our project for notifying the user that clicking an image will enlarge it on screen.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_enlarge_image&quot;</span>&gt;
	Enlarge Image
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’ll then need to retrieve the string value of the resource using the <code>stringResource</code> function. We’ll assign this to a variable reference, as the <code>onClickLabel</code> can only be provided as a string (and the <code>stringResource</code> function is a composable function).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> enlargeImageLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_enlarge_image)
<span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_IMAGE_GRID</span>),
	cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
)
...</code></pre>

<p>We can then use this to apply a value to the <code>onClickLabel</code> of the clickable modifier. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">GalleryImage</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.clickable(
			onClickLabel <span class="syntax-all syntax-keyword">=</span> enlargeImageLabel
		) {
        	selectedImage <span class="syntax-all syntax-keyword">=</span> it.uri
		}
	...
)</code></pre>

<p>As we can see, this isn’t a required property of the clickable modifier, but for minimal effort, we can increase the accessibility of our composable for screen readers.</p>

<h3>Animating the image display</h3>

<p>At the moment you may notice that the image preview is removed suddenly from composition. While this is working as expected, we can go one step further here to improve the transition that occurs during this recomposition. We can utilise the <code>AnimatedVisibility</code> composable that will allow us to animate the visibility of the composable, which we can do so based on the state of the <code>selectedImage</code> value.</p>

<figure><img src="anim.png"/></figure>

<p>We can define the use of this <code>AnimatedVisibility</code> composable, instructing it to fill the maximum available size. We’ll also assign the <code>visibility</code> of the composable based on whether there is currently a non-null value assigned for the <code>selectedImage</code> state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">AnimatedVisibility</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
    visible <span class="syntax-all syntax-keyword">=</span> selectedImage <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>While this allows us to animate the visibility of the composable, we can improve the transition here by modifying the transitions that are used for the <code>enter</code> and <code>exit</code> values. Here we’ll utilise both the <code>fadeIn</code> and <code>fadeOut</code> transitions, which will use a fade for each transition instead of instantly showing/hiding the composable during the transition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">AnimatedVisibility</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
    visible <span class="syntax-all syntax-keyword">=</span> selectedImage <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>,
    enter <span class="syntax-all syntax-keyword">=</span> fadeIn(),
    exit <span class="syntax-all syntax-keyword">=</span> fadeOut()
)</code></pre>

<p>With this in place, we now have the <code>AnimatedVisibility</code> composable configured to animate any contained content in and out of composition. We can now slot this into our <code>ImageGallery</code> composable, placing the existing <code>GalleryPreview</code> composable as the content of the <code>AnimatedVisibility</code> composable. This means that now when the <code>selectedImage</code> state is changed, the contents of the <code>AnimatedVisibility</code> composable will be animated in and out of visibility.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ImageGallery</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">images</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;
) {
    <span class="syntax-all syntax-keyword">var</span> selectedImage by remember { 
		mutableStateOf&lt;<span class="syntax-all syntax-entity">Uri?</span>&gt;(<span class="syntax-all syntax-constant">null</span>) 
	}
    <span class="syntax-all syntax-entity">Box</span>(
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
        ) {
            ...
        }
        <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            visible <span class="syntax-all syntax-keyword">=</span> selectedImage <span class="syntax-all syntax-keyword">!=</span> <span class="syntax-all syntax-constant">null</span>,
            enter <span class="syntax-all syntax-keyword">=</span> fadeIn(),
            exit <span class="syntax-all syntax-keyword">=</span> fadeOut()
        ) {
			selected<span class="syntax-all syntax-entity">Image?</span>.<span class="syntax-all syntax-constant">let</span> {
            	<span class="syntax-all syntax-entity">GalleryPreview</span>(
                	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
						.clickable {
							selectedImage <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
						},
                	selectedImage <span class="syntax-all syntax-keyword">=</span> selectedImage
            	)
			}
        }
    }
}</code></pre>

<hr />

<h2>Retrieving media</h2>

<p>Now that we have the composables in place to display the images on the device, we’re going to need to implement the logic that will retrieve the images from the device media store. We’re going to delegate this to a separate function, which we’ll call <code>retrieveMedia</code>. This function will handle the retrieval of media for us, returning a list of <code>Image</code> references that are generated from the media store results.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">retrieveMedia</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt; {

}</code></pre>

<p>To be able to query the media store, we’re going to need to define the information that we want to query for. For our usage, we’re only going to query for a few pieces of information - the ID of the media item and the display name. This will give us most of the data that we need to construct an <code>Image</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">retrieveMedia</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt; {
	<span class="syntax-all syntax-keyword">val</span> projection <span class="syntax-all syntax-keyword">=</span> arrayOf(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>._ID,
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">DISPLAY_NAME</span>
    )
}</code></pre>

<p>Next, we’re going to want to use this array to query the media store. To do this we’re going to need access to a <code>Context</code> reference, which we’ll add as an argument for our function. With this context in place, we can now use this to access the content resolver and perform queries against it. As previously mentioned, we’re only going to be querying for media information from the external content source, so we’ll utilise the <code>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</code> value to do so. The only other thing we need to pass here is the previously defined projection to specify the information that we want to query for. We can pass <code>null</code> values for the other arguments as we do not need these to perform our query.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">retrieveMedia</span>(<span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt; {
    <span class="syntax-all syntax-keyword">val</span> projection <span class="syntax-all syntax-keyword">=</span> arrayOf(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>._ID,
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">DISPLAY_NAME</span>
    )
    
    context.contentResolver.query(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">EXTERNAL_CONTENT_URI</span>,
        projection, <span class="syntax-all syntax-constant">null</span>, <span class="syntax-all syntax-constant">null</span>, <span class="syntax-all syntax-constant">null</span>
    )
    <span class="syntax-all syntax-keyword">return</span> images
}</code></pre>

<p>Now that we have our query in place, we’re going to want to massage the result that we get back. From this query, we’re going to get back a <code>Cursor</code> reference that we can use to retrieve information regarding the media entries. To get this information from the <code>Cursor</code>, we’re going to need to access the columns that contain the corresponding data. And to be able to do this, we need to know the index of each of those columns, so we’re going to start by getting the column index for each projection that we defined within our projection array.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">retrieveMedia</span>(<span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt; {
    <span class="syntax-all syntax-keyword">val</span> projection <span class="syntax-all syntax-keyword">=</span> arrayOf(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>._ID,
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">DISPLAY_NAME</span>
    )

    context.contentResolver.query(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">EXTERNAL_CONTENT_URI</span>,
        projection, <span class="syntax-all syntax-constant">null</span>, <span class="syntax-all syntax-constant">null</span>, <span class="syntax-all syntax-constant">null</span>
    )?.use { cursor <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-keyword">val</span> idColumn <span class="syntax-all syntax-keyword">=</span> cursor.getColumnIndexOrThrow(
			<span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>._ID)
        <span class="syntax-all syntax-keyword">val</span> nameColumn <span class="syntax-all syntax-keyword">=</span> cursor.getColumnIndexOrThrow(
			<span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">DISPLAY_NAME</span>)
    }
}</code></pre>

<p>With these indexes in place, we can now use these to retrieve the required information from each of the entries that are available from the <code>Cursor</code> reference. Using the <code>moveToNext()</code> function on our <code>Cursor</code> reference, we can move through the cursor entries that represent the different media items that have come back from our query. Within this <code>while</code> operation we’ll use the <code>Cursor</code>, along with each of the column indexes that we just retrieved, allowing us to fetch both the <code>id</code> and <code>name</code> for the current media item from our <code>Cursor</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">retrieveMedia</span>(<span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt; {
    <span class="syntax-all syntax-keyword">val</span> projection <span class="syntax-all syntax-keyword">=</span> arrayOf(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>._ID,
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">DISPLAY_NAME</span>
    )

    context.contentResolver.query(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">EXTERNAL_CONTENT_URI</span>,
        projection, <span class="syntax-all syntax-constant">null</span>, <span class="syntax-all syntax-constant">null</span>, <span class="syntax-all syntax-constant">null</span>
    )?.use { cursor <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-keyword">val</span> idColumn <span class="syntax-all syntax-keyword">=</span> cursor.getColumnIndexOrThrow(
			<span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>._ID)
        <span class="syntax-all syntax-keyword">val</span> nameColumn <span class="syntax-all syntax-keyword">=</span> cursor.getColumnIndexOrThrow(
			<span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">DISPLAY_NAME</span>)

        <span class="syntax-all syntax-keyword">while</span> (cursor.moveToNext()) {
            <span class="syntax-all syntax-keyword">val</span> id <span class="syntax-all syntax-keyword">=</span> cursor.getLong(idColumn)
            <span class="syntax-all syntax-keyword">val</span> name <span class="syntax-all syntax-keyword">=</span> cursor.getString(nameColumn)

        }
    }
    <span class="syntax-all syntax-keyword">return</span> images
}</code></pre>

<p>Now that we have this <code>id</code> and <code>name</code> for the current cursor entry, we can go ahead and create the <code>Uri</code> reference for the media store entry using the retrieved <code>id</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> contentUri <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentUris</span>.withAppendedId(
	<span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">EXTERNAL_CONTENT_URI</span>, id)</code></pre>

<p>Finally, we can now use this generated <code>Uri</code> to instantiate an <code>Image</code> reference. Here we’ll create a new list reference that will be used to hold each of these generated <code>Image</code> references, followed by creating a new <code>Image</code> reference for each <code>Cursor</code> entry and adding it to this list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">retrieveMedia</span>(<span class="syntax-all syntax-parameter">context</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Context</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt; {
    <span class="syntax-all syntax-keyword">val</span> projection <span class="syntax-all syntax-keyword">=</span> arrayOf(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>._ID,
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">DISPLAY_NAME</span>
    )
    <span class="syntax-all syntax-keyword">val</span> images <span class="syntax-all syntax-keyword">=</span> mutableListOf&lt;<span class="syntax-all syntax-entity">Image</span>&gt;()

    context.contentResolver.query(
        <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">EXTERNAL_CONTENT_URI</span>,
        projection, <span class="syntax-all syntax-constant">null</span>, <span class="syntax-all syntax-constant">null</span>, <span class="syntax-all syntax-constant">null</span>
    )?.use { cursor <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-keyword">val</span> idColumn <span class="syntax-all syntax-keyword">=</span> cursor.getColumnIndexOrThrow(
			<span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>._ID)
        <span class="syntax-all syntax-keyword">val</span> nameColumn <span class="syntax-all syntax-keyword">=</span> cursor.getColumnIndexOrThrow(
			<span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">DISPLAY_NAME</span>)

        <span class="syntax-all syntax-keyword">while</span> (cursor.moveToNext()) {
            <span class="syntax-all syntax-keyword">val</span> id <span class="syntax-all syntax-keyword">=</span> cursor.getLong(idColumn)
            <span class="syntax-all syntax-keyword">val</span> name <span class="syntax-all syntax-keyword">=</span> cursor.getString(nameColumn)

            <span class="syntax-all syntax-keyword">val</span> contentUri <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentUris</span>.withAppendedId(
                <span class="syntax-all syntax-entity">MediaStore</span>.<span class="syntax-all syntax-entity">Images</span>.<span class="syntax-all syntax-entity">Media</span>.<span class="syntax-all syntax-entity">EXTERNAL_CONTENT_URI</span>,
                id
            )
            images.add(<span class="syntax-all syntax-entity">Image</span>(id, contentUri, name))
        }
    }
    <span class="syntax-all syntax-keyword">return</span> images
}</code></pre>

<p>Once all of our <code>Cursor</code> logic has been executed, we simply return this list of generated <code>Image</code> references from the function - these will then be used by the calling point to generate the grid of images.</p>

<hr />

<h2>Loading Media</h2>

<p>Now that we have the logic in place to retrieve the images from the media store, we’re going to want to add support for the triggering of this function - allowing media to be loaded and composed within our UI. We’re going to start here by modifying the <code>GalleryContent</code> composable so that a list of <code>Image</code> references can be provided to the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">media</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>
)</code></pre>

<p>Now, when this <code>media</code> reference is null, it will mean that media has not yet been provided to the composable function - signifying that the composable is in a loading state. So in this scenario, we’re going to want to portray this to the user by displaying a progress indicator.</p>

<figure><img src="loading.png"/></figure>

<p>Here we’ll utilise the <code>CircularProgressIndicator</code> composable, wrapping this inside of a <code>Box</code> so that the indicator can be placed in the center.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">media</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>
) {
    <span class="syntax-all syntax-keyword">when</span> {
        permissionState.hasPermission <span class="syntax-all syntax-keyword">-&gt;</span> {
            <span class="syntax-all syntax-keyword">if</span> (media <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">null</span>) {
                <span class="syntax-all syntax-entity">Box</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> modifier,
                    contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
                ) {
                    <span class="syntax-all syntax-entity">CircularProgressIndicator</span>()
                }
            }
        }
        ...
    }
}</code></pre>

<p>Now, if the provided media is in fact <code>null</code> then the progress indicator will be composed. On the other hand, we’ll also want to handle the case where there is in fact media that is provided to the <code>GalleryContent</code> composable. We previously built out the <code>ImageGallery</code> composable, so we’re going to compose this here to allow the display of our image grid. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">media</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>
) {
    <span class="syntax-all syntax-keyword">when</span> {
        permissionState.hasPermission <span class="syntax-all syntax-keyword">-&gt;</span> {
            <span class="syntax-all syntax-keyword">if</span> (media <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">null</span>) {
                <span class="syntax-all syntax-entity">Box</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> modifier,
                    contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
                ) {
                    <span class="syntax-all syntax-entity">CircularProgressIndicator</span>()
                }
            } <span class="syntax-all syntax-keyword">else</span> {
                <span class="syntax-all syntax-entity">ImageGallery</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> modifier,
                    retrieveMedia <span class="syntax-all syntax-keyword">=</span> media
                )
            }
        }
        ...
    }
}</code></pre>

<p>Now that our <code>GalleryContent</code> composable supports the display of media items, we’re going to need to provide these media items to the composable function. We’re currently composing this inside of the <code>Gallery</code> composable, so we’re going to hop over to that composable definition so that we can provide the required media items. These media items are going to need to be held in some form of state reference, so we’ll declare a new piece of mutable state in the form of a nullable <code>Image</code> list. We’ll also wrap this in <code>remember</code> so that the state is remembered across compositions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Gallery</span>() {
	<span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> rememberPermissionState(
        <span class="syntax-all syntax-entity">Manifest</span>.<span class="syntax-all syntax-entity">permission</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-entity">READ_EXTERNAL_STORAGE</span>
    )
    <span class="syntax-all syntax-keyword">var</span> retrievedMedia by remember 	
		{ mutableStateOf&lt;<span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;?&gt;(<span class="syntax-all syntax-constant">null</span>) }
    ...
}</code></pre>

<p>With this state in place, we’ll now want to manipulate it so that the media for our composables can be set, allowing recomposition of the image grid once that has occurred. To be able to set this state, we’ll need to load the media using the previously defined <code>retrieveMedia</code> function. When it comes to loading this media, there are going to be several constraints:</p>

<ul>
	<li>We’ll only want to attempt to load this media on the initial composition, otherwise the media will be loaded every single time a composition occurs</li>
	<li>We’ll only want to attempt the loading of media if we have permission to access the media from the user’s device</li>
	<li>We’ll need to perform the loading of media on the correct threads, otherwise we would end up blocking the UI thread</li>
	<li>Once the media has been loaded, we’ll need to assign it to the state reference so that the image grid can be recomposed</li>
</ul>

<p>Starting with the first point, for this we can utilise the <code>LaunchedEffect</code> side-effect, allowing us to trigger some logic at the time of composition, conditionally.</p>

<p>When <code>LaunchedEffect</code> enters the composition, it will execute the <code>block</code> implementation that is provided to it. However, we only want to run this when the <code>hasPermission</code> state has changed - otherwise, we might be executing this media loading task when it doesn’t need to be. For this, the <code>LaunchedEffect</code> also takes a <code>key</code> - this allows us to provide a value that will be used to determine if the side-effect should be run, which will only be the case when the <code>key</code> value changes. For this, we can declare the <code>LaunchedEffect</code> side-effect, passing the <code>hasPermission</code> reference for the <code>key</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Gallery</span>() {
    <span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	<span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> rememberPermissionState(
        <span class="syntax-all syntax-entity">Manifest</span>.<span class="syntax-all syntax-entity">permission</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-entity">READ_EXTERNAL_STORAGE</span>
    )
    <span class="syntax-all syntax-keyword">var</span> retrievedMedia by remember 	
		{ mutableStateOf&lt;<span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;?&gt;(<span class="syntax-all syntax-constant">null</span>) }
    
    <span class="syntax-all syntax-entity">LaunchedEffect</span>(
		key1 <span class="syntax-all syntax-keyword">=</span> permissionState.hasPermission
	) {
        
    }
    ...
}</code></pre>

<p>Now, if we have permission to access the users media then we’re going to want to trigger our <code>retrieveMedia</code> function. This is a suspending function, so we’re going to need to execute this using a coroutine scope that won’t block the UI thread. We’ll define a new coroutine scope using <code>rememberCoroutineScope()</code>, followed by using this to <code>launch</code> the coroutine within the specified context. Here we use the <code>IO</code> dispatcher to keep the operation off of the main thread.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Gallery</span>() {
	<span class="syntax-all syntax-keyword">val</span> scope <span class="syntax-all syntax-keyword">=</span> rememberCoroutineScope()
    <span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	<span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> rememberPermissionState(
        <span class="syntax-all syntax-entity">Manifest</span>.<span class="syntax-all syntax-entity">permission</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-entity">READ_EXTERNAL_STORAGE</span>
    )
    <span class="syntax-all syntax-keyword">var</span> retrievedMedia by remember 	
		{ mutableStateOf&lt;<span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;?&gt;(<span class="syntax-all syntax-constant">null</span>) }
    
    <span class="syntax-all syntax-entity">LaunchedEffect</span>(
		key1 <span class="syntax-all syntax-keyword">=</span> permissionState.hasPermission
	) {
        <span class="syntax-all syntax-keyword">if</span> (permissionState.hasPermission) {
            scope.launch(<span class="syntax-all syntax-entity">Dispatchers</span>.<span class="syntax-all syntax-entity">IO</span>) {
                <span class="syntax-all syntax-keyword">val</span> retrieveMedia <span class="syntax-all syntax-keyword">=</span> retrieveMedia(context)
                
            }
        }
    }
    ...
}</code></pre>

<p>At this point, we’ve loaded the media and assigned it to a variable reference, all of which is happening off of the UI thread. All that’s left to do now is hop on back over to the <code>Main</code> thread and assigned this media to our <code>retrievedMedia</code> state reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Gallery</span>() {
	...
    <span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	<span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> rememberPermissionState(
        <span class="syntax-all syntax-entity">Manifest</span>.<span class="syntax-all syntax-entity">permission</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-entity">READ_EXTERNAL_STORAGE</span>
    )
    <span class="syntax-all syntax-keyword">var</span> retrievedMedia by remember 	
		{ mutableStateOf&lt;<span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;?&gt;(<span class="syntax-all syntax-constant">null</span>) }
    
    <span class="syntax-all syntax-entity">LaunchedEffect</span>(
		key1 <span class="syntax-all syntax-keyword">=</span> permissionState.hasPermission
	) {
        <span class="syntax-all syntax-keyword">if</span> (permissionState.hasPermission) {
            scope.launch(<span class="syntax-all syntax-entity">Dispatchers</span>.<span class="syntax-all syntax-entity">IO</span>) {
                <span class="syntax-all syntax-keyword">val</span> retrieveMedia <span class="syntax-all syntax-keyword">=</span> retrieveMedia(context)
                withContext(<span class="syntax-all syntax-entity">Dispatchers</span>.<span class="syntax-all syntax-entity">Main</span>) {
                    retrievedMedia <span class="syntax-all syntax-keyword">=</span> retrieveMedia
                }
            }
        }
    }
    ...
}</code></pre>

<p>With the above in place, we’re now retrieving the required media from the media store and assigning this to a state reference. When this state change occurs, recomposition will occur for the <code>GalleryContent</code> and the media will be composed within our UI.</p>

<hr />

<h2>Explaining permissions</h2>

<figure><img src="explain.png"/></figure>

<p>Currently, in our composable permission flow, we are immediately requesting permission from the user. The issue with this is that it’s not clear as to <strong>why</strong> we might be requesting such permission. So instead of doing this upfront, we’re going to compose some UI that explains to the user why we need this permission - followed by giving them the option to grant the permission to our application. We’ll start here by creating a new composable function that will be used to compose this UI, <code>PermissionExplainer</code>. Because this will be used to trigger the permission request, we’ll also add a lambda argument, <code>requestPermission</code>, that will be used to detect when the user has requested to grant our application permission to access the media on their device.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PermissionExplainer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">requestPermission</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Within this composable, we’re going to be displaying a message to the user (to explain why we are requesting permission), along with a button that will be used to trigger the permission flow. Each of these is going to be displaying textual content, so we’ll need to add a string resource for each to the <code>resources.xml</code> file for this feature module.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;permission_explainer_message&quot;</span>&gt;
	To display media we need access to the storage on your 
	device
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;permission_explainer_action&quot;</span>&gt;
	Grant permission
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With these resources in place, we can now build out the composable function that will be used to display this explainer. </p>

<p>As outlined in the diagram above, this is going to be a minimal composable that displays both a <code>Text</code> and <code>Button</code> composable to the user. This <code>Text</code> composable will be used to communicate to the user why we need permission, while the <code>Button</code> will allow us to navigate the user to system settings to trigger the permissions flow.</p>

<p>Before we start adding any of these composables for the display of content, we’re going to add a parent container in the form of a <code>Column</code>. This will be used to display the <code>Text</code> and <code>Button</code> in a vertically stacked format. When it comes to this content displayed within the <code>Column</code>, we’re going to want to position all of this in the center. For this, we’ll utilise both the <code>horizontalAlignment</code> and <code>verticalArrangement</code> arguments to apply the corresponding centralised values.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PermissionExplainer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">requestPermission</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
    ) {
        
    }
}</code></pre>

<p>Next, we’re going to go ahead and compose the <code>Text</code> as a child of our <code>Column</code>, using the resource that we just defined for the <code>text</code> content of the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PermissionExplainer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">requestPermission</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span>
				<span class="syntax-all syntax-entity">R</span>.string.permission_explainer_message),
            textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
        )
    }
}</code></pre>

<p>Alongside this message, we’re also going to add the action that will be used to trigger the permission flow - this will be in the form of a <code>Button</code>. This composable is going to need to display its intent to the user, for which we’ll use the previously defined string resource. At this point, we can now compose our <code>Button</code>. While doing this we’ll also utilise the <code>Spacer</code> composable to create some visual spacing between the <code>Text</code> that is also being composed within the container.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PermissionExplainer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">requestPermission</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span>
				<span class="syntax-all syntax-entity">R</span>.string.permission_explainer_message),
            textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
        <span class="syntax-all syntax-entity">Button</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {

            }
        ) {
            <span class="syntax-all syntax-entity">Text</span>(stringResource(id <span class="syntax-all syntax-keyword">=</span>
				<span class="syntax-all syntax-entity">R</span>.string.permission_explainer_action))
        }
    }
}</code></pre>

<figure><img src="explainer.png"/></figure>

<p>You’ll notice that above while composing the <code>Button</code> we are not yet implementing the <code>onClick</code> argument. When the user clicks this action, we’re going to want to take the user to the system settings so that they can toggle the permissions for our application. However, we’re not going to be handling this navigation within this composable function - instead, we’re going to delegate that responsibility to the parent composable. For this, we’ll add a new lambda argument to our composable function, <code>handleLaunchSettings</code>. Then within the <code>onClick</code> implementation for our <code>Button</code>, we’ll trigger this lambda, which will fire the event back up to the parent to be handled accordingly.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PermissionExplainer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">requestPermission</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span>
				<span class="syntax-all syntax-entity">R</span>.string.permission_explainer_message),
            textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
        <span class="syntax-all syntax-entity">Button</span>(
            onClick <span class="syntax-all syntax-keyword">=</span> {
                requestPermission()
            }
        ) {
            <span class="syntax-all syntax-entity">Text</span>(stringResource(id <span class="syntax-all syntax-keyword">=</span>
				<span class="syntax-all syntax-entity">R</span>.string.permission_explainer_action))
        }
    }
}</code></pre>

<p>We can see here that when the button is interacted with, the <code>requestPermission</code> lambda is invoked. This means that at the point where we compose the <code>PermissionExplainer</code>, we’ll want to trigger the permission request flow. This is where the user will be presented with the system permission dialog, allowing them to grant or deny our application permission to access the media stored on their device.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>
) {
    <span class="syntax-all syntax-keyword">when</span> {
        <span class="syntax-all syntax-keyword">!</span>permissionState.permissionRequested <span class="syntax-all syntax-keyword">-&gt;</span> {
         	<span class="syntax-all syntax-entity">PermissionExplainer</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize()
            ) {
                permissionState.launchPermissionRequest()
            }
        }
    }
}</code></pre>

<p>With the above in place, the <code>PermissionExplainer</code> composable will now be composed when the permission has not previously been requested by our application. If the user decides to interact with the “Grant Permission” action composed on the UI, then the system permission dialog will be displayed on the screen.</p>

<hr />

<h2>Handling denied permissions</h2>

<figure><img src="denied.png"/></figure>

<p>Now that we’ve handled the success states of our permission granting, we’re going to want to handle the cases where the user might have been denied access to their external storage. In this scenario we won’t be able to load any of the media, so we’ll want to display a message to the user that will reflect this state.</p>

<h3>Creating the denied state</h3>

<p>We’re going to start here by creating a new composable function that will be used to communicate this state to the user, we’ll call this <code>DeniedPermission</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DeniedPermission</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>We don’t go too much into how this composable is made up (as we’ve covered a lot of this already in previous composables for this project), but we’ll simply be using a <code>Column</code> to stack a message and button which will be used to communicate the permission request and provide a way for the user to trigger it.</p>

<p>As outlined in the diagram above, this is going to be a minimal composable that displays both a <code>Text</code> and <code>Button</code> composable to the user. This <code>Text</code> composable will be used to communicate this state to the user, while the <code>Button</code> will allow us to navigate the user to system settings to alleviate the permissions issue. We’re going to need to start here by defining some new strings resources over in our <code>strings.xml</code> file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;permission_message&quot;</span>&gt;
	External Storage Permission denied. To be able to show you 
	images from the gallery, you need to grant this app 
	permission to access the external storage.
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;

&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;launch_settings&quot;</span>&gt;
	Grant Permission in Settings
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With this resource in place, we can now think about the composable content. We’ve already covered a similar structure for the permission explainer composable, so we’ll build out our <code>DeniedPermission</code> in the same way.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DeniedPermission</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.permission_message),
            textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))
        <span class="syntax-all syntax-entity">Button</span>(onClick <span class="syntax-all syntax-keyword">=</span> { }) {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
					<span class="syntax-all syntax-entity">R</span>.string.launch_settings)
            )
        }
    }
}</code></pre>

<p>You’ll notice that above while composing the <code>Button</code> we are not yet implementing the <code>onClick</code> argument. When the user clicks this action, we’re going to want to take the user to the system settings so that they can toggle the permissions for our application. However, we’re not going to be handling this navigation within this composable function - instead, we’re going to delegate that responsibility to the parent composable. For this, we’ll add a new lambda argument to our composable function, <code>handleLaunchSettings</code>. Then within the <code>onClick</code> implementation for our <code>Button</code>, we’ll trigger this lambda, which will fire the event back up to the parent to be handled accordingly.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DeniedPermission</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">handleLaunchSettings</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.permission_message),
            textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">12</span>.dp))
        <span class="syntax-all syntax-entity">Button</span>(onClick <span class="syntax-all syntax-keyword">=</span> { handleLaunchSettings() }) {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
					<span class="syntax-all syntax-entity">R</span>.string.launch_settings)
            )
        }
    }
}</code></pre>

<figure><img src="denied-1.png"/></figure>

<hr />

<h3>Composing the denied state</h3>

<p>With the above in place, we now have a composable that can be used to communicate the denied permission state to the user. All we need to do now is compose this within the <code>GalleryContent</code> that we previously created within this chapter. For this, we’re going to utilise the <code>else</code> clause within the <code>when</code> block that is being used to compose our UI based on the current permission state. This is because if the user has not granted permission, and the permission is not currently being requested, then it means that we don’t have permission to access the media right now.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">media</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>
) {
    <span class="syntax-all syntax-keyword">when</span> {
        permissionState.hasPermission <span class="syntax-all syntax-keyword">-&gt;</span> {
            ...
        }
        <span class="syntax-all syntax-keyword">!</span>permissionState.permissionRequested <span class="syntax-all syntax-keyword">-&gt;</span> {
            ...
        }
        <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            <span class="syntax-all syntax-entity">DeniedPermission</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> modifier,
                handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> {
                    
                }
            )
        }
    }
}</code></pre>

<p>You’ll notice here though that the <code>handleLaunchSettings</code> implementation is currently empty. To launch the system settings, we’re going to need access to a context reference. We already decided to not pass this reference when working with the <code>Image</code> for our composable, so we’re going to do the same here. We’ll add a lambda as an argument for our composable function, allowing us to delegate the launching of the system settings to the parent composable where a context reference is already available for us. We’ll then trigger this lambda within the <code>handleLaunchSettings</code> implementation when composing our <code>DeniedPermission</code>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GalleryContent</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">media</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Image</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-parameter">permissionState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span>,
    <span class="syntax-all syntax-parameter">openSettings</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">when</span> {
        permissionState.hasPermission <span class="syntax-all syntax-keyword">-&gt;</span> {
            ...
        }
        <span class="syntax-all syntax-keyword">!</span>permissionState.permissionRequested <span class="syntax-all syntax-keyword">-&gt;</span> {
            ...
        }
        <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
            <span class="syntax-all syntax-entity">DeniedPermission</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> modifier,
                handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> {
                    openSettings()
                }
            )
        }
    }
}</code></pre>

<p>We’ll then need to hop back up to our <code>Gallery</code> composable and implement this required argument. For the implementation of <code>openSettings</code>, we’ll want to create a new <code>Intent</code> that will allow us to launch the system settings for our application - which we can do using the <code>ACTION_APPLICATION_DETAILS_SETTINGS</code>. When creating an intent for this action, we must provide a URI that represents that package that we wish to show the settings screen for. In our case, this is <code>package: academy.compose.gallery</code>, which will differ per application that you are defining this for.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Gallery.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Gallery</span>() {
	...
	<span class="syntax-all syntax-entity">GalleryContent</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
        media <span class="syntax-all syntax-keyword">=</span> retrievedMedia,
        openSettings <span class="syntax-all syntax-keyword">=</span> {
            context.startActivity(
                <span class="syntax-all syntax-entity">Intent</span>(
                    <span class="syntax-all syntax-entity">Settings</span>.
						<span class="syntax-all syntax-entity">ACTION_APPLICATION_DETAILS_SETTINGS</span>,
                    <span class="syntax-all syntax-entity">Uri</span>.parse(<span class="syntax-all syntax-string">&quot;package:</span><span class="syntax-all syntax-entity">${context.packageName}</span><span class="syntax-all syntax-string">&quot;</span>)
                )
            )
        }
    )
}</code></pre>

<p>With this in place, we can direct the user to the system settings screen for our application, prompting them to tweak the permissions as required.</p>

<hr />

<h2>Wrapping Up</h2>

<p>Throughout this project, we’ve now fully implemented our gallery feature - allowing our users to view thumbnails for the images that are on their device storage, along with performing selection to view them in an immersive format. We’ve explored the composition of many different UI components, along with how to handle permissions in a composable environment.</p>

<figure><img src="gallery-4.png"/></figure>

<p>With all of this in place, we’ll want to ensure these components remain functional within our app. In the next chapter, we’re going to explore writing automated UI tests for these composables.</p>

<h1>Testing the Gallery UI</h1>

<p>Now that we’ve built our Gallery feature, we’re going to take a look at how we can write tests for our composables. We’re going to be writing some instrumentation tests using the compose ui-test-junit package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>)
debugImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to add mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered whenever expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:3.12.4&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependent on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		exclude <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/AL2.0&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/LGPL2.1&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
	}
}</code></pre>

<hr />

<h2>Testing the Gallery Content</h2>

<p>At a high level of our feature is the <code>GalleryContent</code> composable. While we have a collection of focused composables that are responsible for specific parts of our UI, this composable acts as the parent container - composing each of the child composables that make up the different parts of the gallery feature. For this reason, we’re going to write a collection of tests that will perform asserts to ensure the correct composables are displayed as expected. We’ll start here by creating a new test class, <code>GalleryContentTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GalleryContentTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the <code>ComposeContentTestRule</code> class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@get:Rule
</span><span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched in, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside of.</p>

<h3>Testing the Image Gallery display</h3>

<p>With this test class configured, we’re going to write some tests to assert that each of the expected composables is being displayed when required - which will be based on the state which is provided to the <code>GalleryContent</code> composable. We’ll start here by asserting that the Image Gallery itself is being composed. To write this first test we’ll use the <strong>@Test</strong> annotation and create a new function to test that the header is displayed by default within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Image_Gallery_Displayed</span>() {

}</code></pre>

<p>Inside of this test, we’re going to need to start by setting the composable content that is to be displayed on screen for us to assert against. Here we’ll use the test rule that we previously defined, along with its <code>setContent</code> function. This function takes a composable function as an argument, allowing us to define what is to be composed on screen for our tests. Because we’re wanting to test the <code>GalleryContent</code> Composable that we defined in the previous sections of this chapter, we’ll go ahead and compose the <code>GalleryContent</code>. When composing the <code>GalleryContent</code> we’ll need to provide references for several different arguments.</p>

<ul>
	<li><strong>media</strong>: the list of <code>Image</code> items that are to be displayed within the gallery. For this, we will simply pass a single item that does not represent any real media, as we don’t need any real data within our test.</li>
	<li><strong>permissionState</strong>: for this, we’ll need to provide an implementation of the <code>PermissionState</code> interface. When doing so we will need to implement the required members - when doing this it is important to note the constraints which will result in the gallery being composed. For this, the <code>hasPermission</code> flag must be marked as <code>true</code>, which will result in the composition of the gallery.</li>
	<li><strong>openSettings</strong>: we don’t currently need to utilise this callback within the test, so we’ll leave the implementation of this block empty.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Image_Gallery_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">object</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span> {
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> hasPermission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permissionRequested<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> shouldShowRationale<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>

        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">launchPermissionRequest</span>() { }
    }

	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">GalleryContent</span>(
        	media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">0</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>)),
            permissionState <span class="syntax-all syntax-keyword">=</span> permissionState,
            openSettings <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>With this in place, we now have the <code>GalleryContent</code> being composed within our test. Now, so that we can locate the Image Gallery within this test, we’re going to need to add a tag to the composable that we wish to perform assertions against - this tag can then be used to locate our composable within our tests. We’ll need to start here by defining a tag reference that can be accessed from both our tests and our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_IMAGE_GALLERY</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;image_gallery&quot;</span>
}</code></pre>

<p>With this tag defined, we’ll then need to add this to the composition of the <code>ImageGallery</code> composable - we’ll use the <code>testTag</code> modifier to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GalleryContent.kt
</span>
<span class="syntax-all syntax-entity">ImageGallery</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_IMAGE_GALLERY</span>),
	...
)</code></pre>

<p>Next, we’re going to locate the node within our composable hierarchy so that we can perform interactions and assertions on it. Here we’ll utilise the <code>onNodeWithTag</code> function, providing the tag that we defined above. We can then utilise the <code>assertIsDisplayed</code> function to assert that the composable is being displayed as expected within the <code>GalleryContent</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Image_Gallery_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">object</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span> {
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> hasPermission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permissionRequested<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> shouldShowRationale<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>

        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">launchPermissionRequest</span>() { }
    }
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">0</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>)),
            permissionState <span class="syntax-all syntax-keyword">=</span> permissionState,
            openSettings <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_IMAGE_GALLERY</span>)
        .assertIsDisplayed()
}</code></pre>

<p>With this in place, we’ll be able to run this test and see that the Image Gallery is being composed as expected.</p>

<h3>Testing the Progress display</h3>

<p>Along with testing the visibility to the image gallery within the <code>GalleryContent</code> composable, we’re going to want to assert that the progress is displayed when expected - this is when the images are being loaded from the media store. Before we can do this though, we’re going to need to add another tag so that the composable can be located within the UI hierarchy.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    ...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PROGRESS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;progress&quot;</span>
}</code></pre>

<p>With this tag in place, we can now assign it to the corresponding composable using the <code>testTag</code> modifier - in this case, it’ll be the progress container within the <code>GalleryContent</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GalleryContent.kt
</span>
<span class="syntax-all syntax-entity">Box</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_PROGRESS</span>),
	contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
) {
	<span class="syntax-all syntax-entity">CircularProgressIndicator</span>()
}</code></pre>

<p>With this tag now assigned to a composable, we can use this within our tests to assert the visibility of the progress indicator within our UI. Within the <code>GalleryContent</code> composable, the progress indicator is displayed when the permission exists to access the media but the media has not yet been loaded - which would be signified by the <code>media</code> argument representing a <code>null</code> value. For this state within our tests, we’ll also need to provide the same <code>PermissionState</code> state that represents a granted media permission, passing the <code>null</code> value for the <code>media</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Progress_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">object</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span> {
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> hasPermission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permissionRequested<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> shouldShowRationale<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>

        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">launchPermissionRequest</span>() { }
    }
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
            permissionState <span class="syntax-all syntax-keyword">=</span> permissionState,
            openSettings <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>With the above in place, we’ll now need to assert that the progress composable is being displayed. We’ll use the <code>TAG_PROGRESS</code> tag that we defined to locate the desired node within our composable hierarchy, followed by utilising the <code>assertIsDisplayed</code> function to assert that the node is being displayed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Progress_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">object</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span> {
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> hasPermission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permissionRequested<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> shouldShowRationale<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>

        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">launchPermissionRequest</span>() { }
    }
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
            permissionState <span class="syntax-all syntax-keyword">=</span> permissionState,
            openSettings <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PROGRESS</span>)
        .assertIsDisplayed()
}</code></pre>

<h3>Testing the Denied Permission display</h3>

<p>When it comes to composable display, we’re going to finally want to assert that the denied permissions composable is being displayed within our UI. For this, we’re going to need to add another tag so that the composable can be located within the UI hierarchy.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
    ...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_DENIED_PERMISSION</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;denied_permission&quot;</span>
}</code></pre>

<p>With this tag in place, we can now assign it to the corresponding composable using the <code>testTag</code> modifier - in this case, it’ll be the <code>DeniedPermission</code> composable within the <code>GalleryContent</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GalleryContent.kt
</span>
<span class="syntax-all syntax-entity">DeniedPermission</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_DENIED_PERMISSION</span>),
	handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> {
		openSettings()
	}
)</code></pre>

<p>With this tag now assigned to a composable, we can use this within our tests to assert the visibility of the <code>DeniedPermisson</code> composable within our UI. This composable is displayed when permission to access the media has previously been denied. For this state within our tests, we’ll need to provide the <code>PermissionState</code> state that represents a denied media permission. Here we can use the <code>hasPermission</code> flag to state that the permission is not present, followed by the <code>permissionRequested</code> flag to state that the permission has been previously requested - these two flags together signify that the permission had previously been requested, but denied.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Denied_Permission_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">object</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span> {
		<span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> hasPermission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permissionRequested<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> shouldShowRationale<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>

        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">launchPermissionRequest</span>() { }
    }
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
            permissionState <span class="syntax-all syntax-keyword">=</span> permissionState,
            openSettings <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>With this <code>PermissionState</code> now configured, we can utilise the <code>TAG_DENIED_PERMISSION</code> tag to assert that the corresponding composable node is currently being displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Denied_Permission_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">object</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">PermissionState</span> {
		<span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> hasPermission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permission<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> permissionRequested<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">val</span> shouldShowRationale<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
            get() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>

        <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">launchPermissionRequest</span>() { }
    }
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
            permissionState <span class="syntax-all syntax-keyword">=</span> permissionState,
            openSettings <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_DENIED_PERMISSION</span>)
        .assertIsDisplayed()
}</code></pre>

<h3>Testing the Permission Request trigger</h3>

<p>Now that we are asserting the different visibilities within the <code>GalleryContent</code> composable, we’re next going to want to assert that the permission is being requested as expected when the permission has not yet been granted <strong>or</strong> requested. We’re going to start here by creating a mock representation of the <code>PermissionState</code> - this will allow us to verify the expected interaction with this interface.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Permission_Request_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> mock&lt;<span class="syntax-all syntax-entity">PermissionState</span>&gt;()
}</code></pre>

<p>Next, we’re going to want to compose the <code>GalleryContent</code>. We’ll pass a <code>null</code> value for the <code>media</code> to signify that the media has not yet been loaded, along with the mock representation of our <code>PermissionState</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Permission_Request_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> mock&lt;<span class="syntax-all syntax-entity">PermissionState</span>&gt;()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
            permissionState <span class="syntax-all syntax-keyword">=</span> permissionState,
            openSettings <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>When the <code>GalleryContent</code> is composed in this state, we would expect that the <code>launchPermissionRequest</code> function of our <code>PermissionState</code> interface is invoked. We’re going to utilise the <code>verify</code> functionality from mockito to assert that this is the case.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Permission_Request_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> permissionState <span class="syntax-all syntax-keyword">=</span> mock&lt;<span class="syntax-all syntax-entity">PermissionState</span>&gt;()
    whenever(permissionState.permissionRequested)
        .doReturn(<span class="syntax-all syntax-constant">false</span>)
    whenever(permissionState.hasPermission)
        .doReturn(<span class="syntax-all syntax-constant">false</span>)

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GalleryContent</span>(
            media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
            permissionState <span class="syntax-all syntax-keyword">=</span> permissionState,
            openSettings <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    <span class="syntax-all syntax-keyword">val</span> grantPermission <span class="syntax-all syntax-keyword">=</span>
		<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
				<span class="syntax-all syntax-entity">R</span>.string.permission_explainer_action)
    composeTestRule
        .onNodeWithText(grantPermission)
        .performClick()
    verify(permissionState).launchPermissionRequest()
}</code></pre>

<p>With this in place, once the composition has occurred, the verification will be run to assert that the <code>launchPermissionRequest</code> function is called on our <code>PermissionState</code> reference.</p>

<hr />

<h2>Testing the Denied State</h2>

<p>As we saw in the previous tests, the <code>DeniedPermission</code> composable is composed within our UI when the permission to access media has been denied by the user. While we have tested that this is displayed under the expected conditions, we’re also going to want to test that the contents of this composable are being composed as expected. We’re going to start here by creating a new test class, <code>DeniedPermissionTest</code>, configuring the test rule in the process. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">DeniedPermissionTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>Within this composable, there are a couple of components being displayed. The first is a message that lets the user know about the denied permission - this is quite important and provides some context as to why the user is seeing this state. For this reason, we’re going to want to test that it is being displayed as expected. We’ll need to start by composing the <code>DeniedPermission</code> composable, for which we’ll provide an empty implementation of the <code>handleLaunchSettings</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DeniedPermission</span>(
            handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>With our composable now being available within our test, we’re going to want to perform the assertion - here we’ll want to check that the denied permission message is being composed. The message being displayed here is being referenced from the <code>R.string.permission_message</code> string resource, so we’ll want to access this resource and assert that a node exists which is displaying this message. </p>

<p>We’ll start by utilising the <code>onNodeWithText</code> function on our test rule, providing a string value for the <code>R.string.permission_message</code> resource. Once a node has been located that matches the representation of this string value, we’re going to want to assert that it is being displayed. Here we’ll use the <code>assertIsDisplayed</code> function, allowing us to assert that this node is being fully displayed within the UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Message_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DeniedPermission</span>(
            handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithText(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>
				.getInstrumentation()
					.targetContext.getString(
                    	<span class="syntax-all syntax-entity">R</span>.string.permission_message)
        )
        .assertIsDisplayed()
}</code></pre>

<p>At this point, we know that the denied permission message is being displayed to the user. Alongside this, a button is displayed which allows the user to trigger the system settings screen for our application. This is a pretty important component within the composable, so we’re going to want to assert that it’s being composed as expected. To assert that this is the case, we’re going to need to add another tag that can be assigned to this button.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
	...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PERMISSIONS_BUTTON</span> <span class="syntax-all syntax-keyword">=</span> 
		<span class="syntax-all syntax-string">&quot;permissions_button&quot;</span>
}</code></pre>

<p>With this tag defined, we’ll now need to assign this to our <code>Button</code> composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// DeniedPermission.kt
</span>
<span class="syntax-all syntax-entity">Button</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_PERMISSIONS_BUTTON</span>),
	onClick <span class="syntax-all syntax-keyword">=</span> { handleLaunchSettings() }
)</code></pre>

<p>We’re now going to write a new test, <code>Action_Displayed</code>, which will contain the assertion for this button composable. Within this test we’ll need to start by composing the <code>DeniedPermission</code>, again providing an empty implementation block for the <code>handleLaunchSettings</code> lambda.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Action_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DeniedPermission</span>(
            handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>At this point, we’re now ready to assert that the <code>Button</code> is being displayed as expected. Using the previously defined <code>TAG_PERMISSIONS_BUTTON</code> tag, we’ll locate the node for the settings button and use the <code>assertIsDisplayed</code> function to assert that the button is being displayed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Action_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DeniedPermission</span>(
            handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PERMISSIONS_BUTTON</span>)
        .assertIsDisplayed()
}</code></pre>

<p>With this test in place, we now know that the permissions button is being displayed as expected. This allows us to ensure that the user will always be able to grant media access permission to our app outside of the initial permissions request flow, as without this, this feature of our app will be pretty unusable.</p>

<p>Now that we know this settings button is being displayed as expected, we’re going to want to assert that the <code>handleLaunchSettings</code> is being triggered when the button is clicked. If this wasn’t behaving as expected, the button would never result in the user being navigated to the system settings screen for our application.</p>

<p>Within our test, we’re going to need to start by composing the <code>DeniedPermission</code> composable. When composing this, we’ll pass in a <code>mock</code> lambda function for the <code>handleLaunchSettings</code> argument. This means that we can use this <code>mock</code> to verify that interactions have taken place based on composable events.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Action_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> handleLaunchSettings<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DeniedPermission</span>(
            handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> handleLaunchSettings
        )
    }
}</code></pre>

<p>Using the previously defined <code>TAG_PERMISSIONS_BUTTON</code> tag, we’ll locate the node for the settings button and use the <code>performClick</code> function to trigger a click event on the <code>Button</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Action_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> handleLaunchSettings<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DeniedPermission</span>(
            handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> handleLaunchSettings
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PERMISSIONS_BUTTON</span>)
        .performClick()
}</code></pre>

<p>When this click action is triggered, this is the point that we would expect the <code>handleLaunchSettings</code> to be invoked so that the parent composable can handle the event. We can verify this within our test by using mockito and its <code>verify</code> function to assert that the lambda has been invoked. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Action_Triggers_Callback</span>() {
    <span class="syntax-all syntax-keyword">val</span> handleLaunchSettings<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">DeniedPermission</span>(
            handleLaunchSettings <span class="syntax-all syntax-keyword">=</span> handleLaunchSettings
        )
    }
    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PERMISSIONS_BUTTON</span>)
        .performClick()
    verify(handleLaunchSettings).invoke()
}</code></pre>

<p>When this lambda is invoked as expected, the test will succeed - otherwise, the lambda not being triggered will mean that our verification will not be satisfied and the test will fail.</p>

<hr />

<h2>Testing the Image Grid</h2>

<p>The key part of our feature is the image gallery itself, used to display a grid of selectable images to the user. If this wasn’t displaying the images as intended, then the feature would be pretty unusable! To ensure that this never occurs we’re going to write some tests to assert the expected behaviours of the gallery. </p>

<h3>Testing the Image Gallery</h3>

<p>We’ll start here by creating a new test class, <code>ImageGalleryTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ImageGalleryTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>For our first test, we’re going to assert that the images are correctly being displayed within the gallery grid.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Images_Displayed</span>() {

}</code></pre>

<p>Within these tests, we’re going to need to interact with not only the grid, but also the individual images that make up our grid. For this reason, we’re going to need to add two new tags to our <code>Tags</code> object.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    ...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_IMAGE_GRID</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;image_grid&quot;</span>
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_IMAGE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;image_&quot;</span>
}</code></pre>

<p>With these tags in place, we’re now going to want to apply them to the corresponding composables. We’ll start by using the <code>testTag</code> function to apply the <code>TAG_IMAGE_GRID</code> tag to the <code>LazyVerticalGrid</code> that represents the grid of images.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">LazyVerticalGrid</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_IMAGE_GRID</span>),
	cells <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GridCells</span>.<span class="syntax-all syntax-entity">Fixed</span>(<span class="syntax-all syntax-constant">2</span>)
)</code></pre>

<p>Next, we’re going to want to apply the <code>TAG_IMAGE</code> tag so that we can interact with each image within the gallery. When defining this tag we appended an underscore on the end, leaving space to append some form of id onto the tag. When using the <code>testTag</code> function to apply a tag to the <code>GalleryImage</code> composable, we’re going to utilise the <code>TAG_IMAGE</code> tag while appending the id of the current <code>Image</code> item that is being composed. This means that from within our tests we can now reference the corresponding <code>GalleryImage</code> composable for a given <code>Image</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">GalleryImage</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.clickable {
			selectedImage <span class="syntax-all syntax-keyword">=</span> it.uri
		}
		.height(<span class="syntax-all syntax-constant">150</span>.dp)
		.fillMaxWidth()
		.testTag(<span class="syntax-all syntax-entity">TAG_IMAGE</span> <span class="syntax-all syntax-keyword">+</span> it.id),
	uri <span class="syntax-all syntax-keyword">=</span> it.uri,
	scaleType <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentScale</span>.<span class="syntax-all syntax-entity">Crop</span>
)</code></pre>

<p>With these tags now in place, we’re able to reference the corresponding composables to perform assertions on. Before we can do this though, we’re going to want to start by composing our <code>ImageGallery</code>, providing a list of images to be composed for the image grid.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Images_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">0</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>),
		<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">1</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>))
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ImageGallery</span>(
            retrieveMedia <span class="syntax-all syntax-keyword">=</span> media
        )
    }
}</code></pre>

<p>Now that the gallery is being composed we can go ahead and assert that the expected images are being displayed within the grid. Using our <code>media</code> list, we’re going to want to loop through the <code>Image</code> references contained within this. Using our <code>TAG_IMAGE_GRID</code> tag we can locate the node for the image gallery itself, followed by using the <code>onChildAt</code> function to locate the node at the current index of our <code>for</code> loop. We expect that the current <code>Image</code> item within the <code>media</code> list will represent the child at the given index of the grid, so we can perform the assertion in this way. For each child we’re going to want to assert that the tag matches the expected state, using the <code>id</code> of the given <code>Image</code>. To assert this we’ll take the <code>TAG_IMAGE</code> tag, appending the <code>id</code> of the current <code>Image</code> item and using the <code>hasTestTag</code> function to verify that the tag of the current grid item matches this expected value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Images_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">0</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>),
		<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">1</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>))
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ImageGallery</span>(
            retrieveMedia <span class="syntax-all syntax-keyword">=</span> media
        )
    }
    media.forEachIndexed { index, image <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule
            .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_IMAGE_GRID</span>)
            .onChildAt(index)
            .<span class="syntax-all syntax-keyword">assert</span>(hasTestTag(<span class="syntax-all syntax-entity">TAG_IMAGE</span> <span class="syntax-all syntax-keyword">+</span> image.id))
    }
}</code></pre>

<h3>Testing the Image Preview</h3>

<p>Now that we can assert the display of gallery images within our UI, we’re going to want to ensure that the image preview is composed when one of the gallery images has been selected. In this test, we’re going to want to interact with a gallery image, followed by asserting that the preview has been displayed. Before we can perform this assertion, we’ll need to add a new tag that can be used to locate this preview composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    ...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_IMAGE_PREVIEW</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;image_preview&quot;</span>
}</code></pre>

<p>With this tag in place, we can now assign this to the composition of the <code>GalleryPreview</code> composable within the <code>ImageGallery</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">GalleryPreview</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxSize()
		.testTag(<span class="syntax-all syntax-entity">TAG_IMAGE_PREVIEW</span>),
	image <span class="syntax-all syntax-keyword">=</span> image,
	onDismiss <span class="syntax-all syntax-keyword">=</span> {
		selectedImage <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
	}
)</code></pre>

<p>Before we can assert the composition of the preview, we’re going to need to compose the <code>ImageGallery</code> so that we can trigger the preview and assert its existence. Similar to the previous tests, we’ll compose this <code>ImageGallery</code> by providing a list containing a single <code>Image</code> item.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Preview_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">0</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>), <span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">1</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>))
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">ImageGallery</span>(
			retrieveMedia <span class="syntax-all syntax-keyword">=</span> media
		)
	}
}</code></pre>

<p>We’re then going to utilise the previously added <code>TAG_IMAGE_GRID</code> tag to interact with the image gallery. Here we’ll perform a click interaction on the first child - we’ll locate this child node using the <code>onChildAt</code> function, followed by the <code>performClick</code> function to perform the click interaction. We retrieve the first child at index <code>0</code> here because there is only a single <code>Image</code> item in the media that we have provided to the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Preview_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">0</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>), <span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">1</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>))
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">ImageGallery</span>(
			retrieveMedia <span class="syntax-all syntax-keyword">=</span> media
		)
	}
	composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_IMAGE_GRID</span>)
        .onChildAt(<span class="syntax-all syntax-constant">0</span>)
        .performClick()
}</code></pre>

<p>Now that the image gallery is being composed and we have clicked on an <code>Image</code>, we’d expect the image preview to be displayed. We can now use the <code>TAG_IMAGE_PREVIEW</code> tag to locate the node that represents the <code>GalleryPreview</code> composable, followed by the <code>assertIsDisplayed</code> function to check that the preview is being displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Preview_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> media <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(<span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">0</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>), <span class="syntax-all syntax-entity">Image</span>(<span class="syntax-all syntax-constant">1</span>, <span class="syntax-all syntax-entity">Uri</span>.<span class="syntax-all syntax-entity">EMPTY</span>, <span class="syntax-all syntax-string">&quot;&quot;</span>))
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">ImageGallery</span>(
			retrieveMedia <span class="syntax-all syntax-keyword">=</span> media
		)
	}
	composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_IMAGE_GRID</span>)
        .onChildAt(<span class="syntax-all syntax-constant">0</span>)
        .performClick()

    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_IMAGE_PREVIEW</span>)
        .assertIsDisplayed()
}</code></pre>

<p>With these interactions in place, we’d expect that the image gallery would be composed, followed by the image preview once an item from the gallery is interacted with. With this test, we can now assert that this expected flow of operations is the case.</p>

<h1>Building a Music Dashboard</h1>

<p>Many multimedia focused applications offer an entire catalogue of media to their users. This catalogue is often split into multiple categories - be it user favourites, new additions or items that are currently featured. This can be a lot of information for users to take in, so these collections are often split into individual sections on a screen. This media dashboard allows the user to access the catalogue on offer, being able to focus on a specific kind of content and in turn making it easier to navigate through the catalogue on offer.</p>

<p>With the above in mind, we’re going to be building out a media catalogue screen using Jetpack Compose. </p>

<figure><img src="screens.png"/></figure>

<p>While at first, this might just sound like a list of content, there is much more to it than that - there are many different layouts, components and interactions that we need to take into account when building out this dashboard.</p>

<ul>
	<li>Build a content list that supports 3 different kinds of layouts, as well as different scroll directions</li>
	<li>Provide the ability to search for content in the catalogue, persisting the UI based on the current search queries</li>
	<li>Utilise the backdrop scaffold to create layered content</li>
	<li>A collapsed and full-screen media playback component that displays the currently playing track</li>
</ul>

<p>We can see here that when it comes to the music dashboard screen, there is more to it than a simple list to display a catalogue of content. Alongside the state and event management that comes with this screen, we need to build out several different UI components using Jetpack Compose to bring our music catalogue to life.</p>

<h1>Defining the Music Dashboard State</h1>

<p>Within our music dashboard, we’re going to be displaying a range of data that makes up the state of the screen. This data is going to be made up of music tracks but split up into a collection of different purposes. </p>

<ul>
	<li>A list of music tracks that are marked as featured</li>
	<li>A list of music tracks that are marked as new</li>
	<li>A list of music tracks that are marked as recent</li>
	<li>The currently playing track</li>
	<li>The current search query</li>
	<li>The results from the current search</li>
</ul>

<p>Along with the different UI components that are going to make up our screen, there are a few different pieces of state that make up the state of our screen. Let’s start to take the above requirements and build out a class that will represent the state of our composable UI. We’ll start by creating a new class to hold the state of our screen:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>()</code></pre>

<hr />

<h2>Modelling the screen status</h2>

<p>When it comes to the data that is being displayed within our UI, in a real-world scenario this is going to be loaded. In this case of our project, we’re going to be loading this from a data factory so that we can focus on building composable UI. So that we can have the current scenario of our screen represented within the state of our screen, we’re going to model the possible scenarios in the form of an enum class, <code>Status</code>. Within this class, we’re going to define two values that can be represented by our type, <code>LOADING</code> and <code>SUCCESS</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Status.kt
</span>
<span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Status</span> {
    <span class="syntax-all syntax-entity">LOADING</span>, <span class="syntax-all syntax-entity">SUCCESS</span>, <span class="syntax-all syntax-entity">IDLE</span>
}</code></pre>

<p>Now that we have this enum class defined, we’ll go ahead and add a representation of this to our state class. We’ll default this to the value of <code>IDLE</code> so that when the state is initialised it has a default value assigned to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">status</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Status</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Status</span>.<span class="syntax-all syntax-entity">LOADING</span>
)</code></pre>

<hr />

<h2>Modelling the Music Track</h2>

<p>Now that we have this screen status defined, we’re going to move on to modelling the key part of our music feature, the track representation. Each track within our UI is going to be represented by a class which holds various properties used to describe a given track. For each track, we’re going to need a collection of information.</p>

<ul>
	<li><strong>id</strong> - a string representing the unique id used to identify the track</li>
	<li><strong>title</strong> - a string representing the title of the track</li>
	<li><strong>artist</strong> - a string representing the name of the artist</li>
	<li><strong>cover</strong> - the color value used as a visual representation of the track</li>
	<li><strong>length</strong> - a Long value representing the length of the track</li>
	<li><strong>isNew</strong> - a boolean value that represents whether the track is new</li>
	<li><strong>isFeatured</strong> - a boolean value that represents whether the track is featured</li>
</ul>

<p>With the above properties and their respective type, we can go ahead and construct a data class to represent this structure.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Track.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Track</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">id</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">title</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">artist</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">cover</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">length</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Long</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">isNew</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">isFeatured</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
)</code></pre>

<p>With this data class in place, we now have a <code>Track</code> class which can be used to represent the different tracks that are being displayed within our music dashboard. So that we can render these tracks within our UI, we’re going to need to add a source of these tracks to our state class. Here we’ll go ahead and add a new <code>tracks</code> property to our <code>MusicDashboardState</code> class, providing a default value of <code>null</code> for when no tracks have yet been set.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">status</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ResultStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ResultStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<hr />

<h2>Modelling the Now Playing state</h2>

<p>Now that we have the class modelled for each <code>Track</code> that is going to be rendered within our dashboard UI, we can start to think about modelling the playback state for the track that is currently being played. This allows us to compose this information to the user, giving awareness of the <code>Track</code> that is currently being played.</p>

<p>For this, we’re going to need more information than the <code>Track</code> that is currently being played. We’re also going to need to know the current state of playback (is the track being played, has it been paused etc), as well as the current position of playback. To model this information we’re going to create a new class, <code>NowPlaying</code>, which will be used to hold this information around the playback of our track. We’ll start here by adding a reference to the <code>Track</code> that is currently being played.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// NowPlaying.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NowPlaying</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
)</code></pre>

<p>Alongside this, we’re going to add a <code>Long</code> reference which will be used to hold the current playback position of the provided track.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// NowPlaying.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NowPlaying</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">position</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Long</span>
)</code></pre>

<p>When it comes to the <code>NowPlaying</code> track, we’re also going to want to know the current state of playback - this is so that we can display the corresponding icon within the media player. For this representation we’re going to create a new enum, <code>NowPlayingState</code>. This enum will have three values - playing, paused and stopped.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NowPlayingState</span> {    
	<span class="syntax-all syntax-entity">PLAYING</span>, <span class="syntax-all syntax-entity">PAUSED</span>, <span class="syntax-all syntax-entity">STOPPED</span>
}</code></pre>

<p>With this enum defined, we’ll now want to add this to our <code>NowPlaying</code> class.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NowPlaying</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">position</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Long</span>,
	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlayingState</span>
)</code></pre>

<p>We’ll now add a representation of this <code>NowPlaying</code> class to our <code>MusicDashboardState</code> class. This value will be nullable, as there may not currently be any track selected for playback (such as when the feature is first opened).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">status</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ResultStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ResultStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>With this value now added to our state, we can now store playback information for the currently playing track which is accessible from the state of our feature.</p>

<hr />

<h2>Modelling the Search state</h2>

<p>Alongside the ability to manage playback for a track within the music dashboard, we also offer the ability to perform a search query against the contents of the tracks library. To utilise this feature, the user needs to input a query into the search bar component - and so that the value of this search query can be composed into our UI, the query that is entered here is going to need to be a part of our state.</p>

<p>We’ll start here by adding a new value to our <code>MusicDashboardState</code> state class in the form of a <code>String</code>. This value will represent the search query that has been entered by the user, so we’ll call this <code>searchTerm</code>. We’ll also mark this field as nullable, as that will allow us to signify that a search is not currently taking place - and therefore the search state should not be composed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">status</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ResultStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ResultStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>Whenever the user enters or makes a change to the current search term, the music dashboard will display a list of search results based on the query. Because these search results are going to be composed within our UI, we’ll need to have these results as a part of our state. Each of these results is going to be represented by an instance of a <code>Track</code>, so we can simply add a new field in the form of a <code>List&lt;Track&gt;</code> to our state class. We’ll call this <code>searchResults</code>, as well as making the field nullable - as there may not always be search results to be displayed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">status</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ResultStatus</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ResultStatus</span>.<span class="syntax-all syntax-entity">LOADING</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchResults</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<hr />

<h2>Modelling Track access</h2>

<p>While we have the tracks defined as a value within our state, our tracks are going to need to be accessible in three different types of collections - new tracks, featured tracks and recent tracks. While we could have modelled this as three different collections within our state class, we’re going to take a different approach and create three functions within our data class that will be used to filter out and provide the required track types.</p>

<p>We’re going to start here by creating a function that will be used to provide the collection of new tracks. For this, we’ll create a new function, <code>newTracks</code>. This function is going to be used to filter out the tracks from our <code>Track</code> collection whose <code>isNew</code> flag represents the value of <code>true</code>. We’ll also utilise null safety here, so that if the tracks collection within our state is null, then a <code>null</code> value is simply returned from the function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
    ...
) {

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">newTracks</span>() <span class="syntax-all syntax-keyword">=</span> tracks?.filter { it.isNew }

}</code></pre>

<p>We’ll want to do a similar thing for retrieving featured tracks, so we’ll start here by creating a new function, <code>featuredTracks</code>. For this, we’ll do a similar thing as the <code>newTracks</code> implementation, except returning the track references whose <code>isFeatured</code> flag represents a <code>true</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
    ...
) {

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">newTracks</span>() <span class="syntax-all syntax-keyword">=</span> tracks?.filter { it.isNew }

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">featuredTracks</span>() <span class="syntax-all syntax-keyword">=</span> tracks?.filter { it.isFeatured }

}</code></pre>

<p>Finally, we’ll create a new function <code>recentTracks</code> that will be used to return tracks to be used for display in the ‘library’ feed. Here we’ll simply only want to display tracks that are not currently being displayed in the ‘new’ and ‘featured’ feeds. We’ll use the same approach to <code>filter</code> the tracks out from the collection, returning only tracks that have a <code>false</code> value for both the <code>isFeatured</code> and <code>isNew</code> flags. This will return us all of the <code>Track</code> references that have not been returned from the previous two functions, allowing us to display these tracks within the ‘library’ feed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardState.kt
</span>
<span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
    ...
) {

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">newTracks</span>() <span class="syntax-all syntax-keyword">=</span> tracks?.filter { it.isNew }

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">featuredTracks</span>() <span class="syntax-all syntax-keyword">=</span> tracks?.filter { it.isFeatured }

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">libraryTracks</span>() <span class="syntax-all syntax-keyword">=</span> tracks?.filter { 
		<span class="syntax-all syntax-keyword">!</span>it.isFeatured <span class="syntax-all syntax-keyword">&amp;&amp;</span> <span class="syntax-all syntax-keyword">!</span>it.isNew 
	}

}</code></pre>

<hr />

<p>With all of this in place, we now have a class that can be used to represent the state of our UI. Over the next few sections of this chapter, we’ll utilise this state when building out our UI, modifying its values as interactions with composables take place, triggering recompositions to reflect any state changes.</p>

<h1>Creating the Music Dashboard ViewModel</h1>

<p>Now that we have the state modelled for our Music Dashboard, we can start thinking about the ViewModel that will be used to manage that state and provide a way to orchestrate it to the user interface. </p>

<hr />

<h2>Setting up the ViewModel</h2>

<p>Before we can get started here, we’re going to add a new dependency to our project that will give us access to the Android Lifecycle ViewModel class:</p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span></code></pre>

<p>💡 You aren’t required to use a ViewModel when working with compose. For the sake of these exercises, helps us to keep things simple and follow an approach that many developers are familiar with.</p>

<p>Next, we’ll create a new ViewModel, called <code>MusicViewModel</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicViewModel.kt
</span>
<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>()</code></pre>

<p>This <code>ViewModel</code> is going to need to hold a reference to the state of our screen. For this we’re going to utilise <code>StateFlow</code> - this allows us to create a state-holder observable flow that will emit the default state we provide to it, along with any updates that occur during its lifetime. Here we’ll create a new <code>MutableStateFlow</code> instance, providing a reference to our <code>MusicDashboardState</code> class as the default value for our <code>StateFlow</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicViewModel.kt
</span>
<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    <span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">MusicDashboardState</span>())

}</code></pre>

<p>With this in place, we now have a StateFlow reference that is holding a reference to our authentication state, initialising it with a new instance of the state class and relying on the defaults that the constructor provides.</p>

<hr />

<h2>Manipulating state using events</h2>

<p>While this state is now in place, we need to start thinking about the different ways in which it can be manipulated - whenever something is changed in our UI (track selected, search triggered), we’ll want to update the state within our ViewModel so that the observing UI can reflect those changes. </p>

<p>For when this is the case, we’re going to model some events that can be triggered in our composable UI and in turn these events will be used to manipulate the state within the view model. This allows us to have a single way of our composable UI communicating with the ViewModel, rather than needing to pass the entire ViewModel or many references to separate functions which could be used to trigger state changes. Instead, we can pass a single function reference to our composable UI which can then be used to trigger these events in the ViewModel. For these events we’re going to need to define different types that can be triggered, so we’ll go ahead and create a new sealed class to represent these.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardEvent</span> {

}</code></pre>

<h3>Handling content refresh</h3>

<p>With this sealed class in place, we can start to think about using it to represent the different events that can occur. We’re going to start by handling the scenario where we are required to load content into the music dashboard - this will be either for the initial load of the screen or for any refreshes that might occur. We’ll go ahead and declare a new <code>object</code> for a <code>MusicDashboardEvent</code> type, in the form of <code>RefreshContent</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardEvent</span>()

}</code></pre>

<p>With this in place, we now have an instance of the <code>MusicDashboardEvent</code> event that can be used to trigger refresh operations for the data of our dashboard. When this event is triggered, we’re going to want to simulate the loading of dashboard data - so we’re going to create a new function, <code>loadContent</code>. In this function, we’re going to emit a new value to our state where we’ll set several values to the state reference.</p>

<ul>
	<li><strong>status</strong> - because the data has been loaded we’ll set this to the SUCCESS value</li>
	<li><strong>tracks</strong> - we’re not going to be loading data, so we’ll use our <code>ContentFactory</code> to create a list of content, assigning the value of this to the <code>tracks</code> property within the state reference</li>
	<li><strong>nowPlaying</strong> - for the currently playing track, we’re going to use the first track from the created list to create a <code>NowPlaying</code> reference. Again, using our <code>ContentFactory</code> to do so.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">loadContent</span>() {
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeContentList()
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
        status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ResultStatus</span>.<span class="syntax-all syntax-entity">SUCCESS</span>,
        tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">data</span>,
        nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeNowPlaying(<span class="syntax-all syntax-keyword">data</span>[<span class="syntax-all syntax-constant">0</span>])
    )
}</code></pre>

<p>With this function in place, we can now trigger this when the <code>RefreshContent</code>event is triggered. For this we’ll create a new function, <code>handleEvent</code>, that will be used to handle each of the <code>MusicCatalogEvent</code> references that are passed to it. We’ll start here by defining a new <code>when</code> block, triggering our <code>loadContent</code> function when the <code>contentEvent</code> is of the <code>RefreshContent</code> type.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
            <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">RefreshContent</span> <span class="syntax-all syntax-keyword">-&gt;</span> loadContent()
        }
    }

    <span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">loadContent</span>() {
    	<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeContentList()
    	uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
        	status <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ResultStatus</span>.<span class="syntax-all syntax-entity">SUCCESS</span>,
        	tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">data</span>,
        	nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeNowPlaying(<span class="syntax-all syntax-keyword">data</span>[<span class="syntax-all syntax-constant">0</span>])
    	)
	}
}</code></pre>

<h3>Handling search queries</h3>

<p>Alongside the need to refresh the dashboard content, we’re going to be allowing users to search for content within this data. This search operation is also going to be represented by a <code>MusicDashboardEvent</code> event type, so we’ll go ahead and declare a new event in the form of <code>Search</code>. We’re going to need to tie some data to this event, which will be the query which is being performed. This also means that our <code>Search</code> event needs to be in the form of a <code>class</code>, allowing us to declare a constructor with the required arguments.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicDashboardEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicDashboardEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Search</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardEvent</span>()

}</code></pre>

<p>💡 When you don’t require arguments for a sealed class you can use an object for the type. On the other hand, using a class allows you to declare a constructor with any additional information that you require to be tied to that class.</p>

<p>With this even in place, we can now add to our <code>handleEvent</code> function so that the search event is handled accordingly. When it comes to searching through the catalogue, we’re not going to be implementing a complex search method - we’re simply going to check whether the <code>title</code> or <code>artist</code> of a track contains the provided search query. We can implement this using the kotlin <code>filter</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> results <span class="syntax-all syntax-keyword">=</span> uiState.value.tracks<span class="syntax-all syntax-keyword">!!</span>.filter {
    it.title.contains(
		searchTerm, 
		ignoreCase <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	) <span class="syntax-all syntax-keyword">||</span>
	it.artist.contains(
		searchTerm, 
		ignoreCase <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	)
}</code></pre>

<p>We can then take the result of this filter operation and emit it to our state along with the current <code>searchTerm</code>. This is so that we can persist the search term in the search bar of the UI, along with composing the list of tracks from the results of the search.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
            <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">Search</span> <span class="syntax-all syntax-keyword">-&gt;</span> 
				performSearch(contentEvent.searchTerm)
        }
    }

    <span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">performSearch</span>(<span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) {
        <span class="syntax-all syntax-keyword">val</span> results <span class="syntax-all syntax-keyword">=</span> uiState.value.tracks<span class="syntax-all syntax-keyword">!!</span>.filter {
            it.title.contains(
				searchTerm, 
				ignoreCase <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
			) <span class="syntax-all syntax-keyword">||</span>
            it.artist.contains(
				searchTerm, 
				ignoreCase <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
			)
        }
        uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
            searchTerm <span class="syntax-all syntax-keyword">=</span> searchTerm,
            searchResults <span class="syntax-all syntax-keyword">=</span> results
        )
    }
}</code></pre>

<h3>Handling search query clearing</h3>

<p>Because the currently performed search query is going to be set within the state for our screen, it’s going to need to be possible to clear this state from within the UI. When this state is cleared, the search will essentially be reset and the user can be displayed with the initial dashboard state that was in place <strong>before</strong> the search operation was first triggered. We don’t require any additional information for this operation, so we’ll define a new event <code>ClearSearchQuery</code> in the form of an object.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicCatalogEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Search</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> ClearSearchQuery<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

}</code></pre>

<p>When it comes to handling this event, we can simply emit an updated version of our state that sets the value of the <code>searchTerm</code> property to <code>null</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
			...
           	<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">ClearSearchQuery</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    searchTerm <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
                )
            }
        }
    }

    ...
}</code></pre>

<h3>Handling track playback</h3>

<p>Whether data is being loaded into the dashboard or the user has searched for music, each music item is going to be selectable so that it can be played. While we aren’t going to be playing any audio within our project, we’re going to simulate this behaviour so that we can create an audio playback functionality both within our UI and state. So that we can set the audio as playing within our state, we’ll need to start by modelling some events to allow the manipulation of audio behaviour. We’ll start here by allowing an audio item to be played, for which we’ll add a new event in the form of <code>PlayTrack</code>. When an item is being played, we’ll need this information to be tied to an event. Here we’ll do this via a constructor argument in the form of a <code>Track</code> reference. This means that when a track is selected, we’ll have the required information for that track so that we can start the playback flow.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicCatalogEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Search</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> ClearSearchQuery<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

	<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PlayTrack</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

}</code></pre>

<p>When it comes to track playback, we aren’t going to be supporting the playback of media - we’ll instead be faking this within our UI so that we can focus on learning how to build these UI components with Jetpack Compose. To simulate media playback we’re going to utilise a coroutine <code>Job</code> that will allow us to update the currently playing track position every second, simulating the playback of a track.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {
    <span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">var</span> nowPlayingFlow<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Job?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
}</code></pre>

<p>💡A coroutine Job allows us to execute a cancellable task as a background process within our application.</p>

<p>We’ll next need to handle the playback of a track, so we’ll create a new function which will be used to trigger the playback of a track. Before we start playing the newly selected track, we’ll want to begin by cancelling any currently playing track, so we’ll take the current flow reference for media playback and trigger the <code>cancel</code> operation - this will cancel the flow reference and halt any playback process that is currently taking place.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">playMusic</span>() {
    now<span class="syntax-all syntax-entity">PlayingFlow?</span>.cancel()  
}</code></pre>

<p>We’ll next want to mark the current playback state as playing, so we’ll emit a modified version of our state, setting the current status of the now playing reference to <strong>PLAYING</strong>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">playMusic</span>() {
    now<span class="syntax-all syntax-entity">PlayingFlow?</span>.cancel()
    <span class="syntax-all syntax-keyword">val</span> nowPlaying <span class="syntax-all syntax-keyword">=</span> uiState.value.nowPlaying<span class="syntax-all syntax-keyword">!!</span>

    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
        nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying.copy(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>
        )
    )
   
}</code></pre>

<p>Now that the state is set to playing, we’re going to want to simulate some kind of audio playback.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">playMusic</span>() {
    now<span class="syntax-all syntax-entity">PlayingFlow?</span>.cancel()
    <span class="syntax-all syntax-keyword">val</span> nowPlaying <span class="syntax-all syntax-keyword">=</span> uiState.value.nowPlaying<span class="syntax-all syntax-keyword">!!</span>

    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
        nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying.copy(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>
        )
    )
    nowPlayingFlow <span class="syntax-all syntax-keyword">=</span> viewModelScope.launch {
        <span class="syntax-all syntax-keyword">while</span> (isActive) {
            <span class="syntax-all syntax-keyword">val</span> maxLength <span class="syntax-all syntax-keyword">=</span>
				uiState.value.nowPlaying<span class="syntax-all syntax-keyword">!!</span>.track.length
            <span class="syntax-all syntax-keyword">val</span> newPosition <span class="syntax-all syntax-keyword">=</span> 			
				uiState.value.nowPlaying<span class="syntax-all syntax-keyword">!!</span>.position <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>
            <span class="syntax-all syntax-keyword">if</span> (newPosition <span class="syntax-all syntax-keyword">&gt;=</span> maxLength) {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying.copy(
                        state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">STOPPED</span>,
                        position <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>
                    )
                )
                cancel()
            } <span class="syntax-all syntax-keyword">else</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying.copy(
                        state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>,
                        position <span class="syntax-all syntax-keyword">=</span> newPosition
                    )
                )
            }
            delay(<span class="syntax-all syntax-constant">1000</span>)
        }
    }
}</code></pre>

<p>With this function in place, we now can play the selected track. We’ll start here by updating the <code>nowPlaying</code> reference inside of our state reference, followed by triggering the <code>playMusic</code> function that we defined above.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
			...
           	<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">PlayTrack</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeNowPlaying(
						contentEvent.track
					)
                )
                playMusic()
            }
        }
    }

    ...
}</code></pre>

<p>When the view model is torn down, we’ll want to stop any currently playing track - which we can do by again utilising the <code>cancel</code> operation on the job reference. We’ll do this within the <code>onCleared</code> function of the view model, meaning that when the feature is exited, the currently playing track will be cleared.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

	<span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">var</span> nowPlayingFlow<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Job?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>

    <span class="syntax-all syntax-keyword">override</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">onCleared</span>() {
        now<span class="syntax-all syntax-entity">PlayingFlow?</span>.cancel()
        <span class="syntax-all syntax-constant">super</span>.onCleared()
    }

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
			...
           	<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">PlayTrack</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeNowPlaying(
						contentEvent.track
					)
                )
                playMusic()
            }
        }
    }

    ...
}</code></pre>

<p>As well as being able to select a track to be played, the user is also going to be able to toggle a track between the playing and paused state. Because we are going to be toggling between these two states, we’re going to model this as a single <code>ToggleNowPlayingState</code> event. That way, this event can be triggered for either condition, with our state just being toggled to the opposite of what it is currently set to.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicCatalogEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Search</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> ClearSearchQuery<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

	<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PlayTrack</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> ToggleNowPlayingState<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

}</code></pre>

<p>With this event in place, we’re going to create a function that will toggle the current playing status. In this function we’ll want to pause the music when the current <code>nowPlaying</code> state represents the <code>PLAYING</code> state, otherwise the track is currently paused so we’ll want to play the music.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">toggleNowPlayingState</span>() {
    <span class="syntax-all syntax-keyword">if</span> (uiState.value.now<span class="syntax-all syntax-entity">Playing?</span>.state <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>) {
        pauseMusic()
    } <span class="syntax-all syntax-keyword">else</span> {
        playMusic()
    }
}</code></pre>

<p>Within our <code>handleEvent</code> function we can now trigger this new function when the <code>PlayTrack</code> event is being handled.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
			...
           	<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">PlayTrack</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                toggleNowPlayingState()
            }
        }
    }

    ...
}</code></pre>

<p>Along with managing the playback of a track, the user will also be able to perform a seek operation on a track. This means that by using the slider UI component, the user will be able to set the current position of a track by dragging the slider back or forward from the current position. We’ll model this using a <code>SeekTrack</code> class, providing a <code>Float</code> value to represent the current position that has been selected by the user.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicCatalogEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Search</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> ClearSearchQuery<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

	<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PlayTrack</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

	<span class="syntax-all syntax-keyword">object</span> ToggleNowPlayingState<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SeekTrack</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">position</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

}</code></pre>

<p>When it comes to handling the seeking of a track, we’re going to want to update the current state using the <code>position</code> value that is being provided via the <code>SeekTrack</code> event. We’ll use the kitting <code>copy</code> function to update the <code>position</code> value for the current <code>NowPlaying</code> reference, followed by emitting this updated state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
			...
           	<span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">SeekTrack</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    nowPlaying <span class="syntax-all syntax-keyword">=</span> 			
						uiState.value.nowPlaying<span class="syntax-all syntax-keyword">!!</span>.copy(
                    		position <span class="syntax-all syntax-keyword">=</span>
								contentEvent.position.toLong()
                   		)
                )
            }
        }
    }

    ...
}</code></pre>

<p>With this <code>Float</code> value in place, this position can be used to set the current playback position of the track that is being played. Along with setting this playback position using the seek bar component, there is also going to be both a rewind <strong>and</strong> fast forward button within the user interface. These buttons will then be used to either skip forward within the currently playing track or go back to a previous playback position. For these two pieces of functionality, we’re going to model two separate events. Neither of these requires additional information, as the event will just be used to manipulate the current playback position within our state. With this in mind we’ll declare two more events, <code>FastForwardNowPlaying</code> and <code>RewindNowPlaying</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicCatalogEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> RefreshContent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">Search</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">searchTerm</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> ClearSearchQuery<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

	<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PlayTrack</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SeekTrack</span>(<span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">position</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> ToggleNowPlayingState<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> FastForwardNowPlaying<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

	<span class="syntax-all syntax-keyword">object</span> RewindNowPlaying<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>()

}</code></pre>

<p>With these events in place, we can now look at implementing the functions that will be triggered when needing to handle these events. We’ll start with the <code>RewindNowPlaying</code> event, creating a new function called <code>rewindMusic</code>. When it comes to rewinding the track, we’re simply going to rewind by 10 seconds - we’ll want to take the current track <code>position</code> for the track being played, followed by subtracting 10 from it. We’ll want to ensure that we never go below the value of 0, so we’ll also add a safeguard to ensure this doesn’t happen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">rewindMusic</span>() {
    <span class="syntax-all syntax-keyword">val</span> nowPlaying <span class="syntax-all syntax-keyword">=</span> uiState.value.nowPlaying<span class="syntax-all syntax-keyword">!!</span>
    <span class="syntax-all syntax-keyword">val</span> newPosition <span class="syntax-all syntax-keyword">=</span> nowPlaying.position <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">10</span>
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
        nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying.copy(
            position <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (newPosition <span class="syntax-all syntax-keyword">&lt;</span> <span class="syntax-all syntax-constant">0</span>) <span class="syntax-all syntax-constant">0</span> <span class="syntax-all syntax-keyword">else</span> newPosition
        )
    )
}</code></pre>

<p>We’ll then trigger this function whenever we need to handle this event.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
			...
           	<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">RewindNowPlaying</span> <span class="syntax-all syntax-keyword">-&gt;</span> rewindMusic()
        }
    }

    ...
}</code></pre>

<p>When it comes to fast-forwarding the current track, we’re going to do the same as rewinding the track, except we’ll add 10 seconds to the current playback time as opposed to the subtraction of 10 seconds when rewinding. We’ll also want to ensure that we never go above the length of the track when adding 10 seconds, so we’ll also add a safeguard here to ensure that this isn’t possible.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">fastForwardMusic</span>() {
    <span class="syntax-all syntax-keyword">val</span> nowPlaying <span class="syntax-all syntax-keyword">=</span> uiState.value.nowPlaying<span class="syntax-all syntax-keyword">!!</span>

    <span class="syntax-all syntax-keyword">val</span> maxLength <span class="syntax-all syntax-keyword">=</span> nowPlaying.track.length
    <span class="syntax-all syntax-keyword">val</span> newPosition <span class="syntax-all syntax-keyword">=</span> nowPlaying.position <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">10</span>
    uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
        nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying.copy(
            position <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">if</span> (newPosition <span class="syntax-all syntax-keyword">&gt;</span> maxLength) {
				maxLength 
			} <span class="syntax-all syntax-keyword">else</span> newPosition
        )
    )
}</code></pre>

<p>We’ll then trigger this function when handling the fast forward event.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    ...

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">contentEvent</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (contentEvent) {
			...
           	<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">FastForwardNowPlaying</span> <span class="syntax-all syntax-keyword">-&gt;</span>
				fastForwardMusic()
        }
    }

    ...
}</code></pre>

<p>With these two additional events in place, we’ll now be able to support both the fast forward and rewind functionalities within our user interface.</p>

<hr />

<p>With this implemented, we are now managing the state of our music dashboard screen and providing the required entry points for our UI layer to manipulate the state based on user interaction. Our view model is now ready to be plugged into a composable UI, which we’ll create in the next section of this chapter!</p>

<h1>Creating the Music Dashboard UI</h1>

<p>With the view model and state management all in place, we’re ready to move on and start implementing the composable UI for our Messaging app. </p>

<figure><img src="one-3.png"/></figure>

<p>When we’re finished building this UI, we’re going to end up with something that looks like the following:</p>

<figure><img src="both.png"/></figure>

<p>This UI will give our users a screen that displays a list of pre-existing messages, grouped by sticky date headers - the user will also be able to send messages to be added to that list. Building this UI will allow us to work with a range of compose features while adding some subtle niceties to the UI in the process.</p>

<hr />

<h2>Setting up the entry point</h2>

<p>Before we can get start building our project, we’re going to need to add a couple of dependencies that we’re going to need. We’ll start here by adding these to the <code>build.gradle</code> file for our new project:</p>

<pre><code class="code-highlighted code-kt">implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.foundation:foundation:$compose_version&quot;</span>
implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui:$compose_version&quot;</span>
implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material:$compose_version&quot;</span>
implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material-icons-extended:$compose_version&quot;</span>
implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span>
implementation <span class="syntax-all syntax-string">&quot;dev.chrisbanes.snapper:snapper:0.2.0&quot;</span>
implementation <span class="syntax-all syntax-string">&quot;com.google.accompanist:accompanist-flowlayout:0.20.0&quot;</span></code></pre>

<p>The current release of this book is building against 1.1.0 of compose - be sure to check compatibly if using a newer version.</p>

<ul>
	<li><strong>foundation</strong>: provides foundational composables, such as layouts and commonly required modifiers</li>
	<li><strong>ui</strong>: provides access to ui related composables, such as drawing and general components</li>
	<li><strong>material</strong>: provides access to compose material UI components</li>
	<li><strong>material-icons-extended</strong>: provides access to an extended collection of iconography</li>
	<li><strong>lifecycle-viewmodel-compose</strong>: provides functionality for providing view models directly inside of composables</li>
	<li><strong>snapper</strong>: provides utilities for building a collection of items that allows snapping to the nearest item</li>
	<li><strong>flowlayout</strong>: provides a layout that automatically spans children across multiple rows/columns as required</li>
</ul>

<p>With these added to our project, we’re now ready to start building out our UI. We’re going to start here by building the access point to our feature - this is how the messaging feature will initially be composed within our user interface. To make this an argument-less access point, we’re going to start with a new composable function, <code>Messaging</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messaging.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messaging</span>()</code></pre>

<p>While you won’t see anything visual just yet, you’ll want to compose this <code>Messaging</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Messaging</code> when running the project.</p>

<p>Before we get started with any composition of messaging specific UI, we’re going to start by declaring the use of the <code>MaterialTheme</code> composable, this will be in place ready to wrap any composition and apply the expected material theming to our project. This isn’t a requirement, but if not provided then you would need to manually style each composable to adhere to material requirements. We’re not going to be doing any theme customisation here, so this will be using the default colors.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messaging.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messaging</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        ...
    }
}</code></pre>

<p>We can see here that we currently have a blank <code>content</code> block, this means that nothing is currently going to be composed in our UI. As mentioned previously, this is just an argument-less entry point to our feature, but we’re going to need access to the state configuration that we set up over the last few chapters. Here, we’re going to utilise the ViewModel related dependency that we added to our project. Using its <code>viewModel()</code> function, we’ll go ahead and retrieve an instance of the <code>ConversationViewModel</code>. This will return an existing reference to the ViewModel, creating a new one if it does not currently exist.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Messaging.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messaging</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        ...
    }
}</code></pre>

<p>With this in place, we have our ViewModel, as well as access to our state through this ViewModel. Now though, we need to set ourselves up to be able to compose UI based on this state. Here we’re going to create a separate composable function that takes the <code>ConversationState</code> class, composing UI from it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Conversation.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Conversation</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationState</span>
)</code></pre>

<p>💡 Declaring a Modifier argument for your composable functions allows the layout constraints of the composable to be delegated to the parent. This helps to keep your composables reusable, as they are not being constrained for a specific scenario.</p>

<p>Not only does having this separate composable keep the responsibilities of our composable functions smaller, but it also will help us with testing later on. Having this separate <code>Conversation</code> composable with a <code>ConversationState</code> argument means that we can provide state within our tests, and perform asserts based on the expected composition from our state. Testing against an argument-less composable function would require us to interact with the UI to manipulate the state, which adds friction during the testing process.</p>

<p>Now that we have this composable in place, we’re ready to compose this inside of our <code>Messaging</code> composable. We can provide two arguments to our <code>Conversation</code> - <code>modifier</code> and <code>state</code>, which the second is <strong>required</strong>. For the <code>modifier</code>, we’ll simply utilise the <code>fillMaxSize</code> modifier - which will instruct the contained composable to use all of the size that it has available to it.</p>

<p>We’ll also need to provide a reference to a <code>ConversationState</code>, which we’ll access through our <code>ConversationViewModel</code>. Here we’re going to use the <code>collectAsState()</code> - because our state is represented within our ViewModel as a <code>StateFlow</code>, we’re going to want to collect the events from here. <code>collectAsState()</code> allows us to collect the emissions from our <code>StateFlow</code> as composable state, meaning that our composables can be recomposed accordingly whenever the state is changed. We’ll need to access the <code>value</code> from the <code>StateFlow</code> and pass this directly to the <code>state</code> argument of our <code>Conversation</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Messaging</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ConversationViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        <span class="syntax-all syntax-entity">Conversation</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            state <span class="syntax-all syntax-keyword">=</span> viewModel.uiState.collectAsState().value
        )
    }
}</code></pre>

<p>At this point, we won’t be able to see anything being composed within our UI, but we’re all set up and ready to start building out our messaging interface.</p>

<hr />

<h2>Setting up the Dashboard</h2>

<figure><img src="two-2.png"/></figure>

<p>Now that we have our <code>MusicCatalog</code> being composed at the root of our Music Catalog screen, we can start to think about building out the composables that are going to make up the different parts of our catalogue UI. Within this UI we’re going to display a collection of different composable structures, all of which will be contained within a material style layout - consisting of a top bar, bottom bar and content area. As shown by the design of this feature, there are going to be two different content areas - one of which is displayed in a bottom layer, while the other will be displayed in a top layer. To achieve this kind of layout we’re going to utilise the <code>BackdropScaffold</code> composable - this composable allows us to create a material structure, with layered content areas.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BackdropScaffold</span>(
    <span class="syntax-all syntax-parameter">appBar</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">backLayerContent</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">frontLayerContent</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">scaffoldState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">BackdropScaffoldState</span> <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(<span class="syntax-all syntax-entity">Concealed</span>),
    <span class="syntax-all syntax-parameter">gesturesEnabled</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
    <span class="syntax-all syntax-parameter">peekHeight</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Dp</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropScaffoldDefaults</span>.<span class="syntax-all syntax-entity">PeekHeight</span>,
    <span class="syntax-all syntax-parameter">headerHeight</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Dp</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropScaffoldDefaults</span>.<span class="syntax-all syntax-entity">HeaderHeight</span>,
    <span class="syntax-all syntax-parameter">persistentAppBar</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
    <span class="syntax-all syntax-parameter">stickyFrontLayer</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
    <span class="syntax-all syntax-parameter">backLayerBackgroundColor</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primary,
    <span class="syntax-all syntax-parameter">backLayerContentColor</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span> <span class="syntax-all syntax-keyword">=</span> contentColorFor(backLayerBackgroundColor),
    <span class="syntax-all syntax-parameter">frontLayerShape</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Shape</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropScaffoldDefaults</span>.frontLayerShape,
    <span class="syntax-all syntax-parameter">frontLayerElevation</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Dp</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropScaffoldDefaults</span>.<span class="syntax-all syntax-entity">FrontLayerElevation</span>,
    <span class="syntax-all syntax-parameter">frontLayerBackgroundColor</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
    <span class="syntax-all syntax-parameter">frontLayerContentColor</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span> <span class="syntax-all syntax-keyword">=</span> contentColorFor(frontLayerBackgroundColor),
    <span class="syntax-all syntax-parameter">frontLayerScrimColor</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropScaffoldDefaults</span>.frontLayerScrimColor,
    <span class="syntax-all syntax-parameter">snackbarHost</span><span class="syntax-all syntax-keyword">:</span> @<span class="syntax-all syntax-entity">Composable</span> (<span class="syntax-all syntax-entity">SnackbarHostState</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> { <span class="syntax-all syntax-entity">SnackbarHost</span>(it) }
)</code></pre>

<p>Within our <code>Dashboard</code> composable we’re going to start by composing a <code>BackdropScaffold</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Dashboard.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dashboard</span>(
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-entity">BackdropScaffold</span>()
}</code></pre>

<p>When composing a <code>BackdropScaffold</code>, you’ll notice that there are a collection of required arguments - these need to be provided so that we can compile our project. The most important of these required arguments are the <code>BackdropScaffoldState</code> reference - this state is used to hold the current status of the backdrop scaffold. Within this state you’ll see a <code>BackdropValue</code> reference - this can be either the value of <code>Concealed</code> or <code>Revealed</code>, which is used to represent whether the back or front layer is currently in view. We’ll create a new reference to this piece of state using the <code>rememberBackdropScaffoldState</code> function, for which we are required to provide an initial value for the <code>BackdropValue</code> reference. This initial value is the state in which the background scaffold will start, which is a required argument when configuring the state reference.</p>

<p>Now that we have this state configured we can go ahead and provide it for the required <code>scaffoldState</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dashboard</span>(
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
        initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
    )

    <span class="syntax-all syntax-entity">BackdropScaffold</span>(
        scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState
    )
}</code></pre>

<p>Aside from the required state value, we also need to provide composable implementations for the <code>appBar</code>, <code>backLayerContent</code> and <code>frontLayerContent</code> arguments. We’re not going to provide the body for these lambda functions just yet, but we need to provide at least empty implementations so that our code will compile.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dashboard</span>(
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
        initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
    )

    <span class="syntax-all syntax-entity">BackdropScaffold</span>(
        scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
        appBar <span class="syntax-all syntax-keyword">=</span> {
            
        },
        backLayerContent <span class="syntax-all syntax-keyword">=</span> {
            
        },
        frontLayerContent <span class="syntax-all syntax-keyword">=</span> {
            
        }
    )
}</code></pre>

<p>In the next section of this project chapter, we’re going to be composing the track content to be displayed inside of the content area. We’ll want to ensure that the background of this content is the expected color, so we’re going to utilise the <code>backLayerBackgroundColor</code> argument to configure the background color to be used for this content area. Here we’ll use the <code>MaterialTheme</code> class to access the <code>surface</code> color from our theme and apply this to the back layer background color of the <code>BackdropScaffold</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dashboard</span>(
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
        initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
    )

    <span class="syntax-all syntax-entity">BackdropScaffold</span>(
        backLayerBackgroundColor <span class="syntax-all syntax-keyword">=</span>
			<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
        scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
        appBar <span class="syntax-all syntax-keyword">=</span> {
            
        },
        backLayerContent <span class="syntax-all syntax-keyword">=</span> {
            
        },
        frontLayerContent <span class="syntax-all syntax-keyword">=</span> {
            
        }
    )
}</code></pre>

<hr />

<h2>Composing a Track</h2>

<p>Before we go ahead and start composing the different sections of our music dashboard, we’re going to need to compose a representation of each track that is going to be displayed. For this we’ll create a new <code>Track</code> composable, declaring a required argument to pass the corresponding <code>Track</code> reference for the data that is to be composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    
}</code></pre>

<p>For each track, we’re going to create a container that contains the track cover, artist and name - for which we’ll use a collection of different composables. We’ll start here with the container of the <code>Track</code>, for which we’ll utilise the <code>Surface</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
	) {
        
    }
}</code></pre>

<p>💡 The Surface is an elevated Material component that is used to contain prominent information within a user interface. It’s ideal for items within a collection, as it creates a clear visual separation between each item.</p>

<p>When it comes to this <code>Surface</code>, we’re going to shape this with rounded corners. To achieve this effect we’ll utilise the <code>RoundedCornerShape</code> class, allowing us to apply rounding to each of the corners. We’ll apply a corner size of <code>8dp</code> for this, assigning the reference of this shape to the <code>shape</code> argument of the <code>Surface</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { },
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">8</span>.dp)
    ) {
        
    }
}</code></pre>

<p>Now that we have our <code>Surface</code> defined, we’re going to go ahead and configure the contents of it. As we can see by the design, we’re going to be showing the track data in a horizontal arrangement - with the track cover at the start of the surface, followed by the track details at the end. To achieve this layout we’re going to utilise the <code>Row</code> composable, using the <code>fillMaxWidth</code> modifier to ensure this fills all of the horizontal space inside of the parent container.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { },
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RectangleShape</span>
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
        ) {
            
        }
    }
}</code></pre>

<p>We’re now going to build out each of the children that are going to be displayed inside of this <code>Row</code>, starting with the track cover. For this cover we’re going to create a new composable function that can be reused in other parts of our UI, we’ll call this <code>CoverArt</code> - this is also going to need to take a <code>Color</code> reference as an argument to display, which will be taken from the <code>Track</code> that is being composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">CoverArt</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)</code></pre>

<p>For our cover art were simply going to take the provided color, and create a gradient color using another color taken from the theme of our application. Utilising the <code>background</code> modifier, we’ll use the <code>verticalGradient</code> brush function to create this gradient. This function takes a <code>colors</code> argument, which needs to consist of the colors that the gradient is to be created from. Here we’ll pass the <code>primaryVariant</code> color from our theme, along with the <code>color</code> reference that has been passed to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">CoverArt</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .background(
                brush <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Brush</span>.verticalGradient(
                    colors <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(
                        <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primaryVariant,
                        color
                    )
                ),
            )
    )
}</code></pre>

<figure><img src="coverr.png"/></figure>

<p>We can go one step further here and improve the visual representation of our cover slightly. We’ll again use the <code>RoundedCornerShape</code> class to apply a rounded corner effect to our cover art, assigning this to the <code>shape</code> argument of the <code>background</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">CoverArt</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .background(
                brush <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Brush</span>.verticalGradient(
                    colors <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">listOf</span>(
                        <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.primaryVariant,
                        track.cover
                    )
                ),
                shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">6</span>.dp)
            )
    )
}</code></pre>

<p>We can see now that our cover art looks slightly more visually appealing when composed.</p>

<figure><img src="cover.png"/></figure>

<p>With this <code>CoverArt</code> composable now in place, we can go ahead and set this into our <code>Track</code> composable. We’ll add this here as the first child of the contained <code>Row</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { },
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RectangleShape</span>
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
        ) {
            <span class="syntax-all syntax-entity">CoverArt</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">40</span>.dp),
                track <span class="syntax-all syntax-keyword">=</span> track
            )
            
        }
    }
}</code></pre>

<p>At this stage, there isn’t too much to see here, but we can see the initial addition being composed inside of the defined <code>Surface</code>.</p>

<figure><img src="row.png"/></figure>

<p>Next, we need to add the textual details for the <code>Track</code> reference. We’re going to stack these vertically on one another, so we’ll need to utilise the <code>Column</code> composable. Here we’ll use two <code>Text</code> composable to compose both the <code>title</code> and <code>artist</code> properties of the <code>Track</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Column</span> {
	<span class="syntax-all syntax-entity">Text</span>(
		text <span class="syntax-all syntax-keyword">=</span> track.title,
		fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.sp
	)
	<span class="syntax-all syntax-entity">Text</span>(
		text <span class="syntax-all syntax-keyword">=</span> track.artist,
		fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
	)
}</code></pre>

<p>We’ll then take this structure and compose it inside of our <code>Track</code> composable. We’ll also compose a <code>Spacer</code> above this to create some vertical spacing between the <code>CoverArt</code> and <code>Column</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { },
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RectangleShape</span>
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
        ) {
            <span class="syntax-all syntax-entity">CoverArt</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">40</span>.dp),
                track <span class="syntax-all syntax-keyword">=</span> track
            )
            <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">12</span>.dp))
            <span class="syntax-all syntax-entity">Column</span> {
                <span class="syntax-all syntax-entity">Text</span>(
                    text <span class="syntax-all syntax-keyword">=</span> track.title,
                    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.sp
                )
                <span class="syntax-all syntax-entity">Text</span>(
                    text <span class="syntax-all syntax-keyword">=</span> track.artist,
                    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
                )
            }
        }
    }
}</code></pre>

<figure><img src="row2.png"/></figure>

<p>While we now have this information being composed, we can improve things here by creating some visual space within the <code>Track</code> card. We’ll use the <code>padding</code> modifier on the <code>Row</code> composable, creating some visual spacing on both the horizontal and vertical edges.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { },
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RectangleShape</span>
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .padding(
                    horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp,
                    vertical <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
                )
                .fillMaxWidth()
        ) {
            ...
        }
    }
}</code></pre>

<figure><img src="row3.png"/></figure>

<hr />

<h1>Tracks Dashboard</h1>

<figure><img src="three-1.png"/></figure>

<p>Now that we have this <code>Track</code> composable in place, we’re going to start to look at building out the different composables sections that will make up the content of our screen. This content area is going to display the various sections of tracks within our dashboard, which we’ll define in the form of a <code>TracksDashboard</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>All of the content within this dashboard is going to be displayed within a vertically scrolling container - so we’ll go ahead and define the use of a new <code>LazyColumn</code> composable, assigning the <code>Modifier</code> that was provided to our <code>TracksDasboard</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        
    }
}</code></pre>

<h2>Recent tracks</h2>

<figure><img src="one-4.png"/></figure>

<p>With this vertical container composed, we’re going to start to build out the different track sections that are going to be displayed inside of this. We’re going to start here by displaying a title for this section within the container, so we’ll add a new string resource to be used for the title content.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;heading_recently_played&quot;</span>&gt;
	Recently Played
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>With this string resource in place, we can go ahead and add a new <code>item</code> to our <code>LazyColumn</code>, defining the use of a new <code>Text</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        item {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
					<span class="syntax-all syntax-entity">R</span>.string.heading_recently_played),
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
                fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
            )
        }
    }
}</code></pre>

<p>💡 The item function is used to add a new node to a LazyColumn. Each component added to a Lazy composable must be wrapped in this item function, this is so that the composable can be managed Lazily.</p>

<p>For this <code>Text</code> composable we provide the <code>text</code> to be used using the previously defined string resource, along with assigning a <code>fontSize</code> and <code>fontWeight</code> that correspond to that of a title.</p>

<figure><img src="fee.png"/></figure>

<p>💡 If you have configured a material theme for the project then you can also utilise the style argument to assign a title style to the text composable.</p>

<p>You may notice here that currently there is not any spacing around the content of our <code>LazyColumn</code>, things currently feel a little bit cramped. To alleviate this, we’re going to utilise the <code>contentPadding</code> argument of our <code>LazyColumn</code>. This allows us to assign padding to the different edges of the container - which we’ll want to assign specifically to the <code>top</code> and <code>bottom</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, 
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
        item {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
					<span class="syntax-all syntax-entity">R</span>.string.heading_recently_played),
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
                fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
            )
        }
    }
}</code></pre>

<p>We can see here now that there is sufficient spacing for the content of the composable, removing that sense of the children cramped against the top and bottom edges of the composable. We don’t need padding at the end of the composable, as per our designs the width of the tracks will be greater than the width of the text.</p>

<figure><img src="feee.png"/></figure>

<p>Alongside the padding of the parent container, we’re always going to want to assign some spacing to the title <code>Text</code>. Not only can we see that the <code>start</code> of the composable is still pressed against the edge of the screen, but when we add content beneath the title there will also be no spacing present there. For this we’re going to utilise the <code>padding</code> modifier, assigning some padding to both the <code>start</code> and <code>bottom</code> of the <code>Text</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, 
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)   
	) {
        item {
            <span class="syntax-all syntax-entity">Text</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(
					start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, 
					bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
				),
                text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
					<span class="syntax-all syntax-entity">R</span>.string.heading_recently_played),
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
                fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
            )
        }
    }
}</code></pre>

<p>Now that we have the title being displayed for the Recent Tracks section, we’re next going to want to display each of the corresponding <code>Track</code> items that come into this section.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, 
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
        ...
        items(state.recentTracks() ) {
            
        }
    }
}</code></pre>

<p>Each of these tacks is again going to be represented by an <code>item</code> within our <code>LazyColumn</code> - so here we’ll use the <code>items</code> function, providing the recent tracks from our state reference. To access this within our composable function, we’ll need to start by adding support for a <code>MusicDashboardState</code> reference to be provided to our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    ...
}</code></pre>

<p>With this state reference now available we can go ahead and add an <code>item</code> to our <code>LazyColumn</code> for each of these tracks. We’ll go ahead here and use the <code>items</code> function, providing a reference to a list of recent <code>Track</code> references that are to be composed lazily.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, 
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
        ...
        items(state.recentTracks()) {
            
        }
    }
}</code></pre>

<p>When composing this list of items, we’re also going to provide a unique <code>key</code> value. This key is unique to each of the items in the list and is used in the mechanics for lazily composing the contents of the composable. For this key, we’re going to use the <code>id</code> of each <code>Track</code>, as we initially configured this to always be unique.</p>

<pre><code class="code-highlighted code-kt">items(state.recentTracks(), key <span class="syntax-all syntax-keyword">=</span> { it.id }) {
            
}</code></pre>

<p>Next, we’ll go ahead and compose the <code>Track</code> composable that we defined in the previous section. In the case of the recently played tracks, we want this content to fill the entire available space, so we’ll pass in the <code>fillMaxWidth</code> modifier along with the <code>Track</code> reference for the details to be composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, 
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)   
    ) {
        ...
        items(state.recentTracks(), key <span class="syntax-all syntax-keyword">=</span> { it.id }) {
            <span class="syntax-all syntax-entity">Track</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
                track <span class="syntax-all syntax-keyword">=</span> it
            )
        }
    }
}</code></pre>

<p>At this point, we’d now be able to see the vertical list of <code>Track</code> references being composed.</p>

<figure><img src="f.png"/></figure>

<p>While these are available visually, there is currently no interaction available on the track items that are displayed within the list. When the user clicks one of these tracks, we want to trigger ‘playback’ of the selected track - I saw ‘playback’ here because we aren’t going to be implementing the playback of audio, but just simulating the action. To account for this behaviour, we’ll go ahead and add a new argument to the <code>TracksDashboard</code> in the form of a lambda function to pass up interaction events to the parent composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With this in place, we can no use the <code>clickable</code> modifier to trigger this lambda, passing up the selected track to the parent composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, 
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
        ...
        items(state.recentTracks(), key <span class="syntax-all syntax-keyword">=</span> { it.id }) {
            <span class="syntax-all syntax-entity">Track</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
                    .clickable { onTrackClicked(it) },
                track <span class="syntax-all syntax-keyword">=</span> it
            )
        }
    }
}</code></pre>

<p>While this is composing the <code>Track</code> items via accessing the <code>recentTracks()</code> function from our state reference, you might have noticed that the recent tracks list is a nullable field. Because of this, we’re going to want to guard ourselves against any null exceptions occurring during composition. For this we can simply wrap the composition of the recent tracks in an <code>isNullOrEmpty()</code> check, ensuring that we only compose this content when we are not dealing with a null list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp,
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
		<span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>state.recentTracks().isNullOrEmpty()) {
        	item {
            	<span class="syntax-all syntax-entity">Text</span>(
                	text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
						<span class="syntax-all syntax-entity">R</span>.string.heading_recently_played),
                	fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
                	fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
            	)
        	}
        	items(state.recentTracks(), key <span class="syntax-all syntax-keyword">=</span> { it.id }) {
				<span class="syntax-all syntax-keyword">val</span> playTrackDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
                    id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play_track,
                    it.title, it.artist
                )
            	<span class="syntax-all syntax-entity">Track</span>(
                	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
                    	.clickable(
							onClickLabel <span class="syntax-all syntax-keyword">=</span> playTrackDescription
						) { onTrackClicked(it) },
                	track <span class="syntax-all syntax-keyword">=</span> it
            	)
        	}
		}
    }
}</code></pre>

<h3>Improved the Featured Track accessibility</h3>

<p>To ensure that the list of featured tracks is accessible to all users, we’re going o go ahead and improve the accessibility of interaction events on our list of tracks. We’re going to do this by adding a <strong>Click Label</strong> to each track item - as currently when each item comes into focus by the screen reader, the user will not be aware of what the click action on the item will trigger.</p>

<p>To improve this we’re going to add a click label - that way the screen reader can communicate the intention of our click action to the user. Before we add this label we’re going to need to add a new string resource to our project for notifying the user that clicking a track will play it.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_play_track&quot;</span>&gt;Play %s, by %s&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’ll then need to retrieve the string value of the resource using the <code>stringResource</code> function. We’ll assign this to a variable reference, as the <code>onClickLabel</code> can only be provided as a string (and the <code>stringResource</code> function is a composable function).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> playTrackDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
	id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play_track,
	it.title, it.artist
)</code></pre>

<p>We can then use this to apply a value to the <code>onClickLabel</code> of the clickable modifier. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp,
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
		<span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>state.recentTracks().isNullOrEmpty()) {
        	...
        	items(state.recentTracks(), key <span class="syntax-all syntax-keyword">=</span> { it.id }) {
				<span class="syntax-all syntax-keyword">val</span> playTrackDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
                    id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play_track,
                    it.title, it.artist
                )
            	<span class="syntax-all syntax-entity">Track</span>(
                	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
                    	.clickable(
							onClickLabel <span class="syntax-all syntax-keyword">=</span> playTrackDescription
						) { onTrackClicked(it) },
                	track <span class="syntax-all syntax-keyword">=</span> it
            	)
        	}
		}
    }
}</code></pre>

<p>As we can see, this isn’t a required property of the clickable modifier, but for minimal effort, we can increase the accessibility of our composable for screen readers.</p>

<h3>Converting to a composable</h3>

<p>Now that we’ve got our recent tracks being composed inside of our <code>TracksDashboard</code>, we may notice that we’ve now got a fair chunk of code and responsibility inside of this composable function. We’re yet to add the new and featured track sections, which is only going to add more responsibilities to this composable function. To get ourselves off to a good start, we’re going to split out the work we’ve carried out for the recent tracks into a separate and focused composable function.</p>

<p>We’re going to start here by creating a new file, <code>RecentTracks.kt</code>, and creating a new function, <code>RecentTracks</code>. Because we’re going to be utilising the <code>item</code> functions inside of this new function, we’re going to need to scope our function using the <code>LazyListScope</code>. While this means this function will only be used within this scope, it’s a required implementation detail without making things more complicated than they need to be.</p>

<p>This function is going to need the list of <code>Track</code> references that are to be displayed, along with a callback to trigger the click event of a track.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// RecentTracks.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> LazyListScope.<span class="syntax-all syntax-entity">RecentTracks</span>(
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We’re then going to copy all of the code that is related to recent tracks into this function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// RecentTracks.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> LazyListScope.<span class="syntax-all syntax-entity">RecentTracks</span>(
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    item {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(
				start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
			),
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.heading_recently_played),
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
            fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
        )
    }
    items(tracks, key <span class="syntax-all syntax-keyword">=</span> { it.id }) {
        <span class="syntax-all syntax-keyword">val</span> playTrackDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
            id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play_track,
            it.title, it.artist
        )
        <span class="syntax-all syntax-entity">Track</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
                .clickable(
					onClickLabel <span class="syntax-all syntax-keyword">=</span> playTrackDescription
				) { onTrackClicked(it) },
            track <span class="syntax-all syntax-keyword">=</span> it
        )
    }
}</code></pre>

<p>With this in place, we can now replace the existing code from our <code>TracksDashboard</code> composable with our new <code>RecentTracks</code> function, passing in the required arguments.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp,
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
		<span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>state.recentTracks().isNullOrEmpty()) {
        	<span class="syntax-all syntax-entity">RecentTracks</span>(
                tracks <span class="syntax-all syntax-keyword">=</span> state.recentTracks(),
                onTrackClicked <span class="syntax-all syntax-keyword">=</span> onTrackClicked
            )
		}
    }
}</code></pre>

<p>With this in place, we can see how we’ve now split out the responsibility of <strong>recent tracks</strong> into a separate function. This puts us in a much better position when it comes to supporting the other track sections within our UI.</p>

<hr />

<h2>Building the New tracks section</h2>

<figure><img src="two-3.png"/></figure>

<p>As well as displaying the featured tracks within our dashboard, we’re also going to be composing <strong>new tracks</strong> - these are tracks that are new to the user’s library. Similar to the featured tracks, we’re going to need to compose these as part of the <code>LazyColumn</code> within our <code>TracksDashboard</code> composable. We’ll start here by creating a new function, scoped using the <code>LazyListScope</code>. Similar to the <code>RecentTracks</code> function we’ll need to allow a collection of <code>Track</code> references to be provided, along with a listener to detect click events on each of the tracks.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> LazyListScope.<span class="syntax-all syntax-entity">NewTracks</span>(
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Inside of this function, we’re going to also start by composing a title that will section out this <strong>New Tracks</strong> collection. We’ll start here by adding a new string resource that will be used to represent this heading.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;heading_new&quot;</span>&gt;New Tracks&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Using the <code>item</code> function from the <code>LazyListScope</code>, we can use the <code>Text</code> composable to compose this piece of text as an item of the <code>LazyColumn</code>. Alongside styling this to appear as a title within our UI, we’ll also assign some padding to the composable to ensure that there is sufficient spacing at the <code>top</code> and <code>bottom</code> of the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> LazyListScope.<span class="syntax-all syntax-entity">NewTracks</span>(
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    item {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(
				start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
			),
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.heading_new),
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
            fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
        )
    }
}</code></pre>

<p>Now that we have this title in place, we can start to think about composing the items that make up the <strong>New Tracks</strong> section. There’s going to be a bit of code that makes up this UI component, so we’re going to split this out into it a separate composable function in the form of <code>NewTracksRow</code>. This composable is going to take the list of <code>Track</code> references that it needs to compose, along with a callback to be triggered when a <code>Track</code> is clicked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTracksRow</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Because we’re going to compose these <code>Track</code> items in a horizontal fashion, we’re going to utilise the <code>LazyRow</code> composable. We use the <code>LazyRow</code> here instead of the <code>Row</code> as we have no guarantee over the number of items that we’re going to need to display, so being able to lazily compose these helps us to ensure that composition will occur efficiently. We’ll compose a <code>LazyRow</code> within this function, providing a reference to the required <code>state</code> argument using the <code>rememberLazyListState()</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTracksRow</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">LazyRow</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
		state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
    ) {
            
    }
}</code></pre>

<p>You may have noticed that the <code>tracks</code> argument of our composable function is nullable, so we’re going to only want to compose this list of new tracks if the list is not null (and also if it is not empty!). To ensure that these requirements are satisfied we’re going to wrap the composition of this <code>LazyRow</code> in an <code>isNullOrEmpty()</code> check, meaning that the composition will only occur if the list is not null and is not empty.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTracksRow</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">LazyRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
        ) {
            
        }
    }
}</code></pre>

<p>Now that we have the container in place for the <code>Track</code> items, we’re going to want to compose each of the items that are going to be displayed inside of it. Although we previously created a <code>Track</code> composable, we’re now going to create a new composable function that creates the track representation for a <strong>New Track</strong>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// NewTrack.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {

}</code></pre>

<p>We’ll start here by creating a container in the form of a <code>Column</code>, this is going to display the children of our track in a vertical format. Alongside using <code>padding</code> to ensure that there is sufficient spacing within our composable, we’re going to use the <code>widthIn</code> modifier to apply a maximum width that can be occupied by our composable. This is so that each of the <code>NewTrack</code> composables occupies equivalent space within the parent container,</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// NewTrack.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp)
            .widthIn(max <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">120</span>.dp),
    ) {
        
    }
}</code></pre>

<p>Using the provided <code>Track</code> reference, we’ll then compose a <code>CoverArt</code>. We previously set the maximum width of the parent container to <code>120dp</code>, so we’ll allow our <code>CovertArt</code> to fill this space, utilising the equivalent sizing for the height so that the cover art is square.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp)
            .widthIn(max <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">120</span>.dp),
    ) {
        <span class="syntax-all syntax-entity">CoverArt</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth().height(<span class="syntax-all syntax-constant">120</span>.dp),
            track <span class="syntax-all syntax-keyword">=</span> track
        )
    }
}</code></pre>

<figure><img src="cov.png"/></figure>

<p>With the <code>CoverArt</code> in place, we can now add a <code>Text</code> composable that will display the <code>title</code> of our <code>Track</code> reference. We’ll also use a <code>Spacer</code> to ensure that there is sufficient spacing between the composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp)
            .widthIn(max <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">120</span>.dp),
    ) {
        ...
		<span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">6</span>.dp))
		<span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> track.title,
            fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>,
            maxLines <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1</span>,
            overflow <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextOverflow</span>.<span class="syntax-all syntax-entity">Ellipsis</span>,
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.sp
        )
    }
}</code></pre>

<figure><img src="2-26.png"/></figure>

<p>Beneath the title, we’ll use another <code>Text</code> composable to display the <code>artist</code> of the track. We’ll use <code>12sp</code> for the font size here, as the information will be less dominant in our component when compared to the <code>title</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp)
            .widthIn(max <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">120</span>.dp),
    ) {
        <span class="syntax-all syntax-entity">CoverArt</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth().height(<span class="syntax-all syntax-constant">120</span>.dp),
            track <span class="syntax-all syntax-keyword">=</span> track
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">6</span>.dp))
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> track.title,
            fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>,
            maxLines <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1</span>,
            overflow <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextOverflow</span>.<span class="syntax-all syntax-entity">Ellipsis</span>,
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.sp
        )
        <span class="syntax-all syntax-entity">Text</span>(
            text <span class="syntax-all syntax-keyword">=</span> track.artist,
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
        )
    }
}</code></pre>

<figure><img src="3-20.png"/></figure>

<p>When it comes to the accessibility services and the focus on our track component, each child node is going to be focused on and communicated individually. This could end up adding quite a bit of friction when navigating through the <strong>New Track</strong> row using the screen reader, so we’re going to use the <code>semantics</code> modifier to merge the descendants of our composable. This means that when the <code>New Track</code> composable is in focus, the node will be focused and communicated as a single element.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp)
            .widthIn(max <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">120</span>.dp)
            .semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { },
    ) {
        ...
    }
}</code></pre>

<p>Hopping back over the parent <code>NewTracksRow</code> we can now compose a <code>NewTrack</code> for each of the <code>Track</code> references that are passed into our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTracksRow</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">LazyRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
        ) {
            items(tracks) { track <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">NewTrack</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
                    track <span class="syntax-all syntax-keyword">=</span> track
                )
            }
        }
    }
}</code></pre>

<figure><img src="1-26.png"/></figure>

<p>At this point, our <code>Track</code> references are being composed, but the user is not able to interact with them. When creating the <code>NewTracksRow</code> composable function, we allowed an <code>onTrackClicked</code> lambda function to be provided - allowing us to pass up click events on the track children. We’re going to want to trigger this lambda whenever any of the tracks are clicked, so we’ll utilise the <code>clickable</code> modifier on each <code>NewTrack</code> composable, triggering the lambda function for the corresponding <code>Track</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTracksRow</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-keyword">val</span> lazyListState <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
        <span class="syntax-all syntax-entity">LazyRow</span>(
            ...
        ) {
            items(tracks) { track <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">NewTrack</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                        .fillMaxWidth()
                        .clickable {
                            onTrackClicked(track)
                        },
                    track <span class="syntax-all syntax-keyword">=</span> track
                )

            }
        }
    }
}</code></pre>

<h3>Improving the New Track accessibility</h3>

<p>To ensure that the list of featured tracks is accessible to all users, we’re going o go ahead and improve the accessibility of interaction events on our list of tracks. We’re going to do this by adding a <strong>Click Label</strong> to each track item - as currently when each item comes into focus by the screen reader, the user will not be aware of what the click action on the item will trigger.</p>

<p>To improve this we’re going to add a click label - that way the screen reader can communicate the intention of our click action to the user. For this label, we’ll utilise the existing string resource that we defined for the click label in the previous section. We’ll need to retrieve the string value of the resource using the <code>stringResource</code> function, which we’ll then assign to a variable reference because the <code>onClickLabel</code> can only be provided as a string (and the <code>stringResource</code> function is a composable function).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> playTrackDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
	id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play_track,
	track.title, track.artist
)</code></pre>

<p>We can then use this to apply a value to the <code>onClickLabel</code> of the clickable modifier. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTracksRow</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">LazyRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
        ) {
            items(tracks) { track <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-keyword">val</span> playTrackDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
                    id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play_track,
                    track.title, track.artist
                )
                <span class="syntax-all syntax-entity">NewTrack</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                        .fillMaxWidth()
                        .clickable(
							onClickLabel <span class="syntax-all syntax-keyword">=</span> playTrackDescription
						) {
                            onTrackClicked(track)
                        },
                    track <span class="syntax-all syntax-keyword">=</span> track
                )

            }
        }
    }
}</code></pre>

<hr />

<h3>Adding content spacing</h3>

<p>Now that all of our content is being composed, we can see a visual representation of the <strong>New Tracks</strong> within our music catalogue. However, we might currently feel that there is not sufficient spacing around the content of our <code>LazyRow</code>. </p>

<figure><img src="1-27.png"/></figure>

<p>To improve things here we can utilise the <code>contentPadding</code> argument, allowing us to provide padding to be applied around our content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTracksRow</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">LazyRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> rememberLazyListState(),
            contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(<span class="syntax-all syntax-constant">8</span>.dp)
        ) {
            ...
        }
    }
}</code></pre>

<p>With this padding in place, we can now see how there is sufficient spacing around the content of our <code>LazyRow</code> - resulting in a content row that feels less cramped.</p>

<figure><img src="2-27.png"/></figure>

<hr />

<h3>Adding item snapping</h3>

<p>When setting up this project, we declared a dependency for the <strong>snapper</strong> library - this allows us to create a snapping effect when scrolling through content lists. Currently, our <strong>New Tracks</strong> row has no snapping effects present, which results in content not always sitting right when scrolling is stopped or fling gestures are performed. </p>

<p>To improve the experience here, we’re going to plug in the offerings of <strong>snapper</strong>, which is only a few lines of code with a high payoff.</p>

<p>The key to adding a basic implementation of snapper is the use of the <code>rememberSnapperFlingBehavior</code> function, this creates a <code>FlingBehavior</code> that defines how fling gestures are to be handled for our <code>LazyRow</code>. This function comes from <strong>snapper</strong> and implements the complexities of creating this snapping effect. When using this function we’ll need to provide a reference to a <code>LazyListState</code>, which we are already providing to our <code>LazyRow</code>. We’ll pull up the use of this <code>rememberLazyListState</code> function to keep a reference to the <code>LazyListState</code>, passing in this reference when creating the <code>FlingBehavior</code>. We can then pass this <code>FlingBehavior</code> into our <code>LazyRow</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">NewTracksRow</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
		<span class="syntax-all syntax-keyword">val</span> lazyListState <span class="syntax-all syntax-keyword">=</span> rememberLazyListState()
        <span class="syntax-all syntax-entity">LazyRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            state <span class="syntax-all syntax-keyword">=</span> lazyListState,
			flingBehavior <span class="syntax-all syntax-keyword">=</span> rememberSnapperFlingBehavior(lazyListState),
            contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(<span class="syntax-all syntax-constant">8</span>.dp)
        ) {
            ...
        }
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
    }
}</code></pre>

<p>Now when scroll and/or fling gestures are performed, we can see this snapping effect occur. This ensures that a <code>NewTrack</code> composable is always positioned at the start of the visible area for our <code>LazyRow</code>.</p>

<hr />

<h3>Composing the New Tracks</h3>

<p>At this point, we have created our <code>NewTracks</code> composable, and it’s ready to be composed inside of our tracks dashboard. We’ll hop on back over to this parent composable and compose the <code>NewTracks</code> inside of it. When composing <code>NewTracks</code> we’ll need to provide the <code>tracks</code> argument, for which we can use the <code>newTracks()</code> function from our <code>MusicDashboardState</code> reference. We’ll also directly pass in the <code>onTrackClicked</code> lambda function that is being provided to our <code>TracksDashboard</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, 
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
        <span class="syntax-all syntax-entity">NewTracks</span>(
            tracks <span class="syntax-all syntax-keyword">=</span> state.newTracks(),
            onTrackClicked <span class="syntax-all syntax-keyword">=</span> onTrackClicked
        )
		...
    }
}</code></pre>

<p>With this composition now taking place, we have our <code>NewTracks</code> being composed alongside the previously defined <code>RecentTracks</code> composable.</p>

<figure><img src="1-28.png"/></figure>

<hr />

<h2>Building the Featured tracks section</h2>

<figure><img src="three-2.png"/></figure>

<p>As well as displaying the new and recent tracks within our dashboard, we’re also going to be composing <strong>featured tracks</strong> - these are tracks that are currently featured within the music catalogue. Similar to the other track lists, we’re going to need to compose these as part of the <code>LazyColumn</code> within our <code>TracksDashboard</code> composable. We’ll start here by creating a new function, scoped using the <code>LazyListScope</code>. We’ll need to allow a collection of <code>Track</code> references to be provided, along with a listener to detect click events on each of the tracks.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> LazyListScope.<span class="syntax-all syntax-entity">FeaturedTracks</span>(
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>Inside of this function, we’re going to also start by composing a title that will section out this <strong>Featured Tracks</strong> collection. We’ll start here by adding a new string resource that will be used to represent this heading.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;heading_featured&quot;</span>&gt;Featured Tracks&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Using the <code>item</code> function from the <code>LazyListScope</code>, we can use the <code>Text</code> composable to compose this piece of text as an item of the <code>LazyColumn</code>. Alongside styling this to appear as a title within our UI, we’ll also assign some padding to the composable to ensure that there is sufficient spacing at the <code>top</code> and <code>bottom</code> of the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> LazyListScope.<span class="syntax-all syntax-entity">FeaturedTracks</span>(
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    item {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(
				start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp
			),
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 									<span class="syntax-all syntax-entity">R</span>.string.heading_featured),
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
            fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
        )
    }
}</code></pre>

<figure><img src="f-1.png"/></figure>

<p>Now that we have this title in place, we can start to think about composing the items that make up the <strong>Featured Tracks</strong> section. There’s going to be a bit of code that makes up this UI component, so we’re going to split this out into its own composable function in the form of <code>FeaturedTracksGrid</code>. This composable is going to take the list of <code>Track</code> references that it needs to compose, along with a callback to be triggered when a <code>Track</code> is clicked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>To display the grid of featured tracks, we’re going to utilise the <code>LazyVerticalGrid</code> composable which will only compose its children as they are required - making it much more efficient than composing everything at the same time, especially when items may not even be visible to the user. When composing the <code>LazyVerticalGrid</code> we’ll pass the modifier that was provided to our <code>FeaturedTracksGrid</code> composable, along with the required <code>cells</code> argument. This needs to be provided in the form of the <code>GridCells</code> type, which allows us to define how many columns should be applied to our grid. We’re going to use the <code>Fixed</code> type in the form of 2 columns.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-keyword">val</span> itemSize <span class="syntax-all syntax-keyword">=</span> 
			(<span class="syntax-all syntax-entity">LocalConfiguration</span>.current.screenWidthDp.dp <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
        <span class="syntax-all syntax-entity">FlowRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            mainAxisSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SizeMode</span>.<span class="syntax-all syntax-entity">Expand</span>,
            mainAxisAlignment <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">FlowMainAxisAlignment</span>.<span class="syntax-all syntax-entity">SpaceBetween</span>
        ) {
            tracks.forEach { track <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">FeaturedTrack</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                        .width(itemSize)
                        .clickable {
                            onTrackClicked(track)
                        },
                    track <span class="syntax-all syntax-keyword">=</span> track
                )
            }
        }
    }
}</code></pre>

<p>💡 Alongside the Fixed type, the Adaptive type allows us to define a minimum sizing for a column - meaning that we can create more adaptive layouts by allowing our grid columns to adjust based on the available space.</p>

<p>When it comes to the items to be composed within our grid, these need to be composed using the <code>items</code> function provided through the <code>LazyListScope</code> - this is so that a unique key can be provided for each item being composed, allowing the <code>LazyVerticalGrid</code> to correctly manage the current scroll position on the screen. </p>

<p>With that said, we’ll go ahead and utilise the <code>items</code> function - this allows us to provide a list that we wish to compose items from. Along with this list of items being provided, the <code>itemContent</code> block will also be called - this is where we will declare the composition for each item that is being composed within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-keyword">val</span> itemSize <span class="syntax-all syntax-keyword">=</span> 
			(<span class="syntax-all syntax-entity">LocalConfiguration</span>.current.screenWidthDp.dp <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
        <span class="syntax-all syntax-entity">FlowRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            mainAxisSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SizeMode</span>.<span class="syntax-all syntax-entity">Expand</span>,
            mainAxisAlignment <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">FlowMainAxisAlignment</span>.<span class="syntax-all syntax-entity">SpaceBetween</span>
        ) {
            tracks.forEach { track <span class="syntax-all syntax-keyword">-&gt;</span>
                
            }
        }
    }
}</code></pre>

<p>Currently, we don’t have the component to be composed inside of our grid, so we’re going to need to create a new composable. We’ll create this as <code>FeaturedTrack</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    
}</code></pre>

<p>For each track, we’re going to create a container that contains the track cover, artist and name - for which we’ll use a collection of different composables. We’ll start here with the container of the <code>Track</code>, for which we’ll utilise the <code>Surface</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
    ) {
        
    }
}</code></pre>

<p>💡 The Surface is an elevated Material component that is used to contain prominent information within a user interface. It’s ideal for items within a collection, as it creates a clear visual separation between each item.</p>

<p>When it comes to this <code>Surface</code>, we’re going to shape this with rounded corners. To achieve this effect we’ll utilise the <code>RoundedCornerShape</code> class, allowing us to apply rounding to each of the corners. We’ll apply a corner size of <code>8dp</code> for this, assigning the reference of this shape to the <code>shape</code> argument of the <code>Surface</code> composable function. We’ll also apply some <code>elevation</code> to the <code>Surface</code> so that it appears raised within the grid.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">8</span>.dp),
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
    ) {
        
    }
}</code></pre>

<p>Now that we have our <code>Surface</code> defined, we’re going to go ahead and configure the contents of it. As we can see by the design, we’re going to be showing the track data in a horizontal arrangement - with the track cover at the start of the surface, followed by the track title at the end. To achieve this layout we’re going to utilise the <code>Row</code> composable, using the <code>fillMaxWidth</code> modifier to ensure this fills all of the horizontal space inside of the parent container. We’ll also want the contents of the <code>Row</code> to be centered vertically, so we’ll utilise the <code>verticalAlignment</code> argument of the <code>Row</code>, passing the <code>CenterVertically</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp),
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">4</span>.dp),
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            
        }
    }
}</code></pre>

<p>At the start of the <code>FeaturedTrack</code> we’re going to display the cover of the track, so we’ll utilise the <code>CoverArt</code> composable that we created earlier. We’ll use the <code>size</code> modifier to fix this to the size of <code>50dp</code>, followed by passing in the current <code>Track</code> reference for the required <code>track</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp),
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">4</span>.dp),
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            <span class="syntax-all syntax-entity">CoverArt</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">50</span>.dp),
                track <span class="syntax-all syntax-keyword">=</span> track
            )
        }
    }
}</code></pre>

<figure><img src="fe.png"/></figure>

<p>At the end of the <code>CoverArt</code>, we’re going to display the <code>title</code> of the track, so we’ll utilise the <code>Text</code> composable. Alongside providing the title of the current track for the <code>text</code> argument, we’re going to provide a couple of extra properties here.</p>

<ul>
	<li><strong>modifier</strong> - we’ll utilise the <code>padding</code> modifier to ensure that there is sufficient spacing around the composable. This also ensures there is always going to be space between the <code>CoverArt</code> and <code>Text</code> composables, as well as ensuring the <code>Text</code> is not pressed against the end of the <code>Row</code></li>
	<li><strong>fontSize</strong> - we don’t need this text to appear too large, so we’ll set a custom font size of <code>14sp</code></li>
	<li><strong>fontWeight</strong> - the title of the track is the key piece of information for the item, so we’ll want to bolden this text to have it stand out on its surface</li>
	<li><strong>maxLines</strong> - we’ll only want to have the title displayed on a single line within the <code>Row</code>, so we’ll fix this at <code>1</code></li>
	<li><strong>overflow</strong> - because we’ve fixed the <code>maxLines</code> to 1, we’ll want to provide a method to be used when this single line is exceeded. We’ll use the <code>TextOverflow.Ellipsis</code> value here so that ellipsis is used for any text that exceeds this single line</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp),
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">4</span>.dp),
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            <span class="syntax-all syntax-entity">CoverArt</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">50</span>.dp),
                track <span class="syntax-all syntax-keyword">=</span> track
            )
            <span class="syntax-all syntax-entity">Text</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">8</span>.dp),
                maxLines <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1</span>,
                overflow <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextOverflow</span>.<span class="syntax-all syntax-entity">Ellipsis</span>,
                text <span class="syntax-all syntax-keyword">=</span> track.title,
                fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>,
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">14</span>.sp
            )
        }
    }
}</code></pre>

<figure><img src="fee-1.png"/></figure>

<p>When it comes to the accessibility services and the focus on our track component, each child node is going to be focused on and communicated individually. This could end up adding quite a bit of friction when navigating through the <strong>Featured Track</strong> row using the screen reader, so we’re going to use the <code>semantics</code> modifier to merge the descendants of our composable. This means that when the <code>FeaturedTrack</code> composable is in focus, the node will be focused and communicated as a single element - resulting in the track title being read with a single focus gesture.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTrack</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>
) {
    <span class="syntax-all syntax-entity">Surface</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">8</span>.dp),
        shape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RoundedCornerShape</span>(<span class="syntax-all syntax-constant">4</span>.dp),
        elevation <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp
    ) {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth()
                .semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { },
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            ...
        }
    }
}</code></pre>

<h3>Composing the Featured Track</h3>

<p>Now that we’ve created the <code>FeaturedTrack</code> composable, we’re going to want to compose it within our <code>FeaturedTracksGrid</code>. Hopping back over to the <code>FeaturedTracksGrid</code> composable we can compose the <code>FeaturedTrack</code> within the <code>items</code> block of the <code>LazyVerticalGrid</code>. When composing the <code>FeaturedTrack</code> we’ll pass the current <code>Track</code>reference for the item being composed, along with the <code>fillMaxWidth</code> modifier to have the item fill the entire available space on the horizontal axis.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-keyword">val</span> itemSize <span class="syntax-all syntax-keyword">=</span> 
			(<span class="syntax-all syntax-entity">LocalConfiguration</span>.current.screenWidthDp.dp <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
        <span class="syntax-all syntax-entity">FlowRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            mainAxisSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SizeMode</span>.<span class="syntax-all syntax-entity">Expand</span>,
            mainAxisAlignment <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">FlowMainAxisAlignment</span>.<span class="syntax-all syntax-entity">SpaceBetween</span>
        ) {
            tracks.forEach { track <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">FeaturedTrack</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                        .width(itemSize),
                    track <span class="syntax-all syntax-keyword">=</span> track
                )
            }
        }
    }
}</code></pre>

<figure><img src="eeee-1.png"/></figure>

<p>Now that each <code>FeaturedTrack</code> is being composed, we’re going to need to trigger the <code>onTrackClicked</code> lambda that is being provided to our <code>FeaturedTracksGrid</code>. Here we’ll utilise the <code>clickable</code> modifier on each <code>FeaturedTrack</code> composable, triggering the <code>onTrackClicked</code> lambda for the corresponding <code>Track</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!</span>tracks.isNullOrEmpty()) {
        <span class="syntax-all syntax-keyword">val</span> itemSize <span class="syntax-all syntax-keyword">=</span> 
			(<span class="syntax-all syntax-entity">LocalConfiguration</span>.current.screenWidthDp.dp <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
        <span class="syntax-all syntax-entity">FlowRow</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            mainAxisSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">SizeMode</span>.<span class="syntax-all syntax-entity">Expand</span>,
            mainAxisAlignment <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">FlowMainAxisAlignment</span>.<span class="syntax-all syntax-entity">SpaceBetween</span>
        ) {
            tracks.forEach { track <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-entity">FeaturedTrack</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                        .width(itemSize)
                        .clickable {
                            onTrackClicked(track)
                        },
                    track <span class="syntax-all syntax-keyword">=</span> track
                )
            }
        }
    }
}</code></pre>

<h3>Composing the Featured Tracks Grid</h3>

<p>At this point, we now have a <code>FeaturedTracksGrid</code> composable that will display each of the featured track items. If we hop on back over to our <code>FeaturedTracks</code> function, we can now compose the <code>FeaturedTracksGrid</code> within the defined <code>item</code> block. When composing this, we’ll use the <code>fillMaxWidth()</code> modifier to have the grid fill the maximum available width, along with providing the required <code>tracks</code> and <code>onTrackClicked</code> references.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// FeaturedTracks.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> LazyListScope.<span class="syntax-all syntax-entity">FeaturedTracks</span>(
    <span class="syntax-all syntax-parameter">tracks</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    item {
        <span class="syntax-all syntax-entity">Text</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
            text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.heading_featured),
            fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
            fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
        )
        <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            tracks <span class="syntax-all syntax-keyword">=</span> tracks,
            onTrackClicked <span class="syntax-all syntax-keyword">=</span> onTrackClicked
        )
    }
}</code></pre>

<p>With the <code>FeaturedTracks</code> composable implementation now complete, we can now compose this within the parent <code>LazyColumn</code>. Here we’ll need to hop on back over to our <code>TracksDashboard</code>, composing the <code>FeaturedTracks</code> using the <code>featuredTracks()</code> from the <code>MusicDashboardState</code> state references and the <code>onTrackClicked</code> lambda provided to the <code>TracksDashboard</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// TracksDashboard.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">LazyColumn</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
			top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, 
			bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
		)
    ) {
        <span class="syntax-all syntax-entity">FeaturedTracks</span>(
            tracks <span class="syntax-all syntax-keyword">=</span> state.featuredTracks(),
            onTrackClicked <span class="syntax-all syntax-keyword">=</span> onTrackClicked
        )
        ...
    }
}</code></pre>

<figure><img src="er.png"/></figure>

<p>With the featured tracks now in place, we now have three different categories of tracks being composed inside of our Dashboard. These three tracks together give us a combination of different nested layouts, with multiple scroll directions being supported while browsing the catalogue.</p>

<hr />

<h2>Adding a Search bar</h2>

<figure><img src="search.png"/></figure>

<p>Now that we have tracks being composed inside of our dashboard, we can see that there could be a lot of content on display. We could help users find a track in the catalogue quicker by supporting search - this would allow the user to search for a track and have the results displayed within the UI. For this we’re going to need to build two parts - the search bar used to enter a search query, along with the list which will display the search results.</p>

<p>We’re going to start by creating the search bar which will be used to enter the search query. We’ll create a new composable function, <code>SearchBar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SearchBar.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) {

}</code></pre>

<p>When it comes to the search query that has been input by the user, this is going to affect multiple parts of our UI.</p>

<ul>
	<li>The search bar itself will need to display the query that has been input by the user</li>
	<li>The results list within the dashboard will need to display the results based on the query that has been entered</li>
</ul>

<p>Because this search query affects multiple children within our feature, we previously defined this query string within the global screen state, which is our <code>MusicDashboardState</code> reference. For this reason, we’re going to declare an argument for our composable function in the form of this query string.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SearchBar.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>
)</code></pre>

<p>Using this query string, we’re then going to compose a <code>TextField</code>, assigning its <code>value</code> to the <code>query</code> string that is being provided to this function. Because this <code>query</code> value is also nullable in our state, we’ll assign a default value of an empty string for when this is null.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SearchBar.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>
) {
   <span class="syntax-all syntax-entity">TextField</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> query <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
        onValueChange <span class="syntax-all syntax-keyword">=</span> {

        }
    )
}</code></pre>

<figure><img src="1-29.png"/></figure>

<p>While we are composing the search query value within our <code>TextField</code>, typing into this field won’t currently have any effect - this is because we currently have an empty <code>onValueChange</code> block. Because this query string is being managed at the global level for our screen, we’re going to need to pass up any change events so that the state can be updated accordingly. We’ll add a new lambda function argument to our composable function, triggering this within the <code>onValueChange</code> block and passing up the updated value to be assigned to our state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
	<span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TextField</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        value <span class="syntax-all syntax-keyword">=</span> query <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
        onValueChange <span class="syntax-all syntax-keyword">=</span> {
            handleQuery(it)
        }
    )
}</code></pre>

<h3>Limiting the line length</h3>

<p>Currently, when entering text into the input field, a new line will be started once the input text reaches the width of the input field. When this happens, the height of the input field will be expanded to adapt to the number of lines that have been entered.</p>

<figure><img src="line_1.png"/></figure>

<p>This isn’t an expected behaviour for search bars, so we’re going to use the <code>singleLine</code> argument of the <code>TextField</code> to limit this input to a single line. This won’t prevent the user from typing as much content as they’d like, but instead, it will keep the input on a single line instead of breaking onto new lines once the width has been reached.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
	<span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TextField</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
		singleLine <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
        value <span class="syntax-all syntax-keyword">=</span> query <span class="syntax-all syntax-keyword">?:</span> <span class="syntax-all syntax-string">&quot;&quot;</span>,
        onValueChange <span class="syntax-all syntax-keyword">=</span> {
            handleQuery(it)
        }
  	)
}</code></pre>

<figure><img src="line_2.png"/></figure>

<h3>Styling the Search Bar</h3>

<p>We’re going to add a few modifications to the search bar that we’ve created, in the form of the <code>colors</code> argument. Using this we can style how the search bar is composed - we’ll pass values for the following arguments to style the bar:</p>

<ul>
	<li><strong>backgroundColor</strong> - the color to be used for the background of the search bar</li>
	<li><strong>focusedIndicatorColor</strong> - the door to be used for the indicator when in focus</li>
	<li><strong>unfocusedIndicatorColor</strong> - the color to be used for the indicator when the bar is <strong>not</strong> in focus</li>
</ul>

<p>So that our theme is adhered to, we’ll use a modified version of the <code>onSurface</code> color from our theme for the indicator colors. We’ll also modify the background of the bar so that the <code>surface</code> color of our theme is applied.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
	<span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
        <span class="syntax-all syntax-entity">TextField</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            colors <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextFieldDefaults</span>.textFieldColors(
                backgroundColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
                focusedIndicatorColor <span class="syntax-all syntax-keyword">=</span> 	
					<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(
						alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.6f</span>),
                unfocusedIndicatorColor <span class="syntax-all syntax-keyword">=</span> 									<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(
						alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.4f</span>),
            ),
            ...
        )
}</code></pre>

<hr />

<h3>Trailing Icon</h3>

<p>Currently, our <code>TextField</code> is being used to display the search query that has been entered by the user. </p>

<figure><img src="1-30.png"/></figure>

<p>During performing a query, it might be the case that the user wants to clear the query from the input field. To offer this functionality (and to avoid the user having to manually delete the input via the keyboard), we’re going to add a trailing icon to the input field so that the text can be cleared upon request. This clear operation is being handled within our ViewModel which manages the global state, so we’ll need to pass up this <strong>clear</strong> event to the parent composable. For this purpose, we’ll add a new lambda function, <code>clearQuery</code>, as an argument for our composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>With this in place, we can now move on to composing the component that will be used to trigger this function. For the <code>trailingIcon</code> block we’re going to compose an <code>IconButton</code>, this will be used to provide an interactable component to clear the search query. For the <code>onClick</code> argument of this composable, we’ll simply want to trigger the <code>onClick</code> lambda that is provided to the <code>SearchBar</code> composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TextField</span>(
        ...,
        trailingIcon <span class="syntax-all syntax-keyword">=</span> {
        	<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
            	clearQuery()
            }) {

            }
        }
    )
}</code></pre>

<p>While we’ve implemented the required <code>onClick</code> argument, this <code>IconButton</code> composable currently has an empty body, so it has no visual representation on-screen. We can change this by composing a new <code>Icon</code> within our <code>IconButton</code>, using the <code>Icons.Default.Clear</code> icon for the <code>imageVector</code> argument. This gives us an icon that represents a ‘clear’ action.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TextField</span>(
        ...,
        trailingIcon <span class="syntax-all syntax-keyword">=</span> {
        	<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
            	clearQuery()
            }) {
            	<span class="syntax-all syntax-entity">Icon</span>(
                	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Clear</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
                }
            }
        }
    )
}</code></pre>

<figure><img src="55-1.png"/></figure>

<p>We’ve initially provided a <code>null</code> value for the <code>contentDescription</code> of our <code>Icon</code>, but we’ll want to provide an actual description resource here so that the component is accessible for all users. We’ll start here by adding a new string to our <code>strings.xml</code> file that describes the action to be triggered by this icon. </p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_clear_query&quot;</span>&gt;Clear query&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>💡Content Descriptions allow us to provide a textual description for visual elements, used by accessibility services to provide additional context to users.</p>

<p>We can then use the <code>stringResource</code> function to retrieve the string representation of this resource value, assigning it to the <code>contentDescription</code> of our <code>Icon</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TextField</span>(
        ...,
        trailingIcon <span class="syntax-all syntax-keyword">=</span> {
        	<span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
            	clearQuery()
            }) {
            	<span class="syntax-all syntax-entity">Icon</span>(
                	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Clear</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span>
						stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_clear_query)
                    )
                }
            }
        }
    )
}</code></pre>

<p>At this point, we’ve added the clear action to our input field, but it won’t always be appropriate for us to display this action. For example, if there is no content currently present as a search query, then it wouldn’t make sense for us to display that as an action to the user. For when there is no content present, we’re going to want to display a different icon to the user - this will be when there is no content currently input as a search query, which will be when there is currently no focus on the input field.</p>

<p>We’re going to start here by using the provided query argument to depict which icon should be composed, as we’ll only want to compose the existing ‘clear’ <code>IconButton</code> if there is currently no search query present.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TextField</span>(
        ...,
        trailingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-keyword">if</span> (query.isNullOrEmpty()) {
                
            } <span class="syntax-all syntax-keyword">else</span> {
                <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
            		clearQuery()
            	}) {
            		<span class="syntax-all syntax-entity">Icon</span>(
                		imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Clear</span>,
                    	contentDescription <span class="syntax-all syntax-keyword">=</span>
							stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_clear_query)
                    	)
                	}
            	}
            }
        }
    )
}</code></pre>

<p>Now that we have this conditional logic configured, we’re ready to compose the <code>Icon</code> to represent the empty search state. We’ll utilise the <code>Icons.Default.Search</code> icon here, passing it to our composable for composition. Because our icon is purely for decoration, in this case, we don’t need to provide a content description so we’ll pass <code>null</code> for this argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">TextField</span>(
        ...,
        trailingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-keyword">if</span> (query.isNullOrEmpty()) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Search</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
                )
            } <span class="syntax-all syntax-keyword">else</span> {
                ...
            }
        }
    )
}</code></pre>

<p>💡Content Descriptions are used to provide descriptions for components that provide value to users. We don’t need to provide descriptions for components that are purely for decoration unless they provide some form of value to the user.</p>

<p>With this in place, we now have a search icon being composed when there is no search query present in the input field.</p>

<figure><img src="ss.png"/></figure>

<h3>Managing Focus</h3>

<p>When the user interacts with the search bar, it gains focus - this means that it is currently in the state of being selected by the user. When this happens, the input field enters ‘input’ mode and the user can enter a search query. When the component loses focus, the expectation would be that the component changes its visual state, no longer displaying the ‘clear’ action that we previously configured. However, when composing this, we only configured this to check whether the search query was currently empty or not. To match the expected behaviour here, we’re also going to take into account the current focus state of the component. This means that when the component comes out of focus, the search icon will be displayed</p>

<p>To implement this behaviour, we’re going to need to start by configuring a couple of variables.</p>

<ul>
	<li> First of all, we need to keep track of whether our search bar currently has focus. For this, we’ll create a mutable piece of state that will be persisted across compositions. This state can remain local to this composable, as it is not required by any other components.</li>
	<li>Secondly, we’ll need to create a new reference for the <code>FocusRequester</code> class. This will allow us to manage the focus state of our search bar.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> inputHasFocus <span class="syntax-all syntax-keyword">=</span> remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }
    <span class="syntax-all syntax-keyword">val</span> focusRequester <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FocusRequester</span>()
    ...
}</code></pre>

<p>With these fields in place, we now need to configure both of these within our composable. We’ll use the <code>focusRequester</code> modifier to assign this <code>FocusRequester</code> reference to our composable, along with utilising the <code>onFocusChanged</code> modifier - this will be used to listen for focus changes on our composable. Whenever there is a focus change we’ll want to set the current focus value to our <code>inputHasFocus</code> state, allowing us to keep a reference to whether the composable is currently in focus. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> inputHasFocus by remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }
    <span class="syntax-all syntax-keyword">val</span> focusRequester <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FocusRequester</span>()
    <span class="syntax-all syntax-entity">TextField</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .focusRequester(focusRequester)
            .onFocusChanged {
                inputHasFocus.value <span class="syntax-all syntax-keyword">=</span> it.hasFocus
            },
        ...
    )
}</code></pre>

<p>Now that we have the current focus state of our composable configured, we can go ahead and use it within the composition of the search bar. We previously added some conditional logic that means the <code>trailingIcon</code> will only display the ‘clear’ icon when the <code>query</code> argument is null or empty. We’re going to modify this logic so that the above outcome will also occur if the input field does not currently have focus - as well as adding the behaviour to clear the focus when the user clicks the ‘clear’ icon. We want this behaviour because without removing the current focus from the input field, the component will always appear focused and in ‘search’ mode - even when the user is interacting with other components on the screen.</p>

<p>To implement this focus clearing, we’ll need to retrieve a reference to the current <code>FocusManager</code> - this will allow us to perform operations related to focus management. We need to change two things here when it comes to the <code>TextField</code>.</p>

<ul>
	<li>We’ll first need to modify the conditional logic for the <code>trailingIcon</code> so that alongside the <code>query</code> being null or empty, the ‘search’ icon will also only show if the input field does not currently have focus. If the field currently has focus, we want to show the ‘clear’ icon so that the focus can be manually cleared.</li>
	<li>Next up we’ll want to modify the <code>onClick</code> implementation for the ‘clear’ <code>IconButton</code>. When this button is clicked, we’ll want to clear the focus from the input field. For this we’ll use the <code>FocusManager</code> reference that we’ve retrieved, utilising the <code>freeFocus</code> function to clear the focus from the input field.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">var</span> inputHasFocus by remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }
    <span class="syntax-all syntax-keyword">val</span> focusRequester <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FocusRequester</span>()
	<span class="syntax-all syntax-keyword">val</span> focusManager <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalFocusManager</span>.current

    <span class="syntax-all syntax-entity">TextField</span>(
        ...
        trailingIcon <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-keyword">if</span> (
				query.isNullOrEmpty() <span class="syntax-all syntax-keyword">&amp;&amp;</span> 
					<span class="syntax-all syntax-keyword">!in</span>putHasFocus
			) {
                ...
            } <span class="syntax-all syntax-keyword">else</span> {
                <span class="syntax-all syntax-entity">IconButton</span>(onClick <span class="syntax-all syntax-keyword">=</span> {
                    focusRequester.freeFocus()
                    clearQuery()
                }) {
                    ...
                }
            }
        }
    )
}</code></pre>

<p>With the above in place, we have better focus management in place for the input field. This configuration now allows the user to remove focus from the field when they are no longer performing a search query, providing better clarity for the current state of the screen.</p>

<h3>Search Hint</h3>

<p>Now that we have the focus management in place, we can utilise this to add a hint to the search field. While the <code>TextField</code> composable supports a label to describe the required input, we’re going to implement this ourselves so that the label does not toggle between a floating state.</p>

<figure><img src="query.png"/></figure>

<p>We’re going to implement this by having a <code>Text</code> composed on top of the existing <code>TextField</code>, this will allow us to show/hide the overlaying <code>Text</code> composable based on whether it needs to be displayed or not. So that we can have this overlapping effect, we’re going to start by defining the use of a <code>Box</code> composable and wrapping the existing <code>TextField</code>. Because we’re placing multiple child nodes inside of the <code>Box</code> we’re going to want to ensure that these are aligned correctly - so we’ll utilise the <code>contentAlignment</code> argument to align the components at the horizontal start and vertical centre of the container space.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	...
    <span class="syntax-all syntax-entity">Box</span>(
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterStart</span>
    ) {
        ...
        <span class="syntax-all syntax-entity">TextField</span>(
			...
		)
    }
}</code></pre>

<p>With this <code>Box</code> now in place, we can add the hint message to be displayed to the user. We’re going to start by adding a new string to our <code>strings.xml</code> file that will represent this hint.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;hint_search&quot;</span>&gt;
	Search for a track, artist or album…
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Now that we have this hint, we can go ahead and compose it inside of the <code>Box</code>. After the composition of the <code>TextField</code>, we’ll compose a <code>Text</code> when the input field does not currently have focus and there is no search query present. This is because if the user is already focused on the input field, or they have already started entering a search query, then they don’t need to see the hint. When composing the <code>Text</code> we’ll provide the previously defined <code>hint_search</code> resource for the <code>text</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> inputHasFocus <span class="syntax-all syntax-keyword">=</span> remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }
    <span class="syntax-all syntax-keyword">val</span> focusRequester <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FocusRequester</span>()
    <span class="syntax-all syntax-entity">Box</span>(
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterStart</span>
    ) {
        <span class="syntax-all syntax-entity">TextField</span>(...)
        <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!in</span>putHasFocus.value <span class="syntax-all syntax-keyword">&amp;&amp;</span> query.isNullOrEmpty()) {
            <span class="syntax-all syntax-entity">Text</span>(
                text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.hint_search)
            )
        }
    }
}</code></pre>

<figure><img src="new.png"/></figure>

<p>While the hint is being composed, it feels as though we are missing a few stylistic properties. First of all, there is insufficient spacing around the composable, as well as the hint being too prominent within the component. A hint should be subtle, so as not to take all of the attention within the user interface. So aside from providing the <code>text</code> value to be composed, we’ll also provide some padding using the corresponding <code>padding</code> modifier, along with overriding the default <code>color</code> of the composed text. For this color, we’re going to take the existing <code>onSurface</code> color from our theme and apply a new <code>alpha</code> value. We want to keep the text color of the hint with the theme of our application, but applying this alpha helps to make it a less prominent part of our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">query</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String?</span>,
    <span class="syntax-all syntax-parameter">handleQuery</span><span class="syntax-all syntax-keyword">:</span> (query<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">clearQuery</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> inputHasFocus <span class="syntax-all syntax-keyword">=</span> remember { mutableStateOf(<span class="syntax-all syntax-constant">false</span>) }
    <span class="syntax-all syntax-keyword">val</span> focusRequester <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FocusRequester</span>()
	<span class="syntax-all syntax-keyword">val</span> onSurfaceWithAlpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors.onSurface.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.4f</span>)
    <span class="syntax-all syntax-entity">Box</span>(
        contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterStart</span>
    ) {
        <span class="syntax-all syntax-entity">TextField</span>(...)
        <span class="syntax-all syntax-keyword">if</span> (<span class="syntax-all syntax-keyword">!in</span>putHasFocus.value <span class="syntax-all syntax-keyword">&amp;&amp;</span> query.isNullOrEmpty()) {
            <span class="syntax-all syntax-entity">Text</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp),
                color <span class="syntax-all syntax-keyword">=</span> onSurfaceWithAlpha,
                text <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.hint_search)
            )
        }
    }
}</code></pre>

<p>💡Even though we are modifying the alpha of a color from our theme, we are still accessing the color from the theme of our application. This helps to ensure that the color of the text for our hint remains consistent with the rest of the text color within our application.</p>

<figure><img src="neww.png"/></figure>

<h3>Composing the Search Bar</h3>

<p>Our search bar is now implemented in a visual sense, but it’s not yet functional within our UI. Here we first need to compose this within our <code>Dashboard</code> composable, plugging it into the <code>appBar</code> of our <code>BackdropScaffold</code>. Here we’ll compose the <code>SearchBar</code>, providing the following for each of its functions arguments.</p>

<ul>
	<li>For the modifier, we’ll utilise the <code>fillMaxWidth</code> modifier, as this will allow the search bar to fill the maximum available width.</li>
	<li>The query to be displayed within the search bar is going to come from our <code>MusicDashboardState</code> reference, so we’ll pass this directly in for the <code>query</code> argument.</li>
	<li>The <code>handleQuery</code> implementation is used to handle when the search query input is changed. When this is triggered, we’ll want to utilise the <code>MusicCatalogEvent.Search</code> event to update the state contained within our ViewModel.</li>
	<li>The <code>clearQuery</code> implementation is being triggered when the ‘clear’ icon within our <code>SearchBar</code> is interacted with. In this case, we’ll want to clear the search query from our state, so we’ll trigger the <code>MusicCatalogEvent.ClearSearchQuery</code> event in these cases to update the state within our ViewModel.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dashboard</span>(
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>
) {
    <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
        initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
    )

    <span class="syntax-all syntax-entity">BackdropScaffold</span>(
        backLayerBackgroundColor <span class="syntax-all syntax-keyword">=</span>
			<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
        scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
        appBar <span class="syntax-all syntax-keyword">=</span> {
        	<span class="syntax-all syntax-entity">SearchBar</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
                query <span class="syntax-all syntax-keyword">=</span> state.searchTerm,
                handleQuery <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">Search</span>(it))
                },
                clearQuery <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(
						<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">ClearSearchQuery</span>)
                }
            )
        },
        backLayerContent <span class="syntax-all syntax-keyword">=</span> {
			...
        },
        frontLayerContent <span class="syntax-all syntax-keyword">=</span> {
            
        }
    )
}</code></pre>

<p>Now with the <code>SearchBar</code> being composed, we can see the input bar being composed at the top of our <code>Scaffold</code>.</p>

<figure><img src="search-1.png"/></figure>

<hr />

<h2>Displaying search results</h2>

<figure><img src="one-5.png"/></figure>

<p>Alongside the user being able to utilise the search bar to find content within the music catalogue, we’re going to want to display the search results based on the query that has been entered into the input field. We’re going to show these search results within our <code>TracksDashboard</code> composable - as here we’re either going to want to display the music catalogue content or the results of the search query.</p>

<p>We’ll start here by adding a conditional statement to our <code>TracksDashboard</code>. If there is currently no search term within the <code>MusicDashboardState</code> then this means that there has been no search query entered. In this case, we’ll want to compose the <code>LazyColumn</code> that represents the music catalogue, otherwise, we’ll want to compose the results of the search.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// TracksDashboard.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (state.searchTerm.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">LazyColumn</span> {
            ...
        }
    } <span class="syntax-all syntax-keyword">else</span> {
        
    }
}</code></pre>

<p>In this else block we’re going to want to compose the search results for the current query. We’re going to house this within a new compose, so we’ll create a new composable function called <code>SearchResults</code>. This is going to take a list of tracks that represents the results of the current search, along with a lambda function that will be used to handle click events on any of the track items.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchResults</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">results</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<h3>Handling Empty results</h3>

<figure><img src="two-4.png"/></figure>

<p>When there are tracks present in the list, we’re going to want to compose the results within this <code>SearchResults</code> composable, otherwise, we’re going to want to compose an empty results message on-screen. To account for these rules, we’ll start by adding a null/empty check for the provided tracks list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchResults</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">results</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (results.isNullOrEmpty()) {
        
    }
}</code></pre>

<p>When the results list is null or empty, we’ll compose a message on-screen to let the user know that no results were found for the given query. We’ll start by adding a new resource that represents this message to our <code>strings.xml</code> file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;message_search_results&quot;</span>&gt;
	No results to display
&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Next, we’ll compose a <code>Text</code> composable that will compose this message. We’ll also wrap this composition in a <code>Box</code> that utilises the modifier passed to the <code>SearchResults</code> composable function, aligning the <code>Text</code> child node in the center of its space.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchResults</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">results</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (results.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.message_search_results))
        }
    } <span class="syntax-all syntax-keyword">else</span> {
        
    }
}</code></pre>

<figure><img src="bbb.png"/></figure>

<h3>Composing the Search results</h3>

<figure><img src="res.png"/></figure>

<p>Now that we have the empty case handled, we’re next going to want to compose the search results using the provided list of <code>Track</code> references.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchResults</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">results</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (results.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.message_search_results))
        }
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
        ) {
            
        }
    }
}</code></pre>

<p>For the search results, we’re going to re-use the <code>Track</code> composable that we created previously for this project. </p>

<figure><img src="ress.png"/></figure>

<p>This <code>Track</code> composable is going to be used to make up the results of the query, so we’ll utilise this within the <code>items</code> block of the specified <code>LazyColumn</code>. When composing each <code>Track</code> we’ll utilise the <code>fillMaxWidth</code> modifier to ensure that the entire available width is occupied, along with providing the current <code>Track</code> search result reference for the <code>track</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchResults</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">results</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (results.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.message_search_results))
        }
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
        ) {
            items(results) {
                <span class="syntax-all syntax-entity">Track</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
                    track <span class="syntax-all syntax-keyword">=</span> it
                )
            }
        }
    }
}</code></pre>

<p>With the above in place, we now have the search results being composed within our <code>SearchResults</code> composable, along with a message when there are no results to display.</p>

<figure><img src="bb-2.png"/></figure>

<p>The last thing to do here is to add click support to the search results, allowing the user to play a track when selecting one of the results. Similar to how we’ve approached other click events in this project, we’ll start by adding a click action description to our <code>strings.xml</code> resources file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;action_select_track&quot;</span>&gt;Play %s&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Next up we’ll go ahead and utilise the <code>clickable</code> modifier to allow click events to be triggered on each of the <code>Track</code> references. When this click action is triggered, we’ll go ahead and trigger the <code>onTrackClicked</code> lambda that is provided to our <code>SearchResults</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchResults</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">results</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (results.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.message_search_results))
        }
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
        ) {
            items(results) {
                <span class="syntax-all syntax-keyword">val</span> selectTrackAction <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
					<span class="syntax-all syntax-entity">R</span>.string.action_select_track, it.title)
                <span class="syntax-all syntax-entity">Track</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                        .fillMaxWidth()
                        .clickable(
							onClickLabel <span class="syntax-all syntax-keyword">=</span> selectTrackAction
						) {
                            onTrackClicked(it)
                        },
                    track <span class="syntax-all syntax-keyword">=</span> it
                )
            }
        }
    }
}</code></pre>

<p>As a final tweak to the search results list, we’ll go ahead and utilise the <code>contentPadding</code> argument for the <code>LazyColumn</code> - allowing us to apply some padding to the displayed content, which now has sufficient spacing around its edges.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">SearchResults</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">results</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt;?,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (results.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            contentAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Center</span>
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
				<span class="syntax-all syntax-entity">R</span>.string.message_search_results))
        }
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(
				top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp
			)
        ) {
            items(results) {
                <span class="syntax-all syntax-keyword">val</span> selectTrackAction <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
					<span class="syntax-all syntax-entity">R</span>.string.action_select_track, it.title)
                <span class="syntax-all syntax-entity">Track</span>(
                    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                        .fillMaxWidth()
                        .clickable(
							onClickLabel <span class="syntax-all syntax-keyword">=</span> selectTrackAction
						) {
                            onTrackClicked(it)
                        },
                    track <span class="syntax-all syntax-keyword">=</span> it
                )
            }
        }
    }
}</code></pre>

<p>With this in place, we now have a <code>SearchResults</code> composable that will display a list of given tracks on-screen, based on the current search query that is within our state.</p>

<p>All that’s left to do now is to compose this <code>SearchResults</code> within our dashboard. Hopping back over to our <code>TracksDashboard</code> composable, we will compose the <code>SearchResults</code> in the <code>else</code> block of the conditional check that we implemented based on the current search term from our <code>MusicDashboardState</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// TracksDashboard.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">TracksDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">onTrackClicked</span><span class="syntax-all syntax-keyword">:</span> (track<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">if</span> (state.searchTerm.isNullOrEmpty()) {
        <span class="syntax-all syntax-entity">LazyColumn</span>(
            ...
        ) {
            ...
        }
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">SearchResults</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier.fillMaxWidth(),
            results <span class="syntax-all syntax-keyword">=</span> state.searchResults,
            onTrackClicked <span class="syntax-all syntax-keyword">=</span> { track <span class="syntax-all syntax-keyword">-&gt;</span>
                onTrackClicked(track)
            }
        )
    }
}</code></pre>

<figure><img src="results.png"/></figure>

<hr />

<h2>Building the Music Playback components</h2>

<figure><img src="l.png"/></figure>

<p>At this point, we have a music dashboard that will display a catalogue of tracks to the user, along with allowing them to search for a track within the catalogue. While these tracks can be viewed, there isn’t any other functionality - we’ve added click listeners to each of the tracks that are composed within our UI, but the result of those click listeners doesn’t currently trigger anything within our UI. In this section, we’re going to create a fake music player component, which will show the currently playing track to the user.</p>

<p>This music player component is going to take two different forms - both a full-screen form and a collapsed form, representing a bottom bar player while the user is browsing the music catalogue.</p>

<h3>Creating the Player Bottom Bar</h3>

<p>When the user is browsing the music catalogue, we’re going to be displaying a collapsed music player at the bottom of the screen. This bottom bar allows us to display the current media playback, while still enabling the user to browse through the catalogue at the same time. This results in a non-blocking audio playback UX, which is something we often see in media applications.</p>

<p>We’re going to start here by creating a new composable, <code>PlayerBar</code>. This composable is going to take a nullable reference to the <code>NowPlaying</code> class that we defined earlier in this chapter - this will represent the track that is currently being played, with a <code>null</code> value representing the state where no media is currently being played. Alongside this, we’ll also require a lambda that can be used to toggle the playback state for the currently playing track.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>When this <code>NowPlaying</code> reference is not null, we’re going to want to display the details for the currently playing track. As per the designs, we’re going to be displaying the following details for a track that is currently being played:</p>

<ul>
	<li>The cover art for the track</li>
	<li>The name of the track</li>
	<li>The artist of the track</li>
	<li>The current playback position of the track</li>
</ul>

<p>To contain these details, we’re going to start by defining a new <code>Row</code> composable - this is going to need to fill the maximum width of the parent container, as well as position all of its children in the center of the vertical axis.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
		<span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            
        }
	}
}</code></pre>

<p>With this <code>Row</code> in place, we can now compose the cover art for the given track. For this we’ll utilise the <code>CoverfArt</code> composable that we previously created, using the <code>size</code> modifier to assign a sizing of <code>32dp</code>. We’ll also provide the <code>Track</code> reference from the <code>NowPlaying</code> state that is being provided to the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
		<span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            <span class="syntax-all syntax-entity">CoverArt</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">32</span>.dp),
                track <span class="syntax-all syntax-keyword">=</span> nowPlaying.track
            )
        }
	}
}</code></pre>

<figure><img src="1-31.png"/></figure>

<p>Alongside the cover art, we’re also going to be showing the title and artist for the given track. We’ll compose a column here to contain this information, using the <code>weight</code> modifier to ensure that it takes up the remaining available width outside of the <code>CoverArt</code> composable. Using the <code>Spacer</code> composer we’ll also ensure that there is sufficient space between the cover art and track information.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
		<span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            <span class="syntax-all syntax-entity">CoverArt</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">32</span>.dp),
                track <span class="syntax-all syntax-keyword">=</span> nowPlaying.track
            )
            <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">16</span>.dp))
            <span class="syntax-all syntax-entity">Column</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>)
            ) {
                <span class="syntax-all syntax-entity">Text</span>(
                    text <span class="syntax-all syntax-keyword">=</span> nowPlaying.track.title,
                    fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>,
                    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.sp
                )
                <span class="syntax-all syntax-entity">Text</span>(
                    text <span class="syntax-all syntax-keyword">=</span> nowPlaying.track.artist,
                    fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">10</span>.sp
                )
            }
        }
	}
}</code></pre>

<figure><img src="2-28.png"/></figure>

<p>For the track information within the <code>Column</code> composable, we’re going to use the <code>mergeSemantics</code> flag within the <code>semantics</code> modifier. This means that the content of the composable will be communicated as a single item, as opposed to two individually focusable elements.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
		<span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            ...
            <span class="syntax-all syntax-entity">Column</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>)
                    .semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { }
            ) {
                ...
            }
        }
	}
}</code></pre>

<h3>Allowing playback</h3>

<p>Outside of displaying the track information for the currently playing item, we’re going to want to allow the user to toggle the playback of this track - enabling the user to pause/resume playback after a music track has been selected from the catalogue. For this, we’re going to place an icon at the end of the <code>Row</code> within the <code>PlayerBar</code>. </p>

<p>For this component we’re going to compose an <code>IconButton</code>, this button will be used to trigger the <code>toggleNowPlayingState</code> lambda that is being provided to the composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PlayerBar.it
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
		<span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            ...
            <span class="syntax-all syntax-entity">IconButton</span>(
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    toggleNowPlayingState()
                }
            ) {
               
            }
        }
	}
}</code></pre>

<p>All we need to do now is compose the body of this <code>IconButton</code>, this composition will consist of an <code>Icon</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PlayerBar.it
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
		<span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            ...
            <span class="syntax-all syntax-entity">IconButton</span>(
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    toggleNowPlayingState()
                }
            ) {
               	<span class="syntax-all syntax-entity">Icon</span>(
                    ...
                )
            }
        }
	}
}</code></pre>

<p>This <code>Icon</code> is going to need to represent the action regarding the current playback state. To keep this logic outside of our composable, as well as make it reusable in other components we’ll be building later in this chapter, we’re going to create a small utility file. This file will define two functions, <code>iconForPlayingState</code> and <code>descriptionForNowPlayingState</code> - these will be used to retrieve both the icon and content description based on the current playback state. We’ll start by using the <code>NowPlayingState</code> to calculate the icon to be used.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// playerUtils.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">iconForPlayingState</span>(<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlayingState</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ImageVector</span> {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-keyword">if</span> (state <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>) {
        <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Pause</span>
    } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">PlayArrow</span>
}</code></pre>

<p>We’ll also want a corresponding content description for these icons, so we’ll start by adding two new strings to our resources file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_play&quot;</span>&gt;Play&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_pause&quot;</span>&gt;Pause&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Followed by creating a second function to retrieve a resource based on the <code>NowPlayingState</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// playerUtils.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">iconForPlayingState</span>(<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlayingState</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ImageVector</span> {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-keyword">if</span> (state <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>) {
        <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Pause</span>
    } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">PlayArrow</span>
}

<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">descriptionForNowPlayingState</span>(<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlayingState</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span> {
    <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-keyword">if</span> (state <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>) {
        <span class="syntax-all syntax-entity">R</span>.string.cd_pause
    } <span class="syntax-all syntax-keyword">else</span> <span class="syntax-all syntax-entity">R</span>.string.cd_play
}</code></pre>

<p>We can then utilise these functions within our composable to complete the composition of the <code>Icon</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PlayerBar.it
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
		<span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            ...
            <span class="syntax-all syntax-entity">IconButton</span>(
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    toggleNowPlayingState()
                }
            ) {
               	<span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> iconForPlayingState(
						nowPlaying.state),
                    contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
                        id <span class="syntax-all syntax-keyword">=</span> descriptionForNowPlayingState(
                            nowPlaying.state
                        )
                    )
                )
            }
        }
	}
}</code></pre>

<figure><img src="3-21.png"/></figure>

<h3>Creating the SeekBar</h3>

<p>Within this player bar, we’re also going to want to display information regarding the current playback status of the track. While the bar currently indicates whether the track is currently being played, there is no information as to the position of the current playback. For this we’re going to create a new component, a seek bar which will be used to display the current playback -we’ll start here by creating a new composable, <code>PlayerSeekBar</code>. This composable is going to take a reference to <code>NowPlaying</code>, which will be used to compose the current playback status.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>
)</code></pre>

<p>To compose the current playback, we’re going to utilise the <code>LinearProgressIndicator</code>. This is because we are wanting to communicate the current progress of the playing track to the user, which can be achieved via the use of a linear progress bar. However, to be able to display the playback progress, we first need to calculate what this progress is based on the current <code>NowPlaying</code> reference. To do so, we’ll take the playback position of the currently playing track, diving it by the length of the track - this will give us the percentage of the playback position in relation to its length.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>
) {
    <span class="syntax-all syntax-keyword">val</span> currentPosition <span class="syntax-all syntax-keyword">=</span> nowPlaying.position.toFloat() <span class="syntax-all syntax-keyword">/</span> 
		nowPlaying.track.length.toFloat()
}</code></pre>

<p>With this calculation in place, we can then apply this value to the <code>progress</code> argument of the <code>LinearProgressIndicator</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>
) {
    <span class="syntax-all syntax-keyword">val</span> currentPosition <span class="syntax-all syntax-keyword">=</span> nowPlaying.position.toFloat() <span class="syntax-all syntax-keyword">/</span> 
		nowPlaying.track.length.toFloat()
    <span class="syntax-all syntax-entity">LinearProgressIndicator</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        progress <span class="syntax-all syntax-keyword">=</span> currentPosition
    )
}</code></pre>

<figure><img src="oo.png"/></figure>

<p>While we have a seek bar that can be used to display the current playback for a track, it doesn’t yet support a piece of functionality that we’re going to need in another part of our music catalogue feature - audio scrubbing, which allows the user to change the current playback position. While we’re not using this functionality just yet, we’re going to implement this here so that we have a reusable component ready to plug in later on in this chapter.</p>

<p>To support this functionality we’re going to add two new arguments to our composable function:</p>

<ul>
	<li><strong>canSeekTrack</strong> - this allows us to define whether the current composition supports the ability to scrub the audio. In the case of our player bottom bar, we don’t want to support this functionality.</li>
	<li><strong>onSeekChanged</strong> - when the audio is scrubbed we’ll need to update the current playback position within our global state, this callback will be used to propagate this state back up to the parent composable</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">canSeekTrack</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> ((value<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>)? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>We have these new arguments applied, we’re going to adjust the composition of the previously defined <code>LinearProgressIndicator</code> - as we’ll only want to compose this when <code>canSeekTrack</code> is provided as a value of <code>false</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">canSeekTrack</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> ((value<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>)? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {
    <span class="syntax-all syntax-keyword">val</span> currentPosition <span class="syntax-all syntax-keyword">=</span> nowPlaying.position.toFloat() <span class="syntax-all syntax-keyword">/</span> 
		nowPlaying.track.length.toFloat()
    <span class="syntax-all syntax-keyword">if</span> (canSeekTrack) {
       ...
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">LinearProgressIndicator</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_SEEK_BAR</span>),
            progress <span class="syntax-all syntax-keyword">=</span> currentPosition
        )
    }
}</code></pre>

<p>On the other hand, we’re going to want to compose a different component when the user <strong>can</strong> perform the scrubbing of audio. In these cases we’re going to want to compose a <code>Slider</code>, this component enables the user to slide between values. When composing this, we’ll want to provide a seek position for the <code>value</code> argument, which will consist of the existing <code>currentPosition</code> value that we previously calculated. We’ll also need to handle the cases where seeking is performed, so here we’ll utilise the <code>onValueChange</code> block, triggering the <code>onSeekChanged</code> lambda that is being provided to the composable function. When calling this we’ll need to pass the current position of the track - so we’ll calculate this using the length of the track, diving it by the current seek position. This calculation will give us the current playback time of the audio, which can then be assigned within the state of our screen.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">canSeekTrack</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> ((value<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>)? <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
) {
    <span class="syntax-all syntax-keyword">val</span> currentPosition <span class="syntax-all syntax-keyword">=</span> nowPlaying.position.toFloat() <span class="syntax-all syntax-keyword">/</span> 
		nowPlaying.track.length.toFloat()
    <span class="syntax-all syntax-keyword">if</span> (canSeekTrack) {
        <span class="syntax-all syntax-entity">Slider</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            value <span class="syntax-all syntax-keyword">=</span> currentPosition,
            onValueChange <span class="syntax-all syntax-keyword">=</span> {
                on<span class="syntax-all syntax-entity">SeekChanged?</span>.invoke(
					nowPlaying.track.length <span class="syntax-all syntax-keyword">*</span> it)
            }
        )
    } <span class="syntax-all syntax-keyword">else</span> {
        <span class="syntax-all syntax-entity">LinearProgressIndicator</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            progress <span class="syntax-all syntax-keyword">=</span> currentPosition
        )
    }
}</code></pre>

<figure><img src="seek.png"/></figure>

<p>At this point, we’re now going to compose the <code>PlayerSeekBar</code> that we’ve just created. Within our <code>PlayerBar</code>, we’ll compose this at the bottom of the <code>Column</code> that is holding the playback information. When composing this, we’re going to provide a couple of pieces of information for composition.</p>

<ul>
	<li>We’ll use the <code>fillMaxWidth</code> modifier to have the composable fill the maximum available width within the container</li>
	<li>We’ll need to provide the <code>NowPlaying</code> reference so that the playback position can be calculated</li>
	<li>In this collapsed version of the <code>PlayerBar</code> the user is not able to perform the seek operation, so we’ll pass a <code>false</code> flag here to prevent this gesture from occurring</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
        <span class="syntax-all syntax-entity">Column</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp, vertical <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp)
        ) {
            ...
            <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
                nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying,
                canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
            )
        }
    }
}</code></pre>

<figure><img src="111-1.png"/></figure>

<p>With this now being composed, we can see that we now have some visual playback information being composed within the player bar. We’ll wrap things up here by adding some padding to the container of our player bar, helping to create some visual spacing on both the horizontal and vertical axis.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PlayerBar</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying?</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> {
        <span class="syntax-all syntax-entity">Column</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp, vertical <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">4</span>.dp)
        ) {
            ...
        }
    }
}</code></pre>

<figure><img src="barr-1.png"/></figure>

<hr />

<h2>Building the Fullscreen Player</h2>

<p>Now that we have the player bottom bar in place, we have a way to communicate audio playback through the dashboard of our music catalogue. In audio applications that mimic the same kind of layout, a fullscreen player can often be launched by interacting with this bottom bar audio component. In this part of the chapter, we’re going to mimic this by creating a version of our <code>PlayerBar</code> that fills the entire screen with playback information. </p>

<figure><img src="pp.png"/></figure>

<p>From this design we can see that the fullscreen player will support:</p>

<ul>
	<li>Information on the track that is currently being played</li>
	<li>A button is used to toggle between the playing and paused state</li>
	<li>Buttons that allow the user to rewind and fast-forward playback</li>
	<li>A seek bar that shows the current position of playback</li>
	<li>An icon that allows the user to close the fullscreen player</li>
</ul>

<p>To implement this, we’ll start here by creating a new composable function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">rewindTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">fastForwardTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
)</code></pre>

<p>We can see that this composable function takes a collection of arguments to satisfy the requirements that are outlined above.</p>

<ul>
	<li><strong>nowPlaying</strong> - a reference to the track that is currently being played</li>
	<li><strong>toggleNowPlayingState</strong> - a lambda triggered when the play/pause button is interacted with to toggle the playback state</li>
	<li><strong>rewindTrack</strong> - a lambda to be triggered when the rewind button is pressed</li>
	<li><strong>fastForwardTrack</strong> - a lambda to be triggered when the fast forward button is pressed</li>
	<li><strong>onSeekChanged</strong> - a lambda to be triggered when the seek bar is used to change the current playback position</li>
	<li><strong>onClose</strong> - a lambda triggered when the close icon is clicked</li>
</ul>

<p>With these arguments in place, we can start building out the UI components that will make up our composable. As we can see from our design, the components are made up of a mixture of vertically and horizontally stacked elements. We’re going to need to start here by defining a container which will be used to hold our UI components - this parent container is going to take the form of a <code>Column</code>, whose children are aligned to the center of both the vertical and horizontal axis. We’ll also apply some padding here to ensure that there is always sufficient spacing around the outside edges of the container.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">rewindTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">fastForwardTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {

    }
}</code></pre>

<p>With this container in place, we can now start adding the children that make up the user interface of our player. We’re going to reuse the <code>CoverArt</code> composable that we created earlier, fixing this to a size of <code>240dp</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">rewindTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">fastForwardTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {

        <span class="syntax-all syntax-entity">CoverArt</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp),
            track <span class="syntax-all syntax-keyword">=</span> nowPlaying.track
        )

    }
}</code></pre>

<figure><img src="cov-1.png"/></figure>

<p>With the cover art for the track now being displayed, we can start to compose more information for our track. Next, we’re going to compose the artist name and title underneath the cover art, using a <code>Spacer</code> to ensure there is sufficient space between the cover and track details.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">rewindTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">fastForwardTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {

        <span class="syntax-all syntax-entity">CoverArt</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp),
            track <span class="syntax-all syntax-keyword">=</span> nowPlaying.track
        )

        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))

        <span class="syntax-all syntax-entity">Column</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { }
        ) {
            <span class="syntax-all syntax-entity">Text</span>(
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">22</span>.sp,
                text <span class="syntax-all syntax-keyword">=</span> nowPlaying.track.title
            )

            <span class="syntax-all syntax-entity">Text</span>(,
                fontSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">18</span>.sp,
                text <span class="syntax-all syntax-keyword">=</span> nowPlaying.track.artist,
                fontWeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">FontWeight</span>.<span class="syntax-all syntax-entity">Bold</span>
            )
        }
       
    }
}</code></pre>

<p>Here we also use the <code>mergeDescendants</code> flag for the composable semantics to have the track details communicated to the user as a single item.</p>

<figure><img src="text.png"/></figure>

<p>Alongside the track title and artist, we’re also going to want to display some information around the current playback state - as well as allow the user to change this playback information. We previously created the <code>PlayerSeekBar</code> composable, so we’ll compose this here with the difference of allowing the user to perform seek operations for the current track.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">rewindTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">fastForwardTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {

        <span class="syntax-all syntax-entity">CoverArt</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp),
            track <span class="syntax-all syntax-keyword">=</span> nowPlaying.track
        )

        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))

        <span class="syntax-all syntax-entity">Column</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { }
        ) {
            ...
        }
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">36</span>.dp))

        <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">32</span>.dp),
            nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying,
            canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        ) {
            onSeekChanged(it)
        }

    }
}</code></pre>

<p>During composition, we utilise both the <code>canSeekTrack</code> and <code>onSeekChanged</code> arguments that were provided to the parent composable. These arguments allow us to compose the playback position for the current track, along with propagating seek events back up to the parent composable for state modification.</p>

<figure><img src="see.png"/></figure>

<p>As it is, the seekbar doesn’t provide an exact representation of the current playback position of the playing track. Because we are in a fullscreen player, we have the space to show additional information that is useful to the user. To improve things here, we’re going to display the current playback time at the start of the seekbar, followed by the length of the track at the end of the seekbar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">rewindTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">fastForwardTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember { 
		<span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;mm:ss&quot;</span>, <span class="syntax-all syntax-entity">Locale</span>.getDefault()) 
	}
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {

        ...

        <span class="syntax-all syntax-keyword">val</span> horizontalPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">32</span>.dp
        <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> horizontalPadding),
            nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying,
            canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        ) {
            onSeekChanged(it)
        }

        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">6</span>.dp))

        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .padding(horizontal <span class="syntax-all syntax-keyword">=</span> horizontalPadding)
        ) {
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(
				<span class="syntax-all syntax-entity">Date</span>(nowPlaying.position <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">1000L</span>)))
            <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
            <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> dateFormat.format(
				<span class="syntax-all syntax-entity">Date</span>(nowPlaying.track.length <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">1000L</span>)))
        }

    }
}</code></pre>

<p>Here we compose this information using the <code>NowPlaying</code> reference that is being provided to the composable. Because we want these times formatted in a minute-minute:second-second format (e.g. 01:20), we need to utilise the <code>SimpleDateFormat</code> class so that we can format the track times. Using the <code>position</code> and track <code>length</code> properties, we can create two formatted time stamps that can be composed at either side of the seek bar. We have these times composed at either end by utilising the <code>Spacer</code> composable, using a weight of <code>1f</code> to force it to use all available space between the timestamps.</p>

<figure><img src="time.png"/></figure>

<p>While we have a seekbarseek bar in place, we’re also going to add some buttons that will allow the playback state to be managed by the user. Here we’ll create three different buttons - one to allow the toggling between a playing/paused state, and two others than can be used to both rewind and fast-forward the playing track. We’re going to want to compose these buttons in a horizontal arrangement, having them spaced evenly within the container. With this in mind, we’ll utilise the <code>Row</code> composable, along with the <code>SpaceEvenly</code> value for the <code>horizontalArrangment</code> property.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
    horizontalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
) {

}</code></pre>

<p>💡Using SpaceEvenly will ensure that all child composable is spread evenly through the available space of the parent container.</p>

<p>The first child of this container is going to be the rewind button. We’ll compose an <code>IconButton</code> for this, triggering the <code>rewindTrack</code> lambda that is being provided to the composable function. For the body of this composable, we’ll utilise the <code>FastRewind</code> icon, along with adding a new value to our strings resources to represent the content description for the icon.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_rewind&quot;</span>&gt;Rewind&lt;/<span class="syntax-all syntax-tag">string</span></code></pre>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
    horizontalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
) {
    <span class="syntax-all syntax-entity">IconButton</span>(
        onClick <span class="syntax-all syntax-keyword">=</span> {
            rewindTrack()
        }
    ) {
        <span class="syntax-all syntax-entity">Icon</span>(
        	imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">FastRewind</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> 
					stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_rewind)
        )
    }
}</code></pre>

<figure><img src="y.png"/></figure>

<p>We’ll then add the second button for the play/pause toggle. Here we’ll trigger the <code>toggleNowPlayingState</code>that is provided to our composable function, along with utilising the previously created functions for the playing state icon and content descriptions.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
    horizontalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
) {
    ...
    <span class="syntax-all syntax-entity">IconButton</span>(
        onClick <span class="syntax-all syntax-keyword">=</span> {
            toggleNowPlayingState()
        }
    ) {
        <span class="syntax-all syntax-entity">Icon</span>(
            imageVector <span class="syntax-all syntax-keyword">=</span> iconForPlayingState(
				nowPlaying.state),
            contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
                id <span class="syntax-all syntax-keyword">=</span> descriptionForNowPlayingState(
					nowPlaying.state))
        )
    }
}</code></pre>

<figure><img src="yy.png"/></figure>

<p>Finally, we’ll add the final button for the fast-forward operation. For this <code>IconButton</code> we’ll trigger the <code>fastForwardTrack</code> lambda, along with the <code>FastForward</code> icon for the body of the button. We’ll also need to add a string to our resources file that will be used for the content description of the icon.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_fast_forward&quot;</span>&gt;Fast Forward&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Row</span>(
    horizontalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
) {
    ...
    <span class="syntax-all syntax-entity">IconButton</span>(
        onClick <span class="syntax-all syntax-keyword">=</span> {
            fastForwardTrack()
        }
    ) {
        <span class="syntax-all syntax-entity">Icon</span>(
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">FastForward</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span>
				<span class="syntax-all syntax-entity">R</span>.string.cd_fast_forward)
        )
    }
}</code></pre>

<figure><img src="yyy.png"/></figure>

<p>With this in place, we now have the playback buttons displayed within the fullscreen playback composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">rewindTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">fastForwardTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember { 
		<span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;mm:ss&quot;</span>, <span class="syntax-all syntax-entity">Locale</span>.getDefault()) 
	}
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {

        ...

        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))

        <span class="syntax-all syntax-entity">Row</span>(
            horizontalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
        ) {
            <span class="syntax-all syntax-entity">IconButton</span>(
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    rewindTrack()
                }
            ) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">FastRewind</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> 
						stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_rewind)
                )
            }
            <span class="syntax-all syntax-entity">IconButton</span>(
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    toggleNowPlayingState()
                }
            ) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> 		
						iconForPlayingState(nowPlaying.state),
                    contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
                        id <span class="syntax-all syntax-keyword">=</span> descriptionForNowPlayingState(
							nowPlaying.state)
                    )
                )
            }
            <span class="syntax-all syntax-entity">IconButton</span>(
                onClick <span class="syntax-all syntax-keyword">=</span> {
                    fastForwardTrack()
                }
            ) {
                <span class="syntax-all syntax-entity">Icon</span>(
                    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">FastForward</span>,
                    contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 		
						<span class="syntax-all syntax-entity">R</span>.string.cd_fast_forward)
                )
            }
        }
    }
}</code></pre>

<figure><img src="controls-1.png"/></figure>

<p>At this point, we have a fullscreen music player that can be used to show information regarding the current audio playback. We also previously created a collapsed version of this music player in the form of a bottom bar, which we will soon use to provide a way for the user to switch between the collapsed and expanded versions. To allow for this implementation, we’re going to need to provide a way for the user to collapse the expanded player - which we’ll do so in the form of a dismiss icon.</p>

<p>For this component we’re going to compose an <code>Icon</code>, aligning it to the start of the parent container. For the icon itself, we’ll use the <code>Cancel</code> icon for the content of the composable, along with triggering the <code>onClose</code> lambda within the <code>clickable</code> body.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Icon</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span>)
       	.clickable {
			onClose() 
		},
    imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Cancel</span>,
    contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
)</code></pre>

<p>To ensure this component is accessible, we’ll use a click label that describes what interacting with this icon will do. We’ll start by adding a new string to the resources file of our application.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_close_now_playing&quot;</span>&gt;Minimise player&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We can then add this string as the <code>onClickLabel</code> of the <code>clickable</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> closeAction <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
			<span class="syntax-all syntax-entity">R</span>.string.cd_close_now_playing)
        <span class="syntax-all syntax-entity">Icon</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span>)
                .clickable(
					onClickLabel <span class="syntax-all syntax-keyword">=</span> closeAction) { 
						onClose() 
					},
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Cancel</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
        )</code></pre>

<p>Now when the component is focused by screen readers, the action of the component will be communicated. We can then compose this <code>Icon</code> within the <code>Player</code> composable, at the top of the <code>Column</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">nowPlaying</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span>,
    <span class="syntax-all syntax-parameter">toggleNowPlayingState</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">rewindTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">fastForwardTrack</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onSeekChanged</span><span class="syntax-all syntax-keyword">:</span> (position<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onClose</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> dateFormat <span class="syntax-all syntax-keyword">=</span> remember { 
		<span class="syntax-all syntax-entity">SimpleDateFormat</span>(<span class="syntax-all syntax-string">&quot;mm:ss&quot;</span>, <span class="syntax-all syntax-entity">Locale</span>.getDefault())
	}
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">16</span>.dp),
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> 
			<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">Center</span>
    ) {
        <span class="syntax-all syntax-keyword">val</span> closeAction <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> 
			<span class="syntax-all syntax-entity">R</span>.string.cd_close_now_playing)
        <span class="syntax-all syntax-entity">Icon</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span>)
                .clickable(
					onClickLabel <span class="syntax-all syntax-keyword">=</span> closeAction) { 
						onClose() 
					},
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">Cancel</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
        )

        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))

        ...

        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.weight(<span class="syntax-all syntax-constant">1f</span>))
    }
}</code></pre>

<figure><img src="pp-1.png"/></figure>

<hr />

<h2>Switching between players</h2>

<p>Now that we have both of the player composables implemented, we’re going to want to write some logic that will conditionally compose the player based on the current state of the screen - this will decide whether the player is currently collapsed or expanded. We’re going to house this composition logic inside of a new composable function, <code>MusicPlayer</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MusicPlayer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>Within the body of this composable, we’re going to start by composing the <code>PlayerBar</code> that we previously defined. Along with having this fill the maximum available width, we’ll need to provide the <code>NowPlaying</code> reference from our <code>MusicDashboardState</code>, along with implementing the <code>toggleNowPlayingState</code> lambda for which we’ll trigger the <code>ToggleNowPlayingState</code> event. You’ll notice that to implement these requirements we’ve added two arguments to the composable function in the form of a <code>MusicDashboardState</code> reference and lambda to handle any <code>MusicCatalogEvent</code> triggers.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MusicPlayer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">PlayerBar</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxWidth(),
        nowPlaying <span class="syntax-all syntax-keyword">=</span> state.nowPlaying,
        toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {
        	handleEvent(
				<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">ToggleNowPlayingState</span>)
        }
    )
}</code></pre>

<p>When the <code>PlayerBar</code> is clicked, we’re going to want to trigger the <code>conceal</code> action on the parent composable, which is the <code>BackdropScaffold</code>. Here we’ll start by modifying the function arguments so that a <code>BackdropScaffoldState</code> reference is being provided to our composable. With this in place, we can now utilise the <code>clickable</code> modifier to trigger the <code>conceal</code> function from this state reference. This function is a suspending function, so it’ll need to be launched from a coroutine - this doesn’t add too much overhead for us though as we can utilise the <code>rememberCoroutineScope</code> function to create a <code>CoroutineScope</code> that can be used to launch this suspending function. As per the documentation, this function will:</p>

<blockquote>
<p>Return a CoroutineScope bound to this point in the composition using the optional CoroutineContext provided by getContext.</p>
</blockquote>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MusicPlayer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">scaffoldState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">BackdropScaffoldState</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> coroutineScope <span class="syntax-all syntax-keyword">=</span> rememberCoroutineScope()
    <span class="syntax-all syntax-entity">PlayerBar</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
 			.fillMaxWidth()
            .clickable {
            	coroutineScope.launch {
                	scaffoldState.conceal()
                }
            },
        nowPlaying <span class="syntax-all syntax-keyword">=</span> state.nowPlaying,
        toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {
        	handleEvent(
				<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">ToggleNowPlayingState</span>)
        }
    )
}</code></pre>

<p>We’re going to make one small tweak here to improve the clickable action on our composable and make it more accessible, which we’ll do by adding an <code>onClickLabel</code> to the <code>clickable</code> modifier. We’ll start by adding a new string resource that will be used to describe the action of the click event.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;action_show_player&quot;</span>&gt;Show Player&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Followed by assigning this message to the <code>onClickLabel</code> argument of the <code>clickable</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MusicPlayer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">scaffoldState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">BackdropScaffoldState</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> coroutineScope <span class="syntax-all syntax-keyword">=</span> rememberCoroutineScope()
	<span class="syntax-all syntax-keyword">val</span> onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.action_show_player)
    <span class="syntax-all syntax-entity">PlayerBar</span>(
		modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
 			.fillMaxWidth()
            .clickable(
				onClickLabel <span class="syntax-all syntax-keyword">=</span> onClickLabel
            ) {
            	coroutineScope.launch {
                	scaffoldState.conceal()
                }
            },
        nowPlaying <span class="syntax-all syntax-keyword">=</span> state.nowPlaying,
        toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {
        	handleEvent(
				<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">ToggleNowPlayingState</span>)
        }
    )
}</code></pre>

<p>While the <code>PlayerBar</code> is now being composed, we’re going to add the use of a <code>Divider</code> composable to create some visual separation between the composable content and the space outside of it. We’ll style the color of this divider using a modified version of the <code>onSurface</code> theme color - we’ll modify this by copying the value of the color and overriding the <code>alpha</code> value that is used for it. This will help to ensure that our divider remains within the theming of our application, while also adapting the color to our requirements.</p>

<p>Because we’re adding another child that is coupled to our <code>PlayerBar</code>, we’re going to need to use a nested parent container to link these two composables together. For this we can simply wrap the two composables in a <code>Column</code>, ensuring that they are vertically stacked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MusicPlayer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">scaffoldState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">BackdropScaffoldState</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span> {
        <span class="syntax-all syntax-entity">Divider</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">2</span>.dp),
            color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MaterialTheme</span>.colors
				.onSurface.copy(alpha <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.4f</span>)
        )
		<span class="syntax-all syntax-keyword">val</span> coroutineScope <span class="syntax-all syntax-keyword">=</span> rememberCoroutineScope()
        <span class="syntax-all syntax-keyword">val</span> onClickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(
			id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.action_show_player)
        <span class="syntax-all syntax-entity">PlayerBar</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
                .clickable(
                    onClickLabel <span class="syntax-all syntax-keyword">=</span> onClickLabel
                ) {
                    coroutineScope.launch {
                        scaffoldState.conceal()
                    }
                },
            nowPlaying <span class="syntax-all syntax-keyword">=</span> state.nowPlaying,
            toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">MusicCatalogEvent</span>
					.<span class="syntax-all syntax-entity">ToggleNowPlayingState</span>)
            }
        )
    }
}</code></pre>

<p>Next, we’re going to compose the <code>Player</code> which we previously defined, which is the full-screen music player. When there is a <code>NowPlaying</code> reference available in our state, we’ll compose this <code>Player</code> - to do so though we’ll need to implement all of its required arguments. For most of these, we can trigger the corresponding <code>MusicCatalogEvent</code> references. For the <code>onClose</code> implementation we’ll simply want to pull out our <code>coroutineScope</code> reference that we defined for the <code>PlayerBar</code> composable, using this to trigger the <code>reveal</code> function on the <code>BackdropScaffoldState</code> reference that is provided to our <code>MusicPlayer</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MusicPlayer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">scaffoldState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">BackdropScaffoldState</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> coroutineScope <span class="syntax-all syntax-keyword">=</span> rememberCoroutineScope()
    state.now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> { nowPlaying <span class="syntax-all syntax-keyword">-&gt;</span>
        <span class="syntax-all syntax-entity">Player</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
            nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying,
            rewindTrack <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(
					<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">RewindNowPlaying</span>)
            },
            fastForwardTrack <span class="syntax-all syntax-keyword">=</span> {
            	handleEvent(
					<span class="syntax-all syntax-entity">MusicCatalogEvent</span>
						.<span class="syntax-all syntax-entity">FastForwardNowPlaying</span>)
            },
            onSeekChanged <span class="syntax-all syntax-keyword">=</span> {
                handleEvent
					<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">SeekTrack</span>(it))
            },
            toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(
					<span class="syntax-all syntax-entity">MusicCatalogEvent</span>
						.<span class="syntax-all syntax-entity">ToggleNowPlayingState</span>)
            },
            onClose <span class="syntax-all syntax-keyword">=</span> {
                coroutineScope.launch {
                    scaffoldState.reveal()
                }
            }
        )
    }
    <span class="syntax-all syntax-entity">Column</span> {
        ...
    }
}</code></pre>

<p>As things currently are, both of these composables are going to be composed on-screen. What we’ll need to do now is add some conditional logic so that only a single one of these is displayed at any given time. During this process, we can also go a step further here and improve the transition that occurs between the two composables. For this we can utilise the <code>AnimatedVisibility</code> composable, this will allow us to show and hide composables in an animated fashion. Here we’re going to use an <code>AnimatedVisibility</code> composable for each of the players, setting their visibility state based on the current state of the provided <code>BackdropScaffoldState</code>. If the state is currently represented as the <code>Concealed</code> value, then we’ll want to display the <code>Player</code> composable, which is our fullscreen player. On the other hand, if the state is represented as <code>Revealed</code> then we’ll want to display the player bottom bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">MusicPlayer</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">scaffoldState</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">BackdropScaffoldState</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> coroutineScope <span class="syntax-all syntax-keyword">=</span> rememberCoroutineScope()
    <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        visible <span class="syntax-all syntax-keyword">=</span> scaffoldState.targetValue <span class="syntax-all syntax-keyword">==</span> 
			<span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Concealed</span>,
        enter <span class="syntax-all syntax-keyword">=</span> fadeIn(),
        exit <span class="syntax-all syntax-keyword">=</span> fadeOut()
    ) {
        state.now<span class="syntax-all syntax-entity">Playing?</span>.<span class="syntax-all syntax-constant">let</span> { nowPlaying <span class="syntax-all syntax-keyword">-&gt;</span>
            ...
        }
    }
    <span class="syntax-all syntax-entity">AnimatedVisibility</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.wrapContentHeight(),
        visible <span class="syntax-all syntax-keyword">=</span> scaffoldState.targetValue <span class="syntax-all syntax-keyword">==</span> 
			<span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>,
        enter <span class="syntax-all syntax-keyword">=</span> fadeIn(),
        exit <span class="syntax-all syntax-keyword">=</span> fadeOut(animationSpec <span class="syntax-all syntax-keyword">=</span> snap())
    ) {
        <span class="syntax-all syntax-entity">Column</span> {
            ...
        }
    }
}</code></pre>

<p>Finally, we’ll want to compose this within our <code>BackdropScaffold</code>. We’ll provide this <code>MusicPlayer</code> as part of the <code>frontLayerContent</code> content, passing in each of the required arguments during its composition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dashboard</span>(
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (contentEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
        initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
    )

    <span class="syntax-all syntax-entity">BackdropScaffold</span>(
        scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
        appBar <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">SearchBar</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .fillMaxWidth(),
                query <span class="syntax-all syntax-keyword">=</span> state.searchTerm,
                handleQuery <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">Search</span>(it))
                },
                clearQuery <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(
						<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">ClearSearchQuery</span>)
                }
            )
        },
        backLayerContent <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">TracksDashboard</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .fillMaxSize()
                    .testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_DASHBOARD</span>),
                state <span class="syntax-all syntax-keyword">=</span> state,
                onTrackClicked <span class="syntax-all syntax-keyword">=</span> { track <span class="syntax-all syntax-keyword">-&gt;</span>
                    handleEvent(
						<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">PlayTrack</span>(track))
                }
            )
        },
        frontLayerContent <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">MusicPlayer</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
                state <span class="syntax-all syntax-keyword">=</span> state,
                handleEvent <span class="syntax-all syntax-keyword">=</span> handleEvent
            )
        }
    )
}</code></pre>

<p>With this in place, we now have the music player composed within our UI, allowing the user to switch between both the collapsed and full-screen player formats. Now that the components of our Ui are now in place, we’re going to need to make a few adjustments so that things are displayed correctly. We’ll do this by providing some values for the arguments of our <code>BackdropScaffold</code>.</p>

<p><strong>headerHeight</strong> - this is the height of the front layer content, which in our case is the collapsed player, the <code>PlayerBar</code>. We’ll need this to be a specific height, otherwise, the content of the bar will not be displayed - so we’ll set this to <code>65dp</code>.</p>

<p><strong>peekHeight</strong> - this is the height of the visible part of the back layer when concealed. We don’t want the back layer visible when the full-screen player is shown, so we’ll set this as <code>0dp</code></p>

<p><strong>gesturesEnabled</strong> - we’ve added click listeners to the player bar so that the full-screen player can be displayed, as well as the <code>close</code> action within the full-screen player to dismiss this from view. So that our UI behaves as expected, we’re going to disable gestures on the <code>BackdropScaffold</code> using this argument.</p>

<p><strong>frontLayerShape</strong> - by default a rounded rectangle shoe will be used for the front layer content. We want to use a solid rectangle shape for this container, so we’ll override this default styling using the <code>RectangleShape</code> value.</p>

<p><strong>frontLayerScrimColor</strong> - by default, a color is applied to the scrim of the front layer. When this color is set, interaction with the front layer is blocked while the back layer is revealed. To prevent this behaviour we’re going to pass the <code>Color.Unspecified</code> value, allowing the click events on the <code>PlayerBar</code> to be detected, allowing the user to reveal/collapse the player components.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">BackdropScaffold</span>(
	headerHeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">65</span>.dp,
	peekHeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>.dp,
	gesturesEnabled <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    backLayerBackgroundColor <span class="syntax-all syntax-keyword">=</span> 
		<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
    scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
    frontLayerShape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RectangleShape</span>,
    appBar <span class="syntax-all syntax-keyword">=</span> {
        ...
    },
    backLayerContent <span class="syntax-all syntax-keyword">=</span> {
        ...
    },
    frontLayerContent <span class="syntax-all syntax-keyword">=</span> {
        ...
    },
    frontLayerScrimColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Unspecified</span>
)</code></pre>

<hr />

<h2>Loading initial data</h2>

<p>When the music dashboard feature is launched, we’re going to want to trigger an initial load of data so that the catalogue is populated. We’re going to want to load this data during the initial composition of our UI, so we’ll use the <code>LaunchedEffect</code> side-effect - this is a block of code that will only be run based on the key that is provided to it (so if the key changes, the block will be re-run). In our case we can simply provide a <code>Unit</code> as the key, meaning that the block will only be run on the initial composition. Within this we can trigger the <code>RefreshContent</code> event, meaning that on the initial composition of our UI the music catalogue data will be loaded.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dashboard</span>(
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (contentEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
        initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
    )

    <span class="syntax-all syntax-entity">LaunchedEffect</span>(<span class="syntax-all syntax-constant">Unit</span>) {
        handleEvent(<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">RefreshContent</span>)
    }

    <span class="syntax-all syntax-entity">BackdropScaffold</span>(
        ...
    )
}</code></pre>

<p>With this project complete, we now have a dashboard that is used to display a catalogue of available music, allowing the user to search for and select tracks to be displayed - along with viewing playback information.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Dashboard</span>(
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>,
    <span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (contentEvent<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">MusicCatalogEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
        initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
    )

	<span class="syntax-all syntax-entity">LaunchedEffect</span>(<span class="syntax-all syntax-constant">Unit</span>) {
        handleEvent(<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">RefreshContent</span>)
    }

    <span class="syntax-all syntax-entity">BackdropScaffold</span>(
        peekHeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>.dp,
        headerHeight <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">65</span>.dp,
        gesturesEnabled <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
        backLayerBackgroundColor <span class="syntax-all syntax-keyword">=</span> 
			<span class="syntax-all syntax-entity">MaterialTheme</span>.colors.surface,
        scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
        frontLayerShape <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">RectangleShape</span>,
        appBar <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">SearchBar</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .fillMaxWidth(),
                query <span class="syntax-all syntax-keyword">=</span> state.searchTerm,
                handleQuery <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">Search</span>(it))
                },
                clearQuery <span class="syntax-all syntax-keyword">=</span> {
                    handleEvent(
						<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">ClearSearchQuery</span>)
                }
            )
        },
        backLayerContent <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">TracksDashboard</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                    .fillMaxSize()
                    .testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_DASHBOARD</span>),
                state <span class="syntax-all syntax-keyword">=</span> state,
                onTrackClicked <span class="syntax-all syntax-keyword">=</span> { track <span class="syntax-all syntax-keyword">-&gt;</span>
                    handleEvent(
						<span class="syntax-all syntax-entity">MusicCatalogEvent</span>.<span class="syntax-all syntax-entity">PlayTrack</span>(track))
                }
            )
        },
        frontLayerContent <span class="syntax-all syntax-keyword">=</span> {
            <span class="syntax-all syntax-entity">MusicPlayer</span>(
                modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.fillMaxSize(),
                scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
                state <span class="syntax-all syntax-keyword">=</span> state,
                handleEvent <span class="syntax-all syntax-keyword">=</span> handleEvent
            )
        },
        frontLayerScrimColor <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Unspecified</span>
    )
}</code></pre>

<figure><img src="both-1.png"/></figure>

<hr />

<h2>Wrapping Up</h2>

<p>Throughout this project, we’ve now fully implemented our music dashboard feature - allowing our users to view the catalogue of tracks, select a track to play, view playback information, as well as search for tracks to be played. We’ve explored the composition of many different UI components, along with how to handle nested scrolling for different layouts inside a list of items.</p>

<figure><img src="both-2.png"/></figure>

<p>With all of this in place, we’ll want to ensure these components remain functional within our app. In the next chapter, we’re going to explore writing automated UI tests for these composables.</p>

<hr />

<h1>Testing the Music Dashboard UI</h1>

<p>Now that we’ve built our Music Dashboard feature, we’re going to take a look at how we can write tests for our composables. We’re going to be writing some instrumentation tests using the compose ui-test-junit package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>)
debugImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to add mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered whenever expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:4.5.1&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependent on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		resources {
            excludes <span class="syntax-all syntax-keyword">+=</span> &#39;<span class="syntax-all syntax-keyword">/</span><span class="syntax-all syntax-entity">META</span><span class="syntax-all syntax-keyword">-</span><span class="syntax-all syntax-entity">INF</span><span class="syntax-all syntax-keyword">/</span>{<span class="syntax-all syntax-entity">AL2</span>.<span class="syntax-all syntax-constant">0</span>,<span class="syntax-all syntax-entity">LGPL2</span>.<span class="syntax-all syntax-constant">1</span>}&#39;
            excludes <span class="syntax-all syntax-keyword">+=</span> <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
            excludes <span class="syntax-all syntax-keyword">+=</span> <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
        }
	}
}</code></pre>

<hr />

<h2>Creating a Test Data Factory</h2>

<p>Before we start writing our tests, we’re going to define some functions that will provide data for us to use during our tests. Throughout our tests, we’re going to need to create instances of the various music classes that contain test data. We’ll create a <code>randomString</code> function that allows us to generate a random string for use in tests (such as message content), along with some functions that allow us to create instances of the <code>NowPlaying</code> and <code>Track</code> classes that contain mock data for use in our tests. Having this factory allows us to simplify the use of test data in our tests, without needing to duplicate this logic throughout our project.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// TestDataFactory.kt
</span>
<span class="syntax-all syntax-keyword">object</span> TestDataFactory {

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">randomString</span>() <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">UUID</span>.randomUUID().toString().substring(<span class="syntax-all syntax-constant">0</span>, <span class="syntax-all syntax-constant">10</span>)

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeNowPlaying</span>(
        <span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span> <span class="syntax-all syntax-keyword">=</span> makeTrack(),
        <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlayingState</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PAUSED</span>,
        <span class="syntax-all syntax-parameter">progress</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Long</span> <span class="syntax-all syntax-keyword">=</span> track.length <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">3</span>
    )<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">NowPlaying</span> {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-entity">NowPlaying</span>(
            track,
            progress,
            state
        )
    }

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeTrack</span>(
        <span class="syntax-all syntax-parameter">isFeatured</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Math</span>.random() <span class="syntax-all syntax-keyword">&lt;</span> <span class="syntax-all syntax-constant">0.5</span>,
        <span class="syntax-all syntax-parameter">isNew</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Math</span>.random() <span class="syntax-all syntax-keyword">&lt;</span> <span class="syntax-all syntax-constant">0.5</span>
    )<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span> {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-entity">Track</span>(
            randomString(),
            randomString(),
            randomString(),
            <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Red</span>,
            length <span class="syntax-all syntax-keyword">=</span> nextLong(<span class="syntax-all syntax-constant">500</span>),
            isFeatured <span class="syntax-all syntax-keyword">=</span> isFeatured,
            isNew <span class="syntax-all syntax-keyword">=</span> isNew
        )
    }

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeContentList</span>(<span class="syntax-all syntax-parameter">count</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt; {
        <span class="syntax-all syntax-keyword">return</span> (<span class="syntax-all syntax-constant">0</span>..count).map { makeTrack() }
    }

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeMixedContentList</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">Track</span>&gt; {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
            makeTrack(<span class="syntax-all syntax-constant">false</span>, <span class="syntax-all syntax-constant">false</span>),
            makeTrack(<span class="syntax-all syntax-constant">true</span>, <span class="syntax-all syntax-constant">true</span>),
            makeTrack(<span class="syntax-all syntax-constant">true</span>, <span class="syntax-all syntax-constant">false</span>),
            makeTrack(<span class="syntax-all syntax-constant">false</span>, <span class="syntax-all syntax-constant">true</span>),
            makeTrack(<span class="syntax-all syntax-constant">true</span>, <span class="syntax-all syntax-constant">true</span>),
            makeTrack(<span class="syntax-all syntax-constant">false</span>, <span class="syntax-all syntax-constant">false</span>),
            makeTrack(<span class="syntax-all syntax-constant">false</span>, <span class="syntax-all syntax-constant">true</span>),
            makeTrack(<span class="syntax-all syntax-constant">true</span>, <span class="syntax-all syntax-constant">false</span>)
        )
    }
}</code></pre>

<hr />

<h2>Testing the Dashboard</h2>

<p>At a high level of our feature is the <code>Dashboard</code> composable. While we have a collection of focused composables that are responsible for specific parts of our UI, this composable acts as the parent container - composing each of the child composables that make up the different parts of the messaging feature. For this reason, we’re going to write a collection of tests that will perform asserts to ensure the correct composables are displayed as expected. We’ll start here by creating a new test class, <code>DashboardTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">DashboardTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the <code>ComposeContentTestRule</code> class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@get:Rule
</span><span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside.</p>

<p>With this test class configured, we’re going to write some tests to assert that each of the expected composables is being displayed when required - which will be based on the state which is provided to the <code>Dashboard</code> composable. We’ll start here by asserting that the header is being composed - the header should always be composed within the messaging screen, so we don’t need to worry about passing any specific state to it.</p>

<h3>Testing the display of Content</h3>

<p>To write this first test we’ll use the <strong>@Test</strong> annotation and create a new function to test that the header is displayed by default within our UI.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Area_Displayed</span>() {

}</code></pre>

<p>Inside of this test, we’re going to need to start by setting the composable content that is to be displayed on the screen for us to perform assertions against. Here we’ll use the test rule that we previously defined, along with its <code>setContent</code> function. This function takes a composable function as an argument, allowing us to define what is to be composed on screen for our tests. Because we’re wanting to test the <code>Dashboard</code> Composable that we defined in the previous sections of this chapter, we’ll go ahead and pass the <code>Dashboard</code> composable function for this composable argument. When composing the <code>Dashboard</code> we’ll need to provide a reference to a <code>MusicDashboardState</code>, along with an implementation of the <code>handleEvent</code> lambda - this will be blank as we don’t need to use this callback within our test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Area_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Dashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

}</code></pre>

<p>So that we can locate the header within our test, we’re going to need to add a tag to the composable that we wish to perform assertions against - this tag can then be used to locate our composable within our tests. We’ll need to start here by defining a tag reference that can be accessed from both our tests and our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_DASHBOARD</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_DASHBOARD&quot;</span>
}                   </code></pre>

<p>With this tag defined, we’ll then need to add this to our <code>Dashboard</code> composable. We’ll assign this to the top-level composable within the function, using the <code>testTag</code> modifier to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">BackdropScaffold</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">Tags</span>.<span class="syntax-all syntax-entity">TAG_DASHBOARD</span>),
	...
)</code></pre>

<p>Next, we’re going to locate the node within our composable hierarchy so that we can perform interactions and assertions on it. Here we’ll utilise the <code>onNodeWithTag</code> function, providing the tag that we defined above. We can then utilise the <code>assertIsDisplayed</code> function to assert that the composable is being displayed as expected within the <code>Dashboard</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Area_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Dashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_DASHBOARD</span>)
        .assertIsDisplayed()
}</code></pre>

<h3>Testing the Search Bar display</h3>

<p>We’re next going to test that the search bar is displayed at the top of the <code>Dashboard</code> composable. So that we can do this, we’ll again need to add a new tag to our <code>Tags</code> file.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
	...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_SEARCH_BAR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_SEARCH_BAR&quot;</span>
}</code></pre>

<p>Within the <code>Dashboard</code> composable we’ll next use the <code>testTag</code> function to assign the <code>TAG_SEARCH_BAR</code> tag to the <code>SearchBar</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">SearchBar</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxWidth()
		.testTag(<span class="syntax-all syntax-entity">TAG_SEARCH_BAR</span>),
    ...
)</code></pre>

<p>With this tag in place, we can now use it to locate the node within our composable, followed by asserting that the composable is being displayed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Search_Bar_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Dashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEARCH_BAR</span>)
        .assertIsDisplayed()
}</code></pre>

<h3>Testing the Player display</h3>

<p>Within the dashboard, the user can interact with the player bar to display a fullscreen music player. We’re going to want to test this functionality so that we can ensure the player is being displayed and hidden as expected, so we’ll start by defining two new tags - one for the player bar (the collapsed version of the player) and another for the fullscreen player.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_PLAYER_BAR&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PLAYER</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_PLAYER&quot;</span>
}</code></pre>

<p>We’ll then need to hop into the <code>MusicPlayer</code> composable and assign these tags to the corresponding composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicPlayer.kt
</span>
<span class="syntax-all syntax-entity">Player</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxSize()
		.testTag(<span class="syntax-all syntax-entity">TAG_PLAYER</span>)
)


<span class="syntax-all syntax-entity">PlayerBar</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxWidth()
		.clickable(
			onClickLabel <span class="syntax-all syntax-keyword">=</span> onClickLabel
        ) {
			coroutineScope.launch {
				scaffoldState.conceal()
            }
		}
		.testTag(<span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span>)
)</code></pre>

<p>With these tags in place, we can now start with the first test for this functionality, here we’re going to assert that the fullscreen player is revealed as expected. So that the player bar is displayed, we’ll need to use our test data factory to assign some data to the <code>nowPlaying</code> property within our <code>MusicDashboardState</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Full_Screen_Player_Revealed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Dashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>Next, we’ll want to locate the player bar using the <code>TAG_PLAYER_BAR</code> tag, followed by using the <code>TAG_PLAYER</code> to assert that the fullscreen player is displayed after the player bar has been clicked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Full_Screen_Player_Revealed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Dashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span>)
        .performClick()

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER</span>)
        .assertIsDisplayed()
}</code></pre>

<p>Now that we’ve asserted that the fullscreen player is being displayed as expected, we’re next going to want to assert that the fullscreen player is collapsed when the dismiss icon is clicked. So that we can interact with the dismiss icon within our tests, we’ll need to add a new tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	...
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_DISMISS_PLAYER</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_DISMISS_PLAYER&quot;</span>
}</code></pre>

<p>We’ll then want to assign this tag to the dismiss <code>Icon</code> within the fullscreen player.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Player.kt
</span>
<span class="syntax-all syntax-entity">Icon</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
        .align(<span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">Start</span>)
        .clickable(onClickLabel <span class="syntax-all syntax-keyword">=</span> closeAction) { onClose() }
        .testTag(<span class="syntax-all syntax-entity">TAG_DISMISS_PLAYER</span>),
	...
)</code></pre>

<p>We’ll then start by creating a new test, <code>Player_Dismissed_Hides_Player</code>, that will start by taking the same form as our previous test - composing the dashboard in a playing state and launching the fullscreen player by clicking on the player bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Dismissed_Hides_Player</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Dashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span>)
        .performClick()
}</code></pre>

<p>Next, we’ll use the <code>TAG_DISMISS_PLAYER</code> tag to locate the node for the dismiss icon, performing a click action to collapse the player. To assert that the player has collapsed, we’ll use the <code>TAG_PLAYER</code> tag to an asset that the fullscreen player no longer exists via the use of the <code>assertDoesNotExist</code> assertion.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Dismissed_Hides_Player</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Dashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span>)
        .performClick()

    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_DISMISS_PLAYER</span>
    ).performClick()

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER</span>)
        .assertDoesNotExist()
}</code></pre>

<p>We’ll also want to assert that when the fullscreen player has been dismissed, the collapsed player bar is displayed onscreen. We’ll create a new test, <code>Player_Dismissed_Shows_Player_Bar</code>, that will perform the same operations as the previous test - but instead of asserting that the <code>TAG_PLAYER</code> node does not exist, we’ll now assert that the collapsed player bar is displayed on the screen (via the use of the <code>TAG_PLAYER_BAR</code> tag).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Dismissed_Shows_Player_Bar</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Dashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span>)
        .performClick()

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_DISMISS_PLAYER</span>)
        .performClick()

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span>)
        .assertIsDisplayed()
}</code></pre>

<p>At this point, we now have a collection of tests that perform assertions to ensure that the dashboard displays the expected states - both in the initial load state of the composable, as well as when there are interactions performed with the player components.</p>

<hr />

<h2>Tracks Dashboard</h2>

<p>Now that we have the dashboard being tested, we’re going to jump a step into the <code>Dashboard</code> composable and write some tests for the back layer content, the <code>TracksDashboard</code>. These tests will be contained in a new test class, <code>TracksDashboardTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">TracksDashboardTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<h3>Testing the Track feeds display</h3>

<p>Within the <code>TracksDashboard</code> there can be two main states - either the tracks are displayed, or the search results for the current query in the <code>Dashboard</code>. We’ll start by writing a test to assert that the expected track feeds are displayed by default when there are no search results present in the state. We’ll need to start here by adding a new tag, <code>TAG_TRACKS_DASHBOARD</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
	...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_TRACKS_DASHBOARD</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_TRACKS_DASHBOARD&quot;</span>
}</code></pre>

<p>This tag can then be assigned to the tracks feed within the <code>TracksDashboard</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// TracksDashboard.kt
</span>
<span class="syntax-all syntax-entity">LazyColumn</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_TRACKS_DASHBOARD</span>),
	contentPadding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">PaddingValues</span>(top <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">12</span>.dp, bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8</span>.dp)
)</code></pre>

<p>Within the test, we can compose the <code>TracksDashboard</code> and then use the <code>TAG_TRACKS_DASHBOARD</code> tag to locate the node representing the tracks feed, followed by using the <code>assertIsDisplayed</code> to assert that it is being displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Content_Area_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">TracksDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(),
            onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_TRACKS_DASHBOARD</span>)
        .assertIsDisplayed()
}</code></pre>

<h3>Testing the Recently Played Tracks display</h3>

<p>Within the <code>TracksDashboard</code> there are 3 different types of track feeds displayed. We’re going to want to write tests for each, but we’ll start with the Recently Played tracks. We’ll first test that the title for the recently played tracks is being displayed as expected in a new test, <code>Recently_Played_Tracks_Header_Displayed</code>. Within this, we’re going to need to start by composing the <code>TracksDashboard</code>, providing a <code>MusicDashboardState</code> that contains a collection of tracks to be composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Recently_Played_Tracks_Header_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">TracksDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
            	tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMixedContentList()
         	),
        	onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
    	)
    }
}</code></pre>

<p>Next, we’re going to need to assert that the expected node contains the title for the recently played tracks. This part of the tracks feed contains multiple children, so we’re going to need to perform assertions against a specific child within the content list. We can retrieve the child of a node using the <code>onChildAt</code> function - within the tracks dashboard the recently played tracks title is at the 4th position in the list, so we can retrieve this directly from the node tagged using <code>TAG_TRACKS_DASHBOARD</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Recently_Played_Tracks_Header_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">TracksDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
            	tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMixedContentList()
         	),
        	onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
    	)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_TRACKS_DASHBOARD</span>)
        .onChildAt(<span class="syntax-all syntax-constant">4</span>)
}</code></pre>

<p>Now that we’ve located this node, we can assert that the text of this child is the expected text from the <code>heading_recently_played</code> resource. We expect the child at the 4th position in the list to represent the recently played title, so if this string resource matches the textual content of that child then the test will succeed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Recently_Played_Tracks_Header_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">TracksDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
            	tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMixedContentList()
         	),
        	onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
    	)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_TRACKS_DASHBOARD</span>)
        .onChildAt(<span class="syntax-all syntax-constant">4</span>)
        .assertTextEquals(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.targetContext.getString(
					<span class="syntax-all syntax-entity">R</span>.string.heading_recently_played))
}</code></pre>

<p>With this in place, we can now confirm that the Recently Played title is being displayed at the correct position, so now we need to test that the track items themselves are being shown. For this, we’ll create a new test called <code>Recently_Played_Tracks_Displayed</code>. Within this test, we’ll need to start by configuring the composable to display a list of tracks</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Recently_Played_Tracks_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMixedContentList()
    <span class="syntax-all syntax-keyword">val</span> state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
        tracks <span class="syntax-all syntax-keyword">=</span> tracks
    )
    <span class="syntax-all syntax-keyword">val</span> recentTracks <span class="syntax-all syntax-keyword">=</span> state.recentTracks()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">TracksDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> state,
            onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>Next, we’ll want to loop through these tracks and assert that they’re being displayed. Using the <code>TAG_DASHBOARD</code> node to perform these assertions against, we’ll again use the <code>onChildAt</code> function to iterate through the nodes that should reflect the recently played tracks. </p>

<p>To be able to assert the expected tracks are displayed, we’ll want to provide a <code>testTag</code> to the <code>Track</code> composable within the recently played tracks. We’ll need to start by adding a new tag to our <code>Tags.kt</code> file in the form of <code>TAG_TRACK</code> - we include an <code>_</code> as a suffix so that we can append the <code>id</code> of the track onto the tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_TRACK_&quot;</span>
}</code></pre>

<p>With this tag in place, we can now assign it to our <code>Track</code> composable. Here we’ll use this <code>TAG_TRACK</code> and append the <code>id</code> of the current message onto it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// RecentTracks.kt
</span>
<span class="syntax-all syntax-entity">Track</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		...
        .testTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> it.id),
    track <span class="syntax-all syntax-keyword">=</span> it
)</code></pre>

<p>Starting from the index of 5 (which is one after the title at index 4), we’ll assert that the node at the current position has the tag that matches the expected track ID. Because we’re working in a scrolling list, we’ll need to utilise the <code>performScrollTo</code> function so that the item in the list is scrolled to and composed on screen, otherwise our test will not be able to locate composables past an index that is off-screen. When running this test, each of the provided recent tracks will be looped through, performing the assertion that each is being composed as an item within the content list.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Recently_Played_Tracks_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMixedContentList()
    <span class="syntax-all syntax-keyword">val</span> state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
        tracks <span class="syntax-all syntax-keyword">=</span> tracks
    )
    <span class="syntax-all syntax-keyword">val</span> recentTracks <span class="syntax-all syntax-keyword">=</span> state.recentTracks()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">TracksDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> state,
            onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    recentTracks<span class="syntax-all syntax-keyword">!!</span>.forEachIndexed { index, track <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule
            .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_DASHBOARD</span>)
            .onChildAt(<span class="syntax-all syntax-constant">5</span> <span class="syntax-all syntax-keyword">+</span> index)
            .performScrollTo()
            .<span class="syntax-all syntax-keyword">assert</span>(hasTestTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> track.id))
    }
}</code></pre>

<p>Aside from the content being displayed, we’ll also want to assert that the track listener provided to the composable function is being triggered on a click event. For the next test we’ll again compose the <code>TracksDashboard</code> but this time we’ll pass a mock implementation of the <code>onTrackClicked</code> lambda - this is so that we can verify this is involved when the composable is interacted with.</p>

<p>We’ll again use the <code>onChildAt</code> function to locate a node at a given position, followed by utilising the <code>performClick</code> function to invoke a click event on the located node. When this click event occurs we would expect the <code>onTrackClicked</code> lambda to be invoked - so at this point we want to verify that this is the case by utilising the mockito verify function. This allows us to assert that the lambda is triggered as expected when the node is clicked. Because we are interacting with the node at the fifth position in the parent, this represents the first track in the featured tracks collection - therefore we expect the lambda to be involved with this track reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Clicking_Recently_Played_Track_Plays_Selected_Track</span>() {
    <span class="syntax-all syntax-keyword">val</span> content <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeMixedContentList()
    <span class="syntax-all syntax-keyword">val</span> state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
        tracks <span class="syntax-all syntax-keyword">=</span> content
    )
    <span class="syntax-all syntax-keyword">val</span> trackToSelect <span class="syntax-all syntax-keyword">=</span> state.recentTracks().first()
    <span class="syntax-all syntax-keyword">val</span> trackListener<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">TracksDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> state,
            onTrackClicked <span class="syntax-all syntax-keyword">=</span> trackListener
        )
    }

    composeTestRule
        .onNodeWithTag(<span class="syntax-all syntax-entity">TAG_DASHBOARD</span>)
        .onChildAt(<span class="syntax-all syntax-constant">5</span>)
        .performClick()

    verify(trackListener).invoke(trackToSelect)
}</code></pre>

<p>In the supporting code for this course, you’ll also find the tests that cover the cases above for the New and Recent tracks, as well as the Search Results. We won’t cover these tests here as the code is almost identical to what we’ve covered above.</p>

<hr />

<h2>Featured Tracks</h2>

<p>Now that we’ve covered the higher-level testing of the dashboard composables, we can start to dive into the more fine-grained composable functions - we’ll start here with the <strong>Featured Track</strong> related composables.</p>

<h3>Testing the Title display</h3>

<p>The <code>FeaturedTrack</code> composable is used to display Featured Tracks in a content feed, so we’ll want to assert that this content is being composed correctly. The <code>FeaturedTrack</code> consists of a title which is taken from the provided track reference. For this, we’ll create a simple test class that composes the <code>FeaturedTrack</code>, followed by asserting that a node is being displayed that contains the <code>title</code> for the composed track.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">FeaturedTrackTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    <span class="syntax-all syntax-keyword">@Test
</span>    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
        <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
        composeTestRule.setContent {
            <span class="syntax-all syntax-entity">FeaturedTrack</span>(track <span class="syntax-all syntax-keyword">=</span> track)
        }
        composeTestRule.onNodeWithText(
            track.title
        ).assertIsDisplayed()
    }

}</code></pre>

<p>Alongside testing the <code>FeaturedTrack</code>, we’re also going to want to write tests for the grid that is used to display the featured tracks - we’ll contain these tests in a new test class, <code>FeaturedTracksGridTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">FeaturedTracksGridTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()


}</code></pre>

<p>For the first test, we’re going to assert that the featured tracks are not displayed when an empty list is provided to the composable function. We’ll start here by composing the <code>FeaturedTracksGrid</code>, providing an empty list for the <code>tracks</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Featured_Tracks_Not_Displayed_When_Empty</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
			tracks <span class="syntax-all syntax-keyword">=</span> emptyList(), 
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
}</code></pre>

<p>Before we can perform assertions, we’ll need to add a new tag for locating the featured tracks node.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_FEATURED_TRACKS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_FEATURED_TRACKS&quot;</span>
}</code></pre>

<p>Within the FeaturedTracksGrid<code>FeaturedTracksGrid</code> we can then assign this to the composable that is displaying the grid of tracks.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// FeaturedTracksGrid.kt
</span>
<span class="syntax-all syntax-entity">FlowRow</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> modifier
        .testTag(<span class="syntax-all syntax-entity">TAG_FEATURED_TRACKS</span>),
    ...
)</code></pre>

<p>With this in place, we can now locate this node within our tests, followed by using the <code>assertDoesNotExist</code> function to assert that the composable does not exist when there are no tracks provided.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Featured_Tracks_Not_Displayed_When_Null</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
			tracks <span class="syntax-all syntax-keyword">=</span> emptyList(), 
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_FEATURED_TRACKS</span>
    ).assertDoesNotExist()
}</code></pre>

<p>On a similar note, the <code>tracks</code> argument is a nullable type - so we can write a similar test to assert that the featured tracks grid is not composed when a null value is passed for the <code>tracks</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Featured_Tracks_Not_Displayed_When_Null</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>, onTrackClicked <span class="syntax-all syntax-keyword">=</span> {})
    }
    composeTestRule.onNodeWithTag(
        <span class="syntax-all syntax-entity">TAG_FEATURED_TRACKS</span>
    ).assertDoesNotExist()
}</code></pre>

<p>Now that we have covered these empty states, the most important state of our featured tracks is where it’s displaying the tracks. To perform assertions that the tracks are being displayed as expected, we’ll start by creating a new test, <code>Featured_Tracks_Displayed</code>. Here we’ll compose the <code>FeaturedTracksGrid</code>, passing a collection of tracks generated using our test data factory.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Featured_Tracks_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeContentList(<span class="syntax-all syntax-constant">5</span>)

    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">FeaturedTracksGrid</span>(
			tracks <span class="syntax-all syntax-keyword">=</span> tracks, 
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
}</code></pre>

<p>Using the <code>TAG_TRACK</code> tag that we defined for a previous test, we’ll now assign this to the <code>FeaturedTrack</code> being composed within the <code>FeaturedTracksGrid</code>, using the id of the track being composed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// FeaturedTracksGrid.kt
</span>
<span class="syntax-all syntax-entity">FeaturedTrack</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		...
        .testTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> track.id),
    track <span class="syntax-all syntax-keyword">=</span> track
)</code></pre>

<p>With this tag in place, we can now locate the tracks inside of the grid. Using the <code>TAG_FEATURED_TRACKS</code> tag to locate the node representing the grid, we’ll assert that the child at the current position in our tracks list correctly represents the expected tag using <code>TAG_TRACK</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Featured_Tracks_Displayed</span>() {
    ...

    tracks.forEachIndexed { rowIndex, track <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_FEATURED_TRACKS</span>)
            .onChildAt(rowIndex)
            .<span class="syntax-all syntax-keyword">assert</span>(hasTestTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> track.id))
    }
}</code></pre>

<p>With this test in place, we can now assert that the featured tracks are being composed as expected in the grid of items. </p>

<hr />

<h2>New Tracks</h2>

<p>Similar to the testing of the composables for the <strong>Recent Tracks</strong>, we’re going to want to perform similar assertions against the composables used to represent the <strong>New Tracks</strong> within the music dashboard. </p>

<h3>Testing the New Track composable</h3>

<p>We’ll start here by writing some tests for the <code>NewTrack</code> composable - similar to the <code>RecentTrack</code> composable, this simply shows some textual information for the provided track. We’ll write two separate tests here - one to test the display of the track <code>title</code> and another to assert the <code>artist</code> is displayed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NewTrackTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    <span class="syntax-all syntax-keyword">@Test
</span>    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Title_Displayed</span>() {
        <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
        composeTestRule.setContent {
            <span class="syntax-all syntax-entity">NewTrack</span>(track <span class="syntax-all syntax-keyword">=</span> track)
        }
        composeTestRule.onNodeWithText(
            track.title
        ).assertIsDisplayed()
    }

    <span class="syntax-all syntax-keyword">@Test
</span>    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Artist_Displayed</span>() {
        <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
        composeTestRule.setContent {
            <span class="syntax-all syntax-entity">NewTrack</span>(track <span class="syntax-all syntax-keyword">=</span> track)
        }
        composeTestRule.onNodeWithText(
            track.artist
        ).assertIsDisplayed()
    }
}</code></pre>

<h3>Testing the New Tracks Row</h3>

<p>Now that we have tests in place for the individual <code>NewTrack</code> composable, we can look at putting some tests together for the row used to display the collection of new track references. We’ll start here by creating a new test class to hold these tests, <code>NewTracksRowTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">NewTracksRowTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>Before we start writing tests inside of this class, we’ll need to be able to locate the New Track container using a tag. We’ll start by adding a new tag to our <code>Tags</code> object.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_NEW_TRACKS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_NEW_TRACKS&quot;</span>
}</code></pre>

<p>Followed by assigning this to the row containing the tracks via the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// NewTracksRow.kt
</span>
<span class="syntax-all syntax-entity">LazyRow</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier
		.testTag(<span class="syntax-all syntax-entity">TAG_NEW_TRACKS</span>),
	...
 )</code></pre>

<p>With this in place, we can now locate the New Tracks row using the <code>TAG_NEW_TRACKS</code> tag. Similar to the Recent Tracks tests, we’ll add some tests to assert that the New Tracks row is not displayed when the provided <code>tracks</code> is either an empty list or a null value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">New_Tracks_Not_Displayed_When_Empty</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">NewTracksRow</span>(tracks <span class="syntax-all syntax-keyword">=</span> emptyList(), onTrackClicked <span class="syntax-all syntax-keyword">=</span> {})
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_NEW_TRACKS</span>)
        .assertDoesNotExist()
}

<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">New_Tracks_Not_Displayed_When_Null</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">NewTracksRow</span>(tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>, onTrackClicked <span class="syntax-all syntax-keyword">=</span> {})
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_NEW_TRACKS</span>)
        .assertDoesNotExist()
}</code></pre>

<p>Alongside these tests, we’ll also want to assert that each of the track references is being composed inside of the row. We’ll again utilise the <code>TAG_TRACK</code> tag that we created earlier, assigning this to the <code>NewTrack</code> composable using the corresponding track id.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// NewTracksRow.kt
</span>
<span class="syntax-all syntax-entity">NewTrack</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		...
		.testTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> track.id),
	track <span class="syntax-all syntax-keyword">=</span> track
)</code></pre>

<p>We can then use this tag to locate the corresponding track node inside the New Tracks row. Here we’ll utilise the <code>performScrollToNode</code> to scroll to the node that represents the current track, followed by <code>assertIsDisplayed</code> to assert that the track is being composed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">New_Tracks_Displayed</span>() {
	<span class="syntax-all syntax-keyword">val</span> tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeContentList()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">NewTracksRow</span>(tracks <span class="syntax-all syntax-keyword">=</span> tracks, onTrackClicked <span class="syntax-all syntax-keyword">=</span> {})
    }

    tracks.forEach { track <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_NEW_TRACKS</span>)
            .performScrollToNode(
				hasTestTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> track.id))
            .assertIsDisplayed()
    }
}</code></pre>

<p>As well as having the new tracks displayed, users can click on those tracks to trigger playback. We’ll want to assert that the track listener provided to the composable function is being triggered on a click event. For the next test we’ll again compose the <code>NewTracksRow</code> but this time we’ll pass a mock implementation of the <code>onTrackClicked</code> lambda - this is so that we can verify this is involved when the composable is interacted with.</p>

<p>We’ll again use the <code>onNodeWithTag</code> function to locate the node that has a tag for the track that we’re wanting to trigger the click event for, followed by utilising the <code>performClick</code> function to invoke the click event on the located node. When this click event occurs we would expect the <code>onTrackClicked</code> lambda to be invoked - so at this point we want to verify that this is the case by utilising the mockito verify function. This allows us to assert that the lambda is triggered as expected when the node is clicked, with the expected track reference that has been clicked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Selecting_New_Track_Triggers_Listener</span>() {
    <span class="syntax-all syntax-keyword">val</span> trackListener<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">track</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Track</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    <span class="syntax-all syntax-keyword">val</span> tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeContentList()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">NewTracksRow</span>(
			tracks <span class="syntax-all syntax-keyword">=</span> tracks, 
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> trackListener
		)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> tracks[<span class="syntax-all syntax-constant">2</span>].id)
        .performClick()

    verify(trackListener).invoke(tracks[<span class="syntax-all syntax-constant">2</span>])
}</code></pre>

<hr />

<h2>Search Bar</h2>

<p>Outside of displaying tracks, we also allow the user to search for tracks in the music catalogue using the search bar. So that we can ensure this search bar is working as expected, we’re going to write some tests to assert this expected functionality. We’ll start here by creating a new test class, <code>SearchBarTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SearchBarTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<h3>Testing the Hint</h3>

<p>To assist users in awareness of what the search bar is used for, we display a hint message. We built our custom hint mechanism for the search bar, so we’re going to want to test that this is displayed and hidden in the expected scenarios. By default when there is no search query entered, this hint is going to be displayed. So that we can test this, we’ll start by composing the <code>SearchBar</code>, providing an empty string value for the <code>query</code> argument.</p>

<p>Using the string resource that represents the search bar hint, we’ll want to assert that the node that has this text as its content is displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Hint_Displayed_By_Default</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">SearchBar</span>(
			query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>, 
			handleQuery <span class="syntax-all syntax-keyword">=</span> {}, 
			clearQuery <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.hint_search)
    ).assertIsDisplayed()
}</code></pre>

<p>When the search bar is in focus, this hint shouldn’t be displayed. We’ll want to test this behaviour, so we’ll need to start by composing the <code>SearchBar</code> with a blank <code>query</code> argument. Next, we’ll want to perform a click event on the search bar, as this will bring the component into focus. We previously added the <code>TAG_SEARCH_BAR</code> tag for some earlier tests, so we’ll want to assign this to the <code>TextField</code> composable within the Search bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SearchBar.kt
</span>
<span class="syntax-all syntax-entity">TextField</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier
		.testTag(<span class="syntax-all syntax-entity">TAG_SEARCH_BAR</span>),
	...
)</code></pre>

<p>With this tag in place, we can now locate this node and use the <code>performClick</code> function to perform a click event on the search bar.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Hint_Hidden_When_Focused</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">SearchBar</span>(
			query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>, 
			handleQuery <span class="syntax-all syntax-keyword">=</span> {}, 
			clearQuery <span class="syntax-all syntax-keyword">=</span> {}
		)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEARCH_BAR</span>)
    	.performClick()
}</code></pre>

<p>Now that this click event has been performed, the search bar should now be in focus. With this focus, it also means that the hint should no longer be displayed in the search bar, so we’ll assert this by using the <code>assertDoesNotExist</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Hint_Hidden_When_Focused</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">SearchBar</span>(
			query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>, 
			handleQuery <span class="syntax-all syntax-keyword">=</span> {}, 
			clearQuery <span class="syntax-all syntax-keyword">=</span> {}
		)
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEARCH_BAR</span>)
    	.performClick()

    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.hint_search
            )
    ).assertDoesNotExist()
}</code></pre>

<h3>Testing the search Icon</h3>

<p>As well as the dynamic hint, we also have an icon displayed in the <code>SeachBar</code> that changes based on the current state of the composable. By default, a search icon is displayed as the trailing icon of the field, so we’ll want to assert this is the case. This search icon has a content description, so we can assert that this icon is being displayed by locating the node that has this content description applied. After composing the <code>SearchBar</code> composable for our test, we’ll use the <code>onNodeWithContentDescription</code> function to locate the node with this content description, followed by using the <code>assertIsDisplayed</code> function to assert that the node with this description is being displayed - in this case, it means that the search icon is being displayed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Search_Icon_Displayed_By_Default</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">SearchBar</span>(
			query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;&quot;</span>, 
			handleQuery <span class="syntax-all syntax-keyword">=</span> {}, 
			clearQuery <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.cd_search
            )
    ).assertIsDisplayed()
}</code></pre>

<p>On the other hand, when a search query has been entered we expect the ‘clear’ icon to be displayed - this allows the user to clear the currently entered search content, resetting the search state. This clear icon will only ever be displayed when there is a query entered, so we’ll want to compose the <code>SearchBar</code> with a valid <code>query</code> argument. Next, we’ll use the content description that is applied to the ‘clear’ icon to locate the corresponding node, followed by using the <code>assertIsDisplayed</code> function to assert that it is being displayed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Close_Icon_Displayed_When_Query_Entered</span>() {
	composeTestRule.setContent {
        <span class="syntax-all syntax-entity">SearchBar</span>(
			query <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;Test&quot;</span>, 
			handleQuery <span class="syntax-all syntax-keyword">=</span> {}, 
			clearQuery <span class="syntax-all syntax-keyword">=</span> {}
		)
    }

    composeTestRule.onNodeWithContentDescription(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.cd_clear_query
            )
    ).assertIsDisplayed()
}</code></pre>

<p>In the sample code, you’ll also find tests that assert the Search icon is hidden when a query is entered, as well as the clear icon, which is hidden when there is no query entered. We haven’t covered these in writing here as the tests are very similar to what we’ve already covered.</p>

<hr />

<h2>Search Results</h2>

<p>When the search bar is used to perform a search operation, the corresponding search results are displayed using the <code>SearchResults</code> composable. So that we can ensure the search results are being displayed as expected, let’s write a few tests that will assert this display of results. We’ll start by creating a new test class, <code>SearchResultsTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SearchResultsTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>When there are no search results to display, we display a message that represents an empty state. We’re going to write a test to assert that this is displayed as expected, so we’ll start by composing <code>SearchResults</code> and passing an empty list for the <code>results</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_State_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">SearchResults</span>(
			results <span class="syntax-all syntax-keyword">=</span> emptyList(), 
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
}</code></pre>

<p>Next, we’ll use the string resource that represents the empty state, asserting that this is displayed within the composable using the <code>assertIsDisplayed</code> function. When this test is run and succeeds, we know that the empty state message is being displayed when there are no results provided to the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_State_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">SearchResults</span>(
			results <span class="syntax-all syntax-keyword">=</span> emptyList(), 
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.message_search_results
            )
    ).assertIsDisplayed()
}</code></pre>

<p>On the other hand, when results have been provided to the composable function, we expect this message to not be displayed. We’re going to write a similar test to the previous, except this time asserting that the message does not exist on-screen when search results have been provided to the composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Empty_State_Not_Displayed_When_ResultsExist</span>() {
	composeTestRule.setContent {
		<span class="syntax-all syntax-entity">SearchResults</span>(
			results <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ContentFactory</span>.makeContentList(),
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
			.targetContext.getString(
                <span class="syntax-all syntax-entity">R</span>.string.message_search_results
            )
    ).assertDoesNotExist()
}</code></pre>

<p>Aside from the empty state, we’re going to want to ensure that the search results are being composed as expected - this will be a case of checking that each of the tracks that are provided to the composable function is being displayed within the results list. We’ll need to start by tagging the <code>Track</code> composable using the <code>TAG_TRACK</code> that we previously defined, along with the <code>id</code> of the corresponding track.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">//SearchResults.kt
</span>
<span class="syntax-all syntax-entity">Track</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		...
		.testTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> it.id),
    track <span class="syntax-all syntax-keyword">=</span> it
)</code></pre>

<p>With this tag in place, we can now test for the display of search results. In this test, we’ll want to compose the <code>SearchResults</code>, passing a collection of track references.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Search_Results_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeContentList(<span class="syntax-all syntax-constant">5</span>)
	composeTestRule.setContent {
        <span class="syntax-all syntax-entity">SearchResults</span>(
			results <span class="syntax-all syntax-keyword">=</span> tracks, 
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
		)
    }
}</code></pre>

<p>So that we can check the contents of the search container, we’ll need to add a new tag <code>TAG_SEARCH_RESULTS</code> to our <code>Tags</code> object.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
    ...
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_SEARCH_RESULTS</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_SEARCH_RESULTS&quot;</span>
}</code></pre>

<p>With this tag in place, we’ll now want to add it to the <code>LazyColumn</code> that is used for composing the collection of tracks.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// SearchResults.kt
</span>
<span class="syntax-all syntax-entity">LazyColumn</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_SEARCH_RESULTS</span>),
	...
)</code></pre>

<p>With this tag in place, we can now loop through the collection of tracks and assert that each one is being composed inside of the column. After locating the node using the <code>TAG_SEARCH_RESULTS</code> tag, we’ll use <code>onChildAt</code> to get the current child for the corresponding index of the loop. Once we have a reference for this child we’ll use the <code>performScrollTo</code> function to ensure that it is composed and visible on screen, followed by using the <code>TAG_TRACK</code> tag and corresponding track <code>id</code> to ensure the track is being displayed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Search_Results_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> tracks <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeContentList(<span class="syntax-all syntax-constant">5</span>)
	composeTestRule.setContent {
        <span class="syntax-all syntax-entity">SearchResults</span>(
			results <span class="syntax-all syntax-keyword">=</span> tracks, 
			onTrackClicked <span class="syntax-all syntax-keyword">=</span> {}
		)
    }

    tracks.forEachIndexed { index, track <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEARCH_RESULTS</span>)
            .onChildAt(index).<span class="syntax-all syntax-constant">apply</span> {
                performScrollTo()
                <span class="syntax-all syntax-keyword">assert</span>(hasTestTag(<span class="syntax-all syntax-entity">TAG_TRACK</span> <span class="syntax-all syntax-keyword">+</span> track.id))
            }
    }
}</code></pre>

<hr />

<h2>Testing the Seeker</h2>

<p>Now that we’ve set up tests for each of the track feeds, we’re going to start looking into the various player components - we’ll start here with the <code>SeekBar</code>. Because we’ve created a custom composable for this, we must test its functionality.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SeekBarTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>So that we can retrieve the node that represents the seeker, we’re going to define a new tag within our <code>Tags</code> object.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_SEEK_BAR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_SEEK_BAR&quot;</span>
}</code></pre>

<p>We can then assign this tag to the <code>Slider</code> composable inside of the <code>PlayerSeekBar</code>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PlayerSeekBar.kt
</span>
<span class="syntax-all syntax-entity">Slider</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_SEEK_BAR</span>),
	...
)</code></pre>

<h3>Testing the current progress</h3>

<p>Within the first test, we’re going to check that this <code>Slider</code> composable is displaying the expected progress, based on the information that is provided to it. We’ll create a new <code>NowPlaying</code> reference, followed by using this to compose a <code>PlayerSeekBar</code>. Because we want to test the <code>Slider</code> composable inside of this, we’re going to go ahead and provide a <code>true</code> value for the <code>canSeekTrack</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Progress_Displayed_When_Can_Seek</span>() {
    <span class="syntax-all syntax-keyword">val</span> nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying,
            canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        )
    }
}</code></pre>

<p>We can now use the previously assigned tag to locate the <code>Seekbar</code> and perform assertions against it. In this test we’re going to want to check that the progress bar is displaying the expected progress, so we’re going to use the <code>assertRangeInfoEquals</code> function to test that the progress range matches the expected range, based on the provided track information. For this, we need to provide a <code>ProgressBarRangeInfo</code> instance that represents the expected progress state of the <code>Seekbar</code>, this has three values:</p>

<ul>
	<li><strong>current</strong> - this represents the current progress value within the seek bar. In our case this is going to be calculated using the currently playing track - so we’ll need to work out the expected percentage using the position of the provided now playing track, dividing it by the length to give us the current percentage value.</li>
	<li><strong>range</strong> - the range that is available within the seeker, which is simply between 0f and 1f</li>
	<li><strong>steps</strong> - the number of steps available within the seek bar. Seeing as we don’t support steps, this is simply 0</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Progress_Displayed_When_Can_Seek</span>() {
    <span class="syntax-all syntax-keyword">val</span> nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying,
            canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEEK_BAR</span>)
        .assertRangeInfoEquals(
            <span class="syntax-all syntax-entity">ProgressBarRangeInfo</span>(
                current <span class="syntax-all syntax-keyword">=</span> nowPlaying.position.toFloat() <span class="syntax-all syntax-keyword">/</span> 
					nowPlaying.track.length.toFloat(),
                range <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>..<span class="syntax-all syntax-constant">1f</span>,
                steps <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>
            )
        )
}</code></pre>

<p>With this in place, we are now able to assert that the currently displayed information within the <code>Seekbar</code> correctly represents the <code>NowPlaying</code> reference that is provided to the <code>PlayerSeekBar</code> composable.</p>

<p>Alongside the progress being displayed in the <code>canSeekTrack</code> state, we also want to make sure that this is still composed as expected when the <code>canSeekTrack</code> flag has been provided as <code>false</code>. We’ll write a new test, <code>Track_Progress_Displayed_When_Cannot_Seek</code>, which takes exactly the same form as the previous, except the <code>PlayerSeekBar</code> composable is composed with the <code>canSeekTrack</code> provided as <code>false</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Progress_Displayed_When_Cannot_Seek</span>() {
    <span class="syntax-all syntax-keyword">val</span> nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> nowPlaying,
            canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEEK_BAR</span>)
        .assertRangeInfoEquals(
            <span class="syntax-all syntax-entity">ProgressBarRangeInfo</span>(
                current <span class="syntax-all syntax-keyword">=</span> nowPlaying.position.toFloat() <span class="syntax-all syntax-keyword">/</span> 
					nowPlaying.track.length.toFloat(),
                range <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>..<span class="syntax-all syntax-constant">1f</span>,
                steps <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0</span>
            )
        )
}</code></pre>

<h3>Testing progress modification</h3>

<p>Alongside the display of the current progress, the <code>Seekbar</code> also supports the seeking of audio via touch gestures on the composable. When this occurs, the <code>onSeekChanged</code> lambda that is provided to the <code>PlayerSeekBar</code> composable should be triggered with the updated progress. We’re going to start by writing a test to assert that this lambda is triggered when expected. We’ll compose the <code>PlayerSeekBar</code> in a similar way to the previous tests, except this time we’re going to provide a mock implementation of the <code>onSeekChanged</code> lambda</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Progress_Updated_When_Can_Seek</span>() {
    <span class="syntax-all syntax-keyword">val</span> seekListener<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">progress</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(),
            canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            onSeekChanged <span class="syntax-all syntax-keyword">=</span> seekListener
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEEK_BAR</span>)
        .performTouchInput {
            swipeLeft()
        }

    verify(seekListener, atLeastOnce()).invoke(any())
}</code></pre>

<p>We’re next going to want to perform a touch gesture on the <code>Seekbar</code>, so we’ll locate the node using the <code>TAG_SEEK_BAR</code>, followed by using the <code>performTouchInput</code> function to trigger the <code>swipeLeft</code> action. When this happens, the gesture should trigger the <code>onSeekChanged</code> lambda which we can verify using mockitos <code>verify</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Progress_Updated_When_Can_Seek</span>() {
    <span class="syntax-all syntax-keyword">val</span> seekListener<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">progress</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(),
            canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            onSeekChanged <span class="syntax-all syntax-keyword">=</span> seekListener
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEEK_BAR</span>)
        .performTouchInput {
            swipeLeft()
        }

    verify(seekListener, atLeastOnce()).invoke(any())
}</code></pre>

<p>In the case where the <code>canSeekTrack</code> argument is provided to our composable as <code>false</code>, we wouldn’t expect the same outcome as the test above. We’ll execute the same test code as above with this modified flag, except this time asserting that the provided <code>onSeekChanged</code> lambda is never triggered when the swipe gesture is performed on the <code>Seekbar</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Progress_Not_Updated_When_Cannot_Seek</span>() {
    <span class="syntax-all syntax-keyword">val</span> seekListener<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">progress</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerSeekBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(),
            canSeekTrack <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
            onSeekChanged <span class="syntax-all syntax-keyword">=</span> seekListener
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SEEK_BAR</span>)
        .performTouchInput {
            swipeLeft()
        }

    verify(seekListener, never()).invoke(any())
}</code></pre>

<hr />

<h2>Testing the Player Bar</h2>

<p>Now that we’ve tested the seek bar composable, we’re going to go up one level and test the composables that utilise this - starting at the <code>PlayerBar</code>. For this, we’ll start by creating a new test class, <code>PlayerBarTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">PlayerBarTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()


}</code></pre>

<h3>Testing the track title</h3>

<p>Within the player bar, we display information regarding the track that is currently playing. To ensure that the correct information is being displayed for a track, we’re going to assert that the composables are displaying the expected information.</p>

<p>We’ll start here by testing the display of the track title. So that we can perform these assertions, we’re going to need to add a new tag for use in our tests.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_TRACK_TITLE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_TRACK_TITLE&quot;</span>
}</code></pre>

<p>We next need to assign this tag to the <code>Text</code> composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PlayerBar.kt
</span><span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_TRACK_TITLE</span>),
	...
)</code></pre>

<p>With this tag in place, we can now move on to writing a test to assert the information is displayed as expected. We’ll start here by composing a <code>PlayerBar</code>, passing in a reference to a <code>Track</code></p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(
                track <span class="syntax-all syntax-keyword">=</span> track
            ),
            toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<h3>Testing the track artist</h3>

<p>Next, we need to locate the node that is tagged using <code>TAG_TRACK_TITLE</code>. When locating the node, we need to utilise the <code>useUnmergedTree</code> flag - this is because within the <code>PlayerBar</code> composable we are merging the descendants, so we need to use the unmerged tree in-order to locate the specific node. When we have this node, we can then assert that the text equals the expected state of the track <code>title</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Title_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(
                track <span class="syntax-all syntax-keyword">=</span> track
            ),
            toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(
		<span class="syntax-all syntax-entity">TAG_TRACK_TITLE</span>, 
		useUnmergedTree <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	)
    .assertTextEquals(track.title)
}</code></pre>

<p>We’re next going to do the same for the artist of the <code>Track</code>. We’ll need to start here by adding another tag for use in our tests.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_TRACK_ARTIST</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_TRACK_ARTIST&quot;</span>
}</code></pre>

<p>Next, we’ll apply this tag to the corresponding composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PlayerBar.kt
</span>
<span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_TRACK_ARTIST</span>),
	...
)</code></pre>

<p>We’ll then go and write a similar test that was used to assert the display of the track title, except this time validating that the track <code>artist</code> is being displayed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Track_Artist_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(
                track <span class="syntax-all syntax-keyword">=</span> track
            ),
            toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(
		<span class="syntax-all syntax-entity">TAG_TRACK_ARTIST</span>, 
		useUnmergedTree <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
	).assertTextEquals(track.artist)
}</code></pre>

<h3>Testing the track playback state</h3>

<p>Alongside testing the title and artist information is displayed correctly, we’re going to want to assert that the playback state is being displayed correctly. This means that:</p>

<ul>
	<li> if the track is currently being played, the pause button should be shown</li>
	<li>if the track is currently paused, the play button should be shown</li>
</ul>

<p>To be able to assert these expected cases, we’re going to start by adding a new tag for use in our tests:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span><span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PLAY_PAUSE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_PLAY_PAUSE&quot;</span>
}</code></pre>

<p>Next, we’ll add this tag to the <code>IconButton</code> used to display the playback state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PlayerBar.kt
</span>
<span class="syntax-all syntax-entity">IconButton</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_PLAY_PAUSE</span>),
	onClick <span class="syntax-all syntax-keyword">=</span> {
		toggleNowPlayingState()
	}
)</code></pre>

<p>With this tag in place, we’re going to start with asserting that the <strong>playing</strong> state is being composed as expected. We’ll need to compose the <code>PlayerBar</code>, providing the information for the currently playing <code>state</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playing_State_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(
                track <span class="syntax-all syntax-keyword">=</span> track,
                state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>
            ),
            toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>Next, we’ll use this tag to assert that the content description matches the description for the pause action. Because we can’t easily test the visual content of the <code>IconButton</code> composable, we can instead test against the content description applied to the composable. Because when the playback state is <strong>PLAYING</strong>, the icon will display the pause action which will, in turn, have the pause content description which we can test for using the <code>assertContentDescriptionEquals</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Playing_State_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(
                track <span class="syntax-all syntax-keyword">=</span> track,
                state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PLAYING</span>
            ),
            toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAY_PAUSE</span>)
        .assertContentDescriptionEquals(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.cd_pause)
		)
}</code></pre>

<p>Similarly, we also want to test that the correct state is displayed when the player is in the <strong>PAUSED</strong> state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Paused_State_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> track <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeTrack()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">PlayerBar</span>(
            nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying(
                track <span class="syntax-all syntax-keyword">=</span> track,
                state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">NowPlayingState</span>.<span class="syntax-all syntax-entity">PAUSED</span>
            ),
            toggleNowPlayingState <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAY_PAUSE</span>)
        .assertContentDescriptionEquals(
            <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
				.targetContext.getString(<span class="syntax-all syntax-entity">R</span>.string.cd_play)
        )
}</code></pre>

<p>When it comes to the <code>Player</code> composable, you’ll find tests that match the above within the sample code - we won’t go through these here as the content is duplicated for each composable test.</p>

<hr />

<h2>Testing the Music Player</h2>

<p>Now that we have tests in place for the individual player composables, we’re going to add some test coverage for the <code>MusicPlayer</code>. This composable has the responsibility of composing either the <code>PlayerBar</code> or <code>Player</code> based on the current state, so we’ll want to test that things are being composed as expected. We’re going to hold these tests in a new test class, <code>MusicPlayerTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">MusicPlayerTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>We’re going to first test that the player bar is displayed when the backdrop state represents the <strong>Revealed</strong> state. We’ll start here by composing the <code>MusicPlayer</code>, providing a <code>BackdropScaffoldState</code> that represents the <code>Revealed</code> state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Collapsed_Player_Bar_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
            initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
        )
        <span class="syntax-all syntax-entity">MusicPlayer</span>(
            scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>With this composition in place, we can use the previously assigned <code>TAG_PLAYER_BAR</code> tag to perform the <code>assertIsDisplayed</code> check. When this test runs, a successful result will mean that the collapsed player bar is being displayed in the expected scenario.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Collapsed_Player_Bar_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
            initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
        )
        <span class="syntax-all syntax-entity">MusicPlayer</span>(
            scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span>)
        .assertIsDisplayed()
}</code></pre>

<p>When the collapsed player is displayed, we expected the full-screen player to not be composed on the screen. We’re going to write a test to assert that this is the case. To do this, we’ll need to start by adding a new tag for our tests.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_PLAYER</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_PLAYER&quot;</span>
}</code></pre>

<p>We can then assign this to the corresponding composable in the <code>MusicPlayer</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicPlayer.kt
</span>
<span class="syntax-all syntax-entity">Player</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		.fillMaxSize()
		.testTag(<span class="syntax-all syntax-entity">TAG_PLAYER</span>),
	...
)</code></pre>

<p>With this in place, we can now use this tag to assert that the <code>Player</code> composable is not being composed when the backdrop scaffold is in a <code>Revealed</code> state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Never_Revealed_While_Player_Bar_Collapsed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
            initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Revealed</span>
        )
        <span class="syntax-all syntax-entity">MusicPlayer</span>(
            scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER</span>)
        .assertDoesNotExist()
}</code></pre>

<p>Along with asserting the correct state for the collapsed player, we’re also going to want to be sure that the full-screen player is composed when expected. These tests are going to look very similar to the previous tests - we’ll start with ensuring that the full-screen player is composed when the backdrop scaffold is in the <code>Concealed</code> state. Once this has been composed, we can use the <code>TAG_PLAYER</code> tag to assert that the composable is displayed when in this state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Revealed_Player_Bar_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
            initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Concealed</span>
        )
        <span class="syntax-all syntax-entity">MusicPlayer</span>(
            scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER</span>)
        .assertIsDisplayed()
}</code></pre>

<p>We’ll also want to ensure that when the fullscreen player is composed, the <code>PlayerBar</code> composable is not. While still composing in the <code>Concealed</code> state, we’ll use the <code>TAG_PLAYER_BAR</code> tag to locate the node for the player bar, along with the <code>assertDoesNotExist</code> function to assert that the composition for the player bar has not taken place.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Player_Bar_Never_Displayed_When_Player_Revealed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-keyword">val</span> scaffoldState <span class="syntax-all syntax-keyword">=</span> rememberBackdropScaffoldState(
            initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">BackdropValue</span>.<span class="syntax-all syntax-entity">Concealed</span>
        )
        <span class="syntax-all syntax-entity">MusicPlayer</span>(
            scaffoldState <span class="syntax-all syntax-keyword">=</span> scaffoldState,
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MusicDashboardState</span>(
                nowPlaying <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TestDataFactory</span>.makeNowPlaying()
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_PLAYER_BAR</span>)
        .assertDoesNotExist()
}</code></pre>

<hr />

<h1>Building a Graphs Dashboard</h1>

<p>When it comes to building mobile applications, there is a vast range of UI components available for it to build out features. While in most cases these UI components provide us with the elements we need to build features, there are sometimes going to be things that we need to create ourselves - some of these things will be at a lower level, often involving custom drawing on a canvas. Knowing how to draw and manage a canvas is an invaluable skill in Android development, something which is just as important when it comes to Jetpack Compose.</p>

<p>To help us learn more about drawing on the Canvas with Jetpack Compose we’re going to build out a small Graphing application. We’ll completely draw the data for these graphs using the <code>Canvas</code> composable, while also utilising some of the compose animation APIs to allow us to animate the drawing of our datasets.</p>

<figure><img src="compppp.png"/></figure>

<h1>Defining the State</h1>

<p>When it comes to the display of graphs, we’re going to need to model the state, as well as the classes that make up the information held within it. In this section of the chapter, we’re going to create these different models, as well as construct the state class used to represent the graphs screen.</p>

<h2>Modelling the Graph Types</h2>

<p>Within this feature, we’re going to be displaying a collection of different graphs. Each of these graphs is going to use the same dataset, but this dataset will be communicated to the user in a different way (based on the currently selected graph type). We’re going to be supporting six different types of graphs, so we’ll define a new enum class that will allow us to model the different graph types.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphType</span> {
    <span class="syntax-all syntax-entity">PIE</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_pie),
    <span class="syntax-all syntax-entity">LINE</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_line),
    <span class="syntax-all syntax-entity">BAR</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_bar),
    <span class="syntax-all syntax-entity">COLUMN</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_column),
    <span class="syntax-all syntax-entity">DOUGHNUT</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_doughnut),
    <span class="syntax-all syntax-entity">AREA</span>(<span class="syntax-all syntax-entity">R</span>.string.app_name)
}</code></pre>

<p>While this allows us to define the types of graphs that are available, we’ll also want a corresponding way to communicate these graph types back to the user. For this reason, we’re also going to assign a human-readable string to each of the graph enum values. We’ll start by adding these strings to the <code>strings.xml</code> resources for this feature.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;graph_pie&quot;</span>&gt;Pie&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;graph_line&quot;</span>&gt;Line&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;graph_bar&quot;</span>&gt;Bar&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;graph_column&quot;</span>&gt;Column&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;graph_doughnut&quot;</span>&gt;Doughnut&lt;/<span class="syntax-all syntax-tag">string</span>&gt;
&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;graph_area&quot;</span>&gt;Area&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>We’ll then need to allow a resource reference to be provided for each enum value, which we’ll define via the <code>GraphType</code> constructor.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphType</span>(<span class="syntax-all syntax-keyword">@StringRes</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>)</code></pre>

<p>Finally, we can take each of the human-readable strings and assign them to the corresponding <code>GraphType</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">enum</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphType</span>(<span class="syntax-all syntax-keyword">@StringRes</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>) {
    <span class="syntax-all syntax-entity">PIE</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_pie),
    <span class="syntax-all syntax-entity">LINE</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_line),
    <span class="syntax-all syntax-entity">BAR</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_bar),
    <span class="syntax-all syntax-entity">COLUMN</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_column),
    <span class="syntax-all syntax-entity">DOUGHNUT</span>(<span class="syntax-all syntax-entity">R</span>.string.graph_doughnut),
    <span class="syntax-all syntax-entity">AREA</span>(<span class="syntax-all syntax-entity">R</span>.string.app_name)
}</code></pre>

<hr />

<h2>Modelling the Graph Data</h2>

<p>Alongside the different types of graphs that are going to be supported by our feature, we’re going to need to allow the definition of the different data entries for our graph. As per the screenshots in the introduction, each graph entry is going to have a:</p>

<ul>
	<li><strong>label</strong> - the label used to represent the entry in the graph</li>
	<li><strong>value</strong> - the value for the entry in the graph</li>
	<li><strong>color</strong> - the color to be used when drawing the entry</li>
</ul>

<p>To model this information, we’ll create a new class, <code>GraphData</code>. We’ll define a property to represent each of these values, making them all required when instantiating a <code>GraphData</code> instance.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphData</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">value</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>
)</code></pre>

<hr />

<h2>Modelling the Screen State</h2>

<p>When it comes to the screen for our feature, several pieces of information are going to need to be persisted at a global level. At a high-level, our composable UI needs to know</p>

<ul>
	<li>the currently selected chart </li>
	<li>whether the chart picker should currently be shown</li>
	<li>the data to be drawn on the graph</li>
</ul>

<p>To model this, we’ll create a new class, <code>GraphsState</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsState</span>()</code></pre>

<p>For the currently selected graph, we’ll define a new property, assigning this a default value of the <code>LINE</code> chart type.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">selectedChart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ChartType</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ChartType</span>.<span class="syntax-all syntax-entity">LINE</span>
)</code></pre>

<p>When it comes to knowing whether or not the chart picker should be displayed, we can model this using a simple Boolean value</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">selectedChart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ChartType</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ChartType</span>.<span class="syntax-all syntax-entity">LINE</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">showChartPicker</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
)</code></pre>

<p>In regards to the chart data, we’re going to need to model this as a list of <code>ChartData</code> references. As we don’t have any ‘real’ data coming from any source, we’ll create a factory class that will allow us to create some fake data.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GraphsDataFactory.kt
</span>
<span class="syntax-all syntax-keyword">object</span> GraphsDataFactory {

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">makeChartData</span>()<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt; {
        <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-constant">listOf</span>(
            <span class="syntax-all syntax-entity">GraphData</span>(<span class="syntax-all syntax-string">&quot;2016&quot;</span>, <span class="syntax-all syntax-constant">20</span>, <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Red</span>),
            <span class="syntax-all syntax-entity">GraphData</span>(<span class="syntax-all syntax-string">&quot;2017&quot;</span>, <span class="syntax-all syntax-constant">10</span>, <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Blue</span>),
            <span class="syntax-all syntax-entity">GraphData</span>(<span class="syntax-all syntax-string">&quot;2018&quot;</span>, <span class="syntax-all syntax-constant">2</span>, <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Yellow</span>),
            <span class="syntax-all syntax-entity">GraphData</span>(<span class="syntax-all syntax-string">&quot;2019&quot;</span>, <span class="syntax-all syntax-constant">42</span>, <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Green</span>),
            <span class="syntax-all syntax-entity">GraphData</span>(<span class="syntax-all syntax-string">&quot;2020&quot;</span>, <span class="syntax-all syntax-constant">7</span>, <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Magenta</span>),
            <span class="syntax-all syntax-entity">GraphData</span>(<span class="syntax-all syntax-string">&quot;2021&quot;</span>, <span class="syntax-all syntax-constant">5</span>, <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Cyan</span>),
        )
    }
}</code></pre>

<p>With this in place, we can now add this chart data to our model in the form of a <code>GraphData</code> list, providing a default set of data using this factory class. We won’t be modifying this state value at any point, so the factory will always be used to provide the graph data as the state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsState</span>(
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">selectedChart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ChartType</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">ChartType</span>.<span class="syntax-all syntax-entity">LINE</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">showChartPicker</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
    <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">ChartData</span>&gt; <span class="syntax-all syntax-keyword">=</span> 
		<span class="syntax-all syntax-entity">GraphsDataFactory</span>.makeChartData()
)</code></pre>

<p>With this in place, we now have the required data that can be used to make up the state of our screen.</p>

<hr />

<h1>Creating the View Model</h1>

<p>Now that we have the state modelled for our Graphs Dashboard, we can start thinking about the ViewModel that will be used to manage that state and provide a way to orchestrate it to the user interface. </p>

<hr />

<h2>Setting up the ViewModel</h2>

<p>Before we can get started here, we’re going to add a new dependency to our project that will give us access to the Android Lifecycle ViewModel class:</p>

<pre><code class="code-highlighted code-kt">implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span></code></pre>

<p>💡 You aren’t required to use a ViewModel when working with compose. For the sake of these exercises, it helps us to keep things simple and follow an approach that many developers are familiar with.</p>

<p>Next, we’ll create a new ViewModel, called <code>GraphsViewModel</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GraphsViewModel.kt
</span>
<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsViewModel</span> <span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>()</code></pre>

<p>This <code>ViewModel</code> is going to need to hold a reference to the state of our screen. For this we’re going to utilise <code>StateFlow</code> - this allows us to create a state-holder observable flow that will emit the default state we provide to it, along with any updates that occur during its lifetime. Here we’ll create a new <code>MutableStateFlow</code> instance, providing a reference to our <code>GraphsState</code> class as the default value for our <code>StateFlow</code>:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// MusicViewModel.kt
</span>
<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsViewModel</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    <span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">GraphsState</span>())

}</code></pre>

<p>With this in place, we now have a StateFlow reference that is holding a reference to our authentication state, initialising it with a new instance of the state class and relying on the defaults that the constructor provides.</p>

<hr />

<h2>Manipulating state using events</h2>

<p>While this state is now in place, we need to start thinking about the different ways in which it can be manipulated - whenever something is changed in our UI (such as a graph type selected), we’ll want to update the state within our ViewModel so that the observing UI can reflect those changes. </p>

<p>For when this is the case, we’re going to model some events that can be triggered in our composable UI and in turn these events will be used to manipulate the state within the view model. This allows us to have a single way of our composable UI communicating with the ViewModel, rather than needing to pass the entire ViewModel or many references to separate functions which could be used to trigger state changes. Instead, we can pass a single function reference to our composable UI which can then be used to trigger these events in the ViewModel. For these events we’re going to need to define different types that can be triggered, so we’ll go ahead and create a new sealed class to represent these.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GraphsEvent.kt
</span>
<span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsEvent</span></code></pre>

<p>In this class, we’re next going to define the different events that can be triggered to update the state of our UI. Within our <code>GraphsState</code> state we defined a <code>showChartPicker</code> property - this is used to depict whether the chart picker component should be composed. So that this state can be updated accordingly, we’ll need to add some event types. We’ll add two new events here - one for the display of the chart picker, and another that can be used to dismiss the picker.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> ShowPicker<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> DismissPicker<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>()
}</code></pre>

<p>With these events in place, we’re going to need to handle these within our<code>GraphsViewModel</code>, updating the state accordingly. So that we can handle the different event types represented by our <code>GraphsEvent</code> class, we’re going to add a new function to our <code>GraphsViewModel</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsViewModel</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    <span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">GraphsState</span>())

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">event</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>) {
        
    }
}</code></pre>

<p>Within this function, we’re now going to want to handle the event types that we’ve declared so far. Whenever the <code>ShowPicker</code> or <code>DismissPicker</code> events are triggered, we’re going to want to update our state reference so that the <code>showChartPicker</code> property is set to the corresponding value - this will be <code>true</code> when the picker is to be shown, and <code>false</code> when otherwise.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsViewModel</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    <span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">GraphsState</span>())

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleStocksEvent</span>(<span class="syntax-all syntax-parameter">event</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (event) {
			<span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">ShowPicker</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    showChartPicker <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>
                )
            }
            <span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">DismissPicker</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    showChartPicker <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
                )
            }
        }
    }
}</code></pre>

<p>Alongside the display of the chart picker, we also need to be able to handle the case where the user selects a graph from this picker - as this will need to change the graph being displayed on-screen. To handle this case we’re going to add a new event, <code>SetChartType</code>. This class will take a <code>GraphType</code> in its constructor which can be used to update our state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">sealed</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsEvent</span> {

    <span class="syntax-all syntax-keyword">object</span> ShowPicker<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>()

    <span class="syntax-all syntax-keyword">object</span> DismissPicker<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>()

	<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SetCharType</span>(<span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>()
}</code></pre>

<p>We’ll then handle this event within our <code>handleEvent</code> function. Here we’ll simply set the <code>selectedChart</code> property in our state, while at the same time dismissing the chart picker (as we no longer want to show the picker when a new graph type has been selected).</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsViewModel</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ViewModel</span>() {

    <span class="syntax-all syntax-keyword">val</span> uiState <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">MutableStateFlow</span>(<span class="syntax-all syntax-entity">GraphsState</span>())

    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">handleEvent</span>(<span class="syntax-all syntax-parameter">event</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>) {
        <span class="syntax-all syntax-keyword">when</span> (event) {
            ...
            <span class="syntax-all syntax-keyword">is</span> <span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">SetChartType</span> <span class="syntax-all syntax-keyword">-&gt;</span> {
                uiState.value <span class="syntax-all syntax-keyword">=</span> uiState.value.copy(
                    selectedChart <span class="syntax-all syntax-keyword">=</span> event.chart,
                    showChartPicker <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>
                )
            }
        }
    }
}</code></pre>

<hr />

<p>With this implemented, we are now managing the state of our graphs dashboard screen and providing the required entry points for our UI layer to manipulate the state based on user interaction. Our view model is now ready to be plugged into a composable UI, which we’ll create in the next section of this chapter!</p>

<h1>Building the Graphs UI</h1>

<p>With the view model and state management all in place, we’re ready to move on and start implementing the composable UI for our Graphs app. With this UI we’re going to be building out 6 different kinds of graphs, with each taking the provided data and animating the dataset onto the screen. When we’re finished building this UI, we’re going to end up with something that looks like the following:</p>

<figure><img src="compppp-1.png"/></figure>

<hr />

<h2>Setting up the entry point</h2>

<p>Before we can get start building our project, we’re going to need to add a couple of dependencies that we’re going to need. We’ll start here by adding these to the <code>build.gradle</code> file for our new project:</p>

<pre><code class="code-highlighted code-kt">implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.foundation:foundation:$compose_version&quot;</span>
implementation <span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui:$compose_version&quot;</span>
implementation 
	<span class="syntax-all syntax-string">&quot;androidx.compose.material:material:$compose_version&quot;</span>
implementation <span class="syntax-all syntax-string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.4.0&quot;</span></code></pre>

<p>The current release of this book is building against 1.1.0 of compose - be sure to check compatibly if using a newer version.</p>

<ul>
	<li><strong>foundation</strong>: provides foundational composables, such as layouts and commonly required modifiers</li>
	<li><strong>ui</strong>: provides access to ui related composables, such as drawing and general components</li>
	<li><strong>material</strong>: provides access to compose material UI components</li>
	<li><strong>lifecycle-viewmodel-compose</strong>: provides functionality for providing view models directly inside of composables</li>
</ul>

<p>With these added to our project, we’re now ready to start building out our UI. We’re going to start here by building the access point to our feature - this is how the messaging feature will initially be composed within our user interface. To make this an argument-less access point, we’re going to start with a new composable function, <code>Graphs</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Graphs.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Graphs</span>()</code></pre>

<p>While you won’t see anything visual just yet, you’ll want to compose this <code>Graphs</code> composable within the <code>setContent</code> block of the activity that was created through the project wizard. Then as we build out the project, we’ll be able to visualise the <code>Graphs</code> when running the project.</p>

<p>Before we get started with any composition of messaging specific UI, we’re going to start by declaring the use of the <code>MaterialTheme</code> composable, this will be in place ready to wrap any composition and apply the expected material theming to our project. This isn’t a requirement, but if not provided then you would need to manually style each composable to adhere to material requirements. We’re not going to be doing any theme customisation here, so this will be using the default colors.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Graphs.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Graphs</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
        ...
    }
}</code></pre>

<p>We can see here that we currently have a blank <code>content</code> block, this means that nothing is currently going to be composed in our UI. As mentioned previously, this is just an argument-less entry point to our feature, but we’re going to need access to the state configuration that we set up over the last few chapters. Here, we’re going to utilise the ViewModel related dependency that we added to our project. Using its <code>viewModel()</code> function, we’ll go ahead and retrieve an instance of the <code>GraphsViewModel</code>. This will return an existing reference to the ViewModel, creating a new one if it does not currently exist.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Graphs.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Graphs</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()
}</code></pre>

<p>With this in place, we have our ViewModel, as well as access to our state through this ViewModel. Now though, we need to set ourselves up to be able to compose UI based on this state. Here we’re going to create a separate composable function that takes the <code>GraphsState</code> class, composing UI from it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GraphsDashboard.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GraphsDashboard</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsState</span>
)</code></pre>

<p>💡 Declaring a Modifier argument for your composable functions allows the layout constraints of the composable to be delegated to the parent. This helps to keep your composables reusable, as they are not being constrained for a specific scenario.</p>

<p>Not only does having this separate composable keep the responsibilities of our composable functions smaller, but it also will help us with testing later on. Having this separate <code>GraphsDashboard</code> composable with a <code>GraphsState</code> argument means that we can provide state within our tests, and perform assertions based on the expected composition from our state. Testing against an argument-less composable function would require us to interact with the UI to manipulate the state, which adds friction during the testing process.</p>

<p>Now that we have this composable in place, we’re ready to compose this inside of our <code>Graphs</code> composable. We can provide two arguments to our <code>GraphsDashboard</code> - <code>modifier</code> and <code>state</code>, which the second is <strong>required</strong>. For the <code>modifier</code>, we’ll simply utilise the <code>fillMaxSize</code> modifier - which will instruct the contained composable to use all of the size that it has available to it.</p>

<p>We’ll also need to provide a reference to a <code>GraphsState</code>, which we’ll access through our <code>GraphsViewModel</code>. Here we’re going to use the <code>collectAsState()</code> - because our state is represented within our ViewModel as a <code>StateFlow</code>, we’re going to want to collect the events from here. <code>collectAsState()</code> allows us to collect the emissions from our <code>StateFlow</code> as composable state, meaning that our composables can be recomposed accordingly whenever the state is changed. We’ll need to access the <code>value</code> from the <code>StateFlow</code> and pass this directly to the <code>state</code> argument of our <code>Graphs</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Graphs.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Graphs</span>() {
    <span class="syntax-all syntax-keyword">val</span> viewModel<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsViewModel</span> <span class="syntax-all syntax-keyword">=</span> viewModel()
    <span class="syntax-all syntax-entity">GraphsDashboard</span>(
        state <span class="syntax-all syntax-keyword">=</span> viewModel.uiState.collectAsState().value,
        handleEvent <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-parameter">viewModel</span>::handleStocksEvent
    )
}</code></pre>

<p>At this point, we won’t be able to see anything being composed within our UI, but we’re all set up and ready to start building out our messaging interface.</p>

<hr />

<h2>Building the Arc Chart</h2>

<p>Within our Graphs dashboard, there are two graphs that take the form of an arc - these are the pie and doughnut charts. The logic used to build both of these charts is very similar, so we’re going to be writing a reusable composable that will allow us to compose both a pie and doughnut chart using mostly the same code. We’re going to place this reusable code inside a new composable function, <code>ArcChart</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
)</code></pre>

<p>When it comes to drawing the chart, we’re going to be utilising the <code>Canvas</code> composable. This allows us to have complete control over what we are drawing on screen - allowing us to draw the custom shapes and labels that make up the graph. When composing this we’ll utilise the <code>size</code> modifier to fix the size of the <code>Canvas</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
) { 
    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
    ) {
        
    }
}</code></pre>

<p>💡 We use the size modifier here so that we can define how much space the composable needs to occupy on the screen. Because we are custom drawing the contents of the canvas, the composition does not know how much space is required. For this reason, we need to manually define the space to be occupied.</p>

<p>Now that we have the <code>Canvas</code> defined, we can start to think about what we’re going to be drawing inside of it. For this, we’re going to utilise the <code>GraphData</code> class that was previously defined - this class contains the value for a graph entry, so we’re going to modify our composable function to take a list reference for the <code>GraphData</code> type. We’ll then want to loop through this data list so that we can draw the visual representation for the data entry.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
    ) {
        chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>

        }
    }
}</code></pre>

<p>Within this loop, we’re going to want to draw the information for the corresponding data point. In the case of the circular graphs, we’re going to need to draw an arc for each of the data entries, for which we can utilise the <code>drawArc</code> function.</p>

<pre><code class="code-highlighted code-kt">chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>        
	drawArc(
		...
	)
}</code></pre>

<p>This function allows us to draw an arc inside of the corresponding <code>Canvas</code>. While we’re now making a call to this function, things aren’t going to compile yet because we’re missing some of the information that is required by the function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">drawArc</span>(
	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>,
    <span class="syntax-all syntax-parameter">startAngle</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>,
    <span class="syntax-all syntax-parameter">sweepAngle</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>,
    <span class="syntax-all syntax-parameter">useCenter</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">topLeft</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Offset</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>.<span class="syntax-all syntax-entity">Zero</span>,
    <span class="syntax-all syntax-parameter">size</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Size</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">this</span>.size.offsetSize(topLeft),
    <span class="syntax-all syntax-keyword">/*@FloatRange</span>(<span class="syntax-all syntax-constant">from</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.0</span>, to <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1.0</span>)*/
    alpha<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1.0f</span>,
    style<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Fill</span>,
    colorFilter<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ColorFilter?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    blendMode<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">BlendMode</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">DefaultBlendMode</span>
)</code></pre>

<p>To satisfy the requirements of the <code>drawArc</code> function, as well as be able to draw the arc for the corresponding data point, we’re going to need to calculate the angles to be used for the drawing of the arc.</p>

<p>When it comes to working out the angle that each graph entry is going to occupy, we’re going to need to calculate this using the information that we have available to us. We know that the total angle of a circle is 360 degrees - so given the data set that we have, we need to calculate the angle of each data entry. We can calculate this using the following formula:</p>

<p>(data value <strong>divided by</strong> total sum of data) <strong>multiplied by</strong> 360</p>

<figure><img src="circ.png"/></figure>

<p>We first need the sum of the entire data set that is provided to the function - here we can use the <code>sumOf</code> Kotlin function to calculate the complete sum of values from our data set. Next, we’re going to take the above formula and use this to calculate the angle for each entry within the data set, so we’ll place this within the loop of our <code>GraphData</code> collection.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {

    <span class="syntax-all syntax-keyword">val</span> sumOfDataSet <span class="syntax-all syntax-keyword">=</span> remember(chartData) { 
		chartData.sumOf { it.value } 
	}

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
    ) {
        chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">val</span> segmentAngle <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">360</span> <span class="syntax-all syntax-keyword">*</span> 
				chartData.value <span class="syntax-all syntax-keyword">/</span> sumOfDataSet
        }
    }
}</code></pre>

<p>As we loop through the data set, we’re going to be drawing an arc for each entry. For this reason, we’re going to need to keep a track of the angle of the circle that has been drawn so far - this means we will be drawing the circle segment by segment, building on the segments that were drawn before the current entry.</p>

<figure><img src="previous.png"/></figure>

<p>So that we can keep track of this, we’re going to add a new variable outside of the <code>GraphData</code> loop, modifying its value each time the <code>segmentAngle</code> value has been calculated.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {

    <span class="syntax-all syntax-keyword">val</span> sumOfDataSet <span class="syntax-all syntax-keyword">=</span> remember(chartData) { 
		chartData.sumOf { it.value } 
	}

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
    ) {
        
        <span class="syntax-all syntax-keyword">val</span> radius <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>
		<span class="syntax-all syntax-keyword">var</span> currentSegment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>

        chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">val</span> segmentAngle <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">360</span> <span class="syntax-all syntax-keyword">*</span> 
				chartData.value <span class="syntax-all syntax-keyword">/</span> sumOfDataSet

			<span class="syntax-all syntax-comment">// draw segment
</span>
            currentSegment <span class="syntax-all syntax-keyword">+=</span> segmentAngle
        }
    }
}</code></pre>

<p>Now that we have both the current segment angle and the total drawn angle, we can use these values to draw the segment. We’re going to be provided 4 different values to the <code>drawArc</code> function to draw the segment:</p>

<ul>
	<li><strong>color</strong> - the Color to be used when drawing the arc. For this, we’ll provide the Color value for the corresponding <code>GraphData</code> entry.</li>
	<li><strong>startAngle</strong> - the starting angle for drawing the arc, is going to be equal to the end of the previously drawn arc. We previously declared the <code>currentSegment</code> variable which is being used to keep a track of the total angle of the graph that has currently been drawn. We’re always going to want to start drawing at this value, as it represents the end of the previously drawn segment.</li>
	<li><strong>sweepAngle</strong> - the angle of the arc to be drawn. We are currently calculating the angle of the corresponding <code>GraphData</code> in the form of the <code>segmentAngle</code> variable - so for this, we’ll directly pass this value.</li>
	<li><strong>useCenter</strong> - this value is used to declare whether the arc should close at the center of the corresponding area. </li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;,
    <span class="syntax-all syntax-parameter">useCenter</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>
) {

    <span class="syntax-all syntax-keyword">val</span> sumOfDataSet <span class="syntax-all syntax-keyword">=</span> remember(chartData) { 
		chartData.sumOf { it.value } 
	}

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">var</span> currentSegment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
        <span class="syntax-all syntax-keyword">val</span> radius <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>
        <span class="syntax-all syntax-keyword">val</span> totalAngle <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">360</span>

        chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">val</span> segmentAngle <span class="syntax-all syntax-keyword">=</span> totalAngle <span class="syntax-all syntax-keyword">*</span> 
				chartData.value <span class="syntax-all syntax-keyword">/</span> sumOfDataSet
            drawArc(
				color <span class="syntax-all syntax-keyword">=</span> chartData.color,
                startAngle <span class="syntax-all syntax-keyword">=</span> currentSegment,
                sweepAngle <span class="syntax-all syntax-keyword">=</span> segmentAngle.toFloat(),
                useCenter <span class="syntax-all syntax-keyword">=</span> useCenter
            )
            currentSegment <span class="syntax-all syntax-keyword">+=</span> segmentAngle
        }
    }
}</code></pre>

<p>With the above in place, we’ll be able to see a graph being drawn, but it is currently not looking quite like how we would expect.</p>

<figure><img src="ra.png"/></figure>

<p>We can see that a circular graph is being drawn, but the segments don’t quite match up to what we’d expect. The values we have calculated for the graph are correct, but we’re missing some information for the <code>drawArc</code> function that will help to ensure the graph is being drawn correctly. This information is to be provided in the form of the <code>DrawStyle</code> class, which is used to declare how a shape should be drawn within a canvas. This information is going to look different depending on the type of circular graph that is being drawn, so we’re going to allow this to be passed into the <code>ArcChart</code> composable function. We’ll then want to pass this value directly to the <code>drawArc</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;,
    <span class="syntax-all syntax-parameter">style</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span>
) {
    <span class="syntax-all syntax-keyword">val</span> sumOfDataSet <span class="syntax-all syntax-keyword">=</span> remember(chartData) { 
		chartData.sumOf { it.value } 
	}

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">var</span> currentSegment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
        <span class="syntax-all syntax-keyword">val</span> totalAngle <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">360</span>

        chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">val</span> segmentAngle <span class="syntax-all syntax-keyword">=</span> totalAngle <span class="syntax-all syntax-keyword">*</span> 
				chartData.value <span class="syntax-all syntax-keyword">/</span> sumOfDataSet
            drawArc(
                color <span class="syntax-all syntax-keyword">=</span> chartData.color,
                startAngle <span class="syntax-all syntax-keyword">=</span> currentSegment,
                sweepAngle <span class="syntax-all syntax-keyword">=</span> segmentAngle.toFloat(),
                useCenter <span class="syntax-all syntax-keyword">=</span> useCenter,
                style <span class="syntax-all syntax-keyword">=</span> style
            )
            currentSegment <span class="syntax-all syntax-keyword">+=</span> segmentAngle
        }
    }
}</code></pre>

<p>Within the preview of our composable, we can now provide a reference to a <code>DrawStyle</code> to be used for the composition of the graph. For this first type of arc graph, we’re going to be drawing a doughnut chart - this means that each segment should only have a specific width, as opposed to it filling the whole circle area within the canvas. To create this effect we’re going to use the <code>Stroke</code> style, this allows us to draw each segment of the graph as a stroke. Because we’re drawing a graph, we’re going to want this to be quite thick - so we’ll provide a value of <code>150dp</code> for the width argument of the <code>Stroke</code>. We’ll then be able to view a doughnut graph within Android Studio for the preview of our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Preview</span>(<span class="syntax-all syntax-constant">showBackground</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>)
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Preview_DoughnutChart</span>() {
    <span class="syntax-all syntax-entity">MaterialTheme</span> {
		<span class="syntax-all syntax-entity">ArcChart</span>(
        	chartData <span class="syntax-all syntax-keyword">=</span> chartData,
        	useCenter <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
        	style <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Stroke</span>(width <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">150f</span>)
    	)
	}
}</code></pre>

<figure><img src="img.png"/></figure>

<hr />

<h3>Displaying data labels</h3>

<p>Now that we have the visuals of the graph drawn on the canvas, we’re next going to want to display the data values as labels on the graph - this allows us to communicate the actual values of the data set, as opposed to relying on the visual representation. So that we can draw this text on the canvas, we’re going to start by defining the <code>Paint</code> reference that will be used for this drawing. Sot that this is persisted across compositions we’ll go ahead and wrap this in a <code>remember</code> block.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> remember { <span class="syntax-all syntax-entity">Paint</span>() }</code></pre>

<p>We’re going to want to apply some specific styling to how the text is drawn on the canvas, so we’ll configure both the <code>textAlign</code> and <code>typeface</code> properties. We’ll want to align the text in the <code>center</code> wherever it is drawn, along with applying a <code>BOLD</code> weighting to the applied typeface.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> remember {
	<span class="syntax-all syntax-entity">Paint</span>().<span class="syntax-all syntax-constant">apply</span> {
		textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Paint</span>.<span class="syntax-all syntax-entity">Align</span>.<span class="syntax-all syntax-entity">CENTER</span>
        typeface <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Typeface</span>.create(<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">DEFAULT</span>, 				<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">BOLD</span>)
    }
}</code></pre>

<p>We’re also going to want to apply a specific sizing to the label, so we’ll start by adding this font size to our <code>dimens.xml</code> file.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">dimen</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;label_size&quot;</span>&gt;12sp&lt;/<span class="syntax-all syntax-tag">dimen</span>&gt;</code></pre>

<p>We can then retrieve this from our resources and assign the value directly to the <code>textSize</code> property.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> labelTextSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current.resources
	.getDimensionPixelSize(<span class="syntax-all syntax-entity">R</span>.dimen.label_size)

<span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> remember {
	<span class="syntax-all syntax-entity">Paint</span>().<span class="syntax-all syntax-constant">apply</span> {
		textSize <span class="syntax-all syntax-keyword">=</span> labelTextSize.toFloat()
		textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Paint</span>.<span class="syntax-all syntax-entity">Align</span>.<span class="syntax-all syntax-entity">CENTER</span>
        typeface <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Typeface</span>.create(<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">DEFAULT</span>, 				<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">BOLD</span>)
    }
}</code></pre>

<p>We don’t need to configure this information for every different label that is being drawn in the canvas, so we can place this code at the very top of our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;,
    <span class="syntax-all syntax-parameter">useCenter</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">style</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span>,
    <span class="syntax-all syntax-parameter">outerMargin</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
) {
    <span class="syntax-all syntax-keyword">val</span> labelTextSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current.resources
		.getDimensionPixelSize(<span class="syntax-all syntax-entity">R</span>.dimen.label_size)

    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> remember {
        <span class="syntax-all syntax-entity">Paint</span>().<span class="syntax-all syntax-constant">apply</span> {
            textSize <span class="syntax-all syntax-keyword">=</span> labelTextSize.toFloat()
            textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Paint</span>.<span class="syntax-all syntax-entity">Align</span>.<span class="syntax-all syntax-entity">CENTER</span>
            typeface <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Typeface</span>.create(<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">DEFAULT</span>, 				<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">BOLD</span>)
        }
    }

    ...
}</code></pre>

<p>Now that we have the <code>Paint</code> reference configured for the drawing of the label, we’re going to move on to drawing the data labels onto the canvas - allowing us to show information next to the visual representation of the data set. When it comes to drawing these labels, we’re going to be displaying them outside of the radius of the graph, central to each corresponding segment.</p>

<figure><img src="labelss.png"/></figure>

<p>To start, we’re going to need to first calculate how we are going to be drawing the text outside of the graph. For this, we need to know the radius, as well as define a border (in the form of padding) that will ensure our text is not pressed up against the graph (as to keep it readable for the user). </p>

<p>When it comes to defining the border, we’re going to use a <code>dp</code> value to represent this padding, but we’ll need it in a pixel format as we are drawing on the canvas. For this, we’ll utilise the <code>LocalDensity</code> provider which will provide us with a pixel value in relation to the corresponding density on the device.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> radius <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>
<span class="syntax-all syntax-keyword">val</span> radiusBorder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { <span class="syntax-all syntax-constant">24</span>.dp.toPx() }
<span class="syntax-all syntax-keyword">val</span> radiusWithBorder <span class="syntax-all syntax-keyword">=</span> radius <span class="syntax-all syntax-keyword">+</span> radiusBorder</code></pre>

<p>So that we can calculate where the label is to be drawn, we’re going to need to write some mathematical logic to calculate the required positions. We won’t go too much into the how/why of this logic as we’ll stray from the focus of Jetpack Compose specifics. </p>

<p>To start, we need to find the median angle of the segment - this is the halfway point for the current segment that we are drawing the label for. To calculate this we can take the current total segment value that was previously being calculated, followed by subtracting the 1/2 of the current segment that is being drawn (this is because we want to draw in the middle of this current segment). We then multiple this by <code>PI</code> and divide it by <code>180</code> (half of the radius of a circle). This calculation gives us the median angle that we need to draw at.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> medianAngle <span class="syntax-all syntax-keyword">=</span> (currentSegment <span class="syntax-all syntax-keyword">-</span> (segmentAngle <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-entity">Math</span>.<span class="syntax-all syntax-entity">PI</span> <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">180f</span></code></pre>

<p>Now that we have this median angle, we need to calculate the x and y coordinates that we are drawing the label at. When it comes to working out these coordinates for the edge of a circle, we can utilise the concept of <strong>Sine</strong> and <strong>Cosine</strong>. Using the built-in Kotlin functions for this math theory, we can use the <code>cos</code> function to calculate the x-coordinate, along with the <code>sin</code> function for the y-coordinate. We’ll use our already calculated radius values in the calculation for this logic, giving us the required coordinates for drawing the labels in their respective place on the canvas. The radius values will ensure that we are drawing on the outside of the graph, while the <code>cos</code> and <code>sin</code> calculated angles will ensure we are drawing at the correct angle for the corresponding segment.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span>
	(radiusWithBorder <span class="syntax-all syntax-keyword">*</span> cos(medianAngle)).toFloat() <span class="syntax-all syntax-keyword">+</span> radius
<span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span>
	(radiusWithBorder <span class="syntax-all syntax-keyword">*</span> sin(medianAngle)).toFloat() <span class="syntax-all syntax-keyword">+</span> radius</code></pre>

<p>So that we can draw, we’re going to need to drop into the <code>NativeCanvas</code> - text cannot be drawn directly into the <code>Canvas</code> within compose, so retrieving the <code>NativeCanvas</code> reference gives us access to the <code>drawText</code> function. For this we need to provide:</p>

<ul>
	<li><strong>text</strong> - the label that is being drawn onto the canvas</li>
	<li><strong>x</strong> - the x-coordinate of the label, this is always going to equal 0 as we are always drawing at the start of the canvas</li>
	<li><strong>y</strong> - the y-coordinate of the label, this is going to be the <code>drawAtY</code> that we just calculated</li>
	<li><strong>paint</strong> - the <code>Paint</code> reference used to draw the label, which is the <code>textPaint</code> being provided to the function</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;,
    <span class="syntax-all syntax-parameter">useCenter</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">style</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span>
) {
   
    <span class="syntax-all syntax-keyword">val</span> radiusBorder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">24</span>.dp.toPx() 
	}

    ...

    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
    ) {
        <span class="syntax-all syntax-entity">Canvas</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
        ) {
            <span class="syntax-all syntax-keyword">var</span> currentSegment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
            <span class="syntax-all syntax-keyword">val</span> radius <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>
            <span class="syntax-all syntax-keyword">val</span> totalAngle <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">360</span>

            chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>
                ...

                drawIntoCanvas {
                    <span class="syntax-all syntax-keyword">val</span> medianAngle <span class="syntax-all syntax-keyword">=</span> (currentSegment <span class="syntax-all syntax-keyword">-</span> 
						(segmentAngle <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-entity">Math</span>.<span class="syntax-all syntax-entity">PI</span> <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">180f</span>
                    <span class="syntax-all syntax-keyword">val</span> radiusWithBorder <span class="syntax-all syntax-keyword">=</span> 
						radius <span class="syntax-all syntax-keyword">+</span> radiusBorder
                    <span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> (radiusWithBorder <span class="syntax-all syntax-keyword">*</span> 							cos(medianAngle)).toFloat() <span class="syntax-all syntax-keyword">+</span> radius
                    <span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> (radiusWithBorder <span class="syntax-all syntax-keyword">*</span> 							sin(medianAngle)).toFloat() <span class="syntax-all syntax-keyword">+</span> radius
                    it.nativeCanvas.drawText(
                        chartData.value.toString(),
                        drawAtX,
                        drawAtY,
                        labelTextPaint
                    )
                }
            }
        }
    }
}</code></pre>

<p>We’re going to make one small tweak here so that a composable utilising the <code>ArcChart</code> can provide its margin to be applied outside of the graph - we’re going to be creating a <strong>Pie</strong> and <strong>Doughnut</strong> chart using this composable, so the spacings for each will need to be different. To account for this we’ll add a new argument to the composable function in the form of a <code>Float</code> called <code>outerMargin</code>. We’ll then slot this value into the <code>drawAtX</code> and <code>drawAtY</code> values that we calculated for the drawing of our labels.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> ((radiusWithBorder <span class="syntax-all syntax-keyword">+</span> outerMargin) <span class="syntax-all syntax-keyword">*</span> 		
	cos(medianAngle)).toFloat() <span class="syntax-all syntax-keyword">+</span> radius
<span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> ((radiusWithBorder <span class="syntax-all syntax-keyword">+</span> outerMargin) <span class="syntax-all syntax-keyword">*</span> 
	sin(medianAngle)).toFloat() <span class="syntax-all syntax-keyword">+</span> radius</code></pre>

<p>We can now update this code within the <code>ArcChart</code> composable, giving us a complete composable function for drawing <code>Arc</code> graphs.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;,
    <span class="syntax-all syntax-parameter">useCenter</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">style</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span>,
    <span class="syntax-all syntax-parameter">outerMargin</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
) {
    <span class="syntax-all syntax-keyword">val</span> labelTextSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current.resources
		.getDimensionPixelSize(<span class="syntax-all syntax-entity">R</span>.dimen.label_size)

    <span class="syntax-all syntax-keyword">val</span> radiusBorder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">24</span>.dp.toPx() 
	}

    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> remember {
        <span class="syntax-all syntax-entity">Paint</span>().<span class="syntax-all syntax-constant">apply</span> {
            textSize <span class="syntax-all syntax-keyword">=</span> labelTextSize.toFloat()
            textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Paint</span>.<span class="syntax-all syntax-entity">Align</span>.<span class="syntax-all syntax-entity">CENTER</span>
            typeface <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Typeface</span>.create(<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">DEFAULT</span>, 				<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">BOLD</span>)
        }
    }

    <span class="syntax-all syntax-keyword">val</span> sumOfDataSet <span class="syntax-all syntax-keyword">=</span> remember(chartData) { 
		chartData.sumOf { it.value } 
	}

    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
    ) {
        <span class="syntax-all syntax-entity">Canvas</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
        ) {
            <span class="syntax-all syntax-keyword">var</span> currentSegment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
            <span class="syntax-all syntax-keyword">val</span> radius <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>
            <span class="syntax-all syntax-keyword">val</span> totalAngle <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">360</span>

            chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-keyword">val</span> segmentAngle <span class="syntax-all syntax-keyword">=</span> totalAngle <span class="syntax-all syntax-keyword">*</span> 							chartData.value <span class="syntax-all syntax-keyword">/</span> sumOfDataSet
                drawArc(
                    color <span class="syntax-all syntax-keyword">=</span> chartData.color,
                    startAngle <span class="syntax-all syntax-keyword">=</span> currentSegment,
                    sweepAngle <span class="syntax-all syntax-keyword">=</span> segmentAngle.toFloat(),
                    useCenter <span class="syntax-all syntax-keyword">=</span> useCenter,
                    style <span class="syntax-all syntax-keyword">=</span> style
                )
                currentSegment <span class="syntax-all syntax-keyword">+=</span> segmentAngle

                drawIntoCanvas {
                    <span class="syntax-all syntax-keyword">val</span> medianAngle <span class="syntax-all syntax-keyword">=</span> (currentSegment <span class="syntax-all syntax-keyword">-</span> 
						(segmentAngle <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-entity">Math</span>.<span class="syntax-all syntax-entity">PI</span> <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">180f</span>
                    <span class="syntax-all syntax-keyword">val</span> radiusWithBorder <span class="syntax-all syntax-keyword">=</span> radius <span class="syntax-all syntax-keyword">+</span> 							radiusBorder
                    <span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span>
                        ((radiusWithBorder <span class="syntax-all syntax-keyword">+</span> outerMargin) <span class="syntax-all syntax-keyword">*</span> 					cos(medianAngle)).toFloat() <span class="syntax-all syntax-keyword">+</span> radius
                    <span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span>
                        ((radiusWithBorder <span class="syntax-all syntax-keyword">+</span> outerMargin) <span class="syntax-all syntax-keyword">*</span> 					sin(medianAngle)).toFloat() <span class="syntax-all syntax-keyword">+</span> radius
                    it.nativeCanvas.drawText(
                        chartData.value.toString(),
                        drawAtX,
                        drawAtY,
                        labelTextPaint
                    )
                }
            }
        }
    }
}</code></pre>

<figure><img src="labels.png"/></figure>

<hr />

<h2>Animating the Arc</h2>

<p>Now that the arc graph is being drawn, we can look at going one step further here and animating the values when they are being drawn. For this, we’re going to be utilising the <code>Animatable</code> class. This class allow us to animate between values, which is perfect for when we are drawing at a set of given coordinates on the canvas. This function is going to take a list of <code>GraphData</code> references for drawing the data, along with returning an <code>Animatable</code> reference that contains the <code>Float</code> value that is being animated. The <code>Animatable</code> type defines two contained types, of which we’ll define <code>AnimationVector1D</code> for the second - this class is used to define a single float value during the animation, which in our case is all we need when working with animated values. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">//animationUtil.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">configureAnimation</span>(
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Animatable</span>&lt;<span class="syntax-all syntax-constant">Float</span>, <span class="syntax-all syntax-entity">AnimationVector1D</span>&gt; {
    
}</code></pre>

<p>Next, we’ll need to define the animation itself. Here we’ll instantiate the <code>Animatable</code> class, providing an initial value of <code>0f</code> for the starting point of the animation. We’ll also wrap this in the <code>remember</code> function, using the provided <code>chartData</code> reference as the key.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">//animationUtil.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">configureAnimation</span>(
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Animatable</span>&lt;<span class="syntax-all syntax-constant">Float</span>, <span class="syntax-all syntax-entity">AnimationVector1D</span>&gt; {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> remember(chartData) {
        <span class="syntax-all syntax-entity">Animatable</span>(
            initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
        )
    }
    <span class="syntax-all syntax-keyword">return</span> transitionAnimation
}</code></pre>

<p>💡 Passing a key value here allows us to define that the contained block should be remembered across compositions, only needing to change if the value of the provided key is changed.</p>

<p>Now that the animation is defined we’re going to want to start the animation. When it comes to the animated value, we’re simply going to want to animate from the initial value of <code>0f</code> up until a value of <code>1f</code>. We’ll start this animation using the <code>animateTo</code> function, for which we’ll also override the default <code>AnimationSpec</code>. Here we’ll use the <code>TweenSpec</code> class with an animation duration of 750 milliseconds - this allows us to achieve a smoother animation effect compared to the default <code>SpringSpec</code>. We’ll also wrap this animation in a <code>LaunchedEffect</code> block, meaning that the animation is only launched within the initial composition, only ever relaunching if the provided key has changed (which we are again using the provided <code>chartData</code> reference for.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">//animationUtil.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">configureAnimation</span>(
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Animatable</span>&lt;<span class="syntax-all syntax-constant">Float</span>, <span class="syntax-all syntax-entity">AnimationVector1D</span>&gt; {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> remember(chartData) {
        <span class="syntax-all syntax-entity">Animatable</span>(
            initialValue <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
        )
    }
    <span class="syntax-all syntax-entity">LaunchedEffect</span>(chartData) {
        transitionAnimation.animateTo(
            <span class="syntax-all syntax-constant">1f</span>,
            animationSpec <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TweenSpec</span>(durationMillis <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">750</span>)
        )
    }
    <span class="syntax-all syntax-keyword">return</span> transitionAnimation
}</code></pre>

<p>With this animation defined, we can now plug this into our <code>ArcChart</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;,
    <span class="syntax-all syntax-parameter">useCenter</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">style</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span>,
    <span class="syntax-all syntax-parameter">outerMargin</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
}</code></pre>

<p>We’re going to utilise this in a few places, but we’ll start by animating the text that is being drawn onto the canvas. For the <code>Paint</code> reference being created for the graph labels, we’re going to apply an <code>alpha</code> value using the calculated animation value. The <code>alpha</code> value of the text can be any value between <strong>0</strong> and <strong>255</strong>, so we’re going to need to calculate this value based on the current transition value. We’ll want this to be calculated as a percentage representation - so we’ll start by dividing the maximum value of <strong>255</strong> by <strong>100</strong>. Next, because our transition value is going to be between 0 and 1, we’ll want to multiply this by 100 to get a 0-100 percent representation. We can then take this value and use it to multiple the initial division that we performed. The result of this gives us the alpha that is to be applied to the painted text.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;,
    <span class="syntax-all syntax-parameter">useCenter</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">style</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span>,
    <span class="syntax-all syntax-parameter">outerMargin</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
    <span class="syntax-all syntax-keyword">val</span> labelTextSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current.resources
		.getDimensionPixelSize(<span class="syntax-all syntax-entity">R</span>.dimen.label_size)
    <span class="syntax-all syntax-keyword">val</span> radiusBorder <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">24</span>.dp.toPx() 
	}
    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> remember {
        <span class="syntax-all syntax-entity">Paint</span>().<span class="syntax-all syntax-constant">apply</span> {
            textSize <span class="syntax-all syntax-keyword">=</span> labelTextSize.toFloat()
            textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Paint</span>.<span class="syntax-all syntax-entity">Align</span>.<span class="syntax-all syntax-entity">CENTER</span>
            typeface <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Typeface</span>.create(<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">DEFAULT</span>, 				<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">BOLD</span>)
        }
    }.<span class="syntax-all syntax-constant">apply</span> {
        alpha <span class="syntax-all syntax-keyword">=</span> ((<span class="syntax-all syntax-constant">255</span> <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">100</span>) <span class="syntax-all syntax-keyword">*</span> 
			(transitionAnimation.value <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">100</span>)).toInt()
    }
	...
}</code></pre>

<p>Next, we’ll want to modify the drawing logic so that this animated value is also being applied when the segments of the graph are being drawn. To calculate this value, we can reuse the existing logic that we had defined for the <code>segmentAngle</code> value - the only difference here is going to be that the <code>value</code> is drawn from the corresponding <code>GraphData</code> reference needs to be modified to take the transition value into account. Because our transition value is going to represent an animated value between 0 and 1, we can multiple the <code>GraphData</code> value by this, which will, in turn, animate the overall size of the angle that is being drawn.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> angleToDraw <span class="syntax-all syntax-keyword">=</span> totalAngle <span class="syntax-all syntax-keyword">*</span> (chartData.value <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value) <span class="syntax-all syntax-keyword">/</span> sumOfDataSet</code></pre>

<p>Now that we have this animated segment size in place, we’re going to need to make a few more adjustments to the values passed to the <code>drawArc</code> function. Now, we need to keep the previous <code>segmentAngle</code> variable in place because we’re going to need this later when it comes to drawing labels on the graph, so we’ll continue to add the calculated variables to <code>currentSegment</code>. So that we have an animated tracker variable for the segments, we’ll create a new variable <code>currentStartAngle</code> which will be used to keep a track of the total segment sizes that have been drawn, but in an animated fashion. This means that the drawing of the whole graph will be animated and the segments will be drawn one by one, filling up the arc graph as the animation is seen through. After the drawing of every arc, we’ll add the calculated value of <code>angleToDraw</code> to this <code>currentStartAngle</code> tracker variable. With this in place, we’ll need to update the value that is being passed for the <code>startAngle</code> argument - this is now going to be passed as the <code>currentStartAngle</code> variable. This means that the <code>startAngle</code> for each segment will now be animated.</p>

<p>With this new <code>angleToDraw</code> variable, we can now pass this for the <code>sweepAngle</code> argument of the <code>drawArc</code> function. This will define the size of the arc, using the animated value that we previously defined. This means that when the transition is running, the <code>sweepAngle</code> property will animate to its final state.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    ...
) {
    ...

    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
    ) {
        <span class="syntax-all syntax-entity">Canvas</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.size(<span class="syntax-all syntax-constant">240</span>.dp)
        ) {
            <span class="syntax-all syntax-keyword">var</span> currentSegment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
            <span class="syntax-all syntax-keyword">var</span> currentStartAngle <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
            <span class="syntax-all syntax-keyword">val</span> radius <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>
            <span class="syntax-all syntax-keyword">val</span> totalAngle <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">360</span>

            chartData.forEach { chartData <span class="syntax-all syntax-keyword">-&gt;</span>
                <span class="syntax-all syntax-keyword">val</span> segmentAngle <span class="syntax-all syntax-keyword">=</span> totalAngle <span class="syntax-all syntax-keyword">*</span> 							chartData.value <span class="syntax-all syntax-keyword">/</span> sumOfDataSet

                <span class="syntax-all syntax-keyword">val</span> angleToDraw <span class="syntax-all syntax-keyword">=</span> totalAngle <span class="syntax-all syntax-keyword">*</span> 
					(chartData.value <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value) <span class="syntax-all syntax-keyword">/</span> sumOfDataSet

                drawArc(
                    color <span class="syntax-all syntax-keyword">=</span> chartData.color,
                    startAngle <span class="syntax-all syntax-keyword">=</span> currentStartAngle,
                    sweepAngle <span class="syntax-all syntax-keyword">=</span> angleToDraw,
                    useCenter <span class="syntax-all syntax-keyword">=</span> useCenter,
                    style <span class="syntax-all syntax-keyword">=</span> style
                )
                currentSegment <span class="syntax-all syntax-keyword">+=</span> segmentAngle
                currentStartAngle <span class="syntax-all syntax-keyword">+=</span> angleToDraw
            }
        }
    }
}</code></pre>

<p>With these variables in place, the values of the arc and arc segments are now being completely animated. While you won’t be able to see this in the composable preview, running this on a device will show the arc graph filling up its entire radius in an animated fashion, drawing each segment as the arc is filled.</p>

<hr />

<h2>Creating a Graph Legend</h2>

<p>Now that we have the data being displayed within the circular graph, we’re next going to create a legend that will be used to display the labels for the corresponding data in the graph. </p>

<figure><img src="labels-1.png"/></figure>

<p>We’re going to start here by creating a new composable function, <code>LegendItem</code>, which will be used to represent each of the items within the legend. This composable will take a reference to a <code>GraphData</code> which will be used to compose the corresponding label.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LegendItem.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LegendItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">data</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphData</span>
) {

}</code></pre>

<p>As seen in the design above, we’re going to be showing a box representing the color of the item in the graph along with the <code>Text</code> composable to display the label for the <code>GraphData</code> reference. To contain these components we’re going to define a <code>Row</code> so that we can compose these items alongside one another, we’ll also want to center these on the vertical axis using <code>CenterVertically</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LegendItem.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LegendItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">data</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphData</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">12</span>.dp),
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        
    }
}</code></pre>

<p>We’ll start by adding the small square that represents the color of the data entry for our graph - this is so that the representation in the graph can be matched against the information being displayed in the legend. For this, we can use a <code>Box</code> composable, fixing the size as <code>12dp</code> and setting the background of the composable to the color in the provided <code>GraphData</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LegendItem.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LegendItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">data</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphData</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">12</span>.dp),
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .size(<span class="syntax-all syntax-constant">12</span>.dp)
                .background(<span class="syntax-all syntax-keyword">data</span>.color)
        )
    }
}</code></pre>

<figure><img src="box.png"/></figure>

<p>Next, we’ll compose a <code>Text</code> that will be used to represent the information for the <code>GraphData</code> entry. For this we’ll simply use the <code>label</code> property from the reference, using a <code>Spacer</code> to create a visual separation between the <code>Box</code> and <code>Text</code> composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LegendItem.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LegendItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">data</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphData</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.padding(<span class="syntax-all syntax-constant">12</span>.dp),
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .size(<span class="syntax-all syntax-constant">12</span>.dp)
                .background(<span class="syntax-all syntax-keyword">data</span>.color)
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">8</span>.dp))
        <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">data</span>.label)
    }
}</code></pre>

<figure><img src="boxx.png"/></figure>

<p>As the last step here, we’ll go ahead and utilise the <code>semantics</code> modifier and merge the descendants of the container using the <code>mergeDescendants</code> flag. This means that when the composable is focused by screen readers, a single element will be communicated as opposed to the individual children, making it smoother to navigate around our UI when using accessibility services.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LegendItem.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LegendItem</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">data</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphData</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier.padding(<span class="syntax-all syntax-constant">12</span>.dp)
			.semantics(mergeDescendants <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>) { },
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        <span class="syntax-all syntax-entity">Box</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .size(<span class="syntax-all syntax-constant">12</span>.dp)
                .background(<span class="syntax-all syntax-keyword">data</span>.color)
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.width(<span class="syntax-all syntax-constant">8</span>.dp))
        <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-keyword">data</span>.label)
    }
}</code></pre>

<p>Now that we have the <code>LegendItem</code> composable in place, we can think about composing a collection of these for the corresponding <code>GraphData</code> list. </p>

<figure><img src="labels-2.png"/></figure>

<p>For this we’re going to compose a new component in the form of a <code>Legend</code> composable, this will take a collection of <code>GraphData</code> as an argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Legend.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Legend</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)</code></pre>

<p>We’re next going to want to create a grid layout for the <code>GraphData</code> items. While we have solutions like the <code>LazyGrid</code> available (that is currently in an experimental state), we’re working with a very simple dataset and layout so we’re going to recreate this using a simple <code>Column</code> and <code>Row</code> solution.</p>

<p>Starting by composing a <code>Column</code>, we can use the Kotlin <code>chunked</code> function to split our <code>chartData</code> into a collection of sized groups. For each of these groups, we’re going to compose a <code>Row</code> with 2 <code>LegendItem</code> composables, one for each of the items in our chunked set.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Legend.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Legend</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        chartData.chunked(<span class="syntax-all syntax-constant">2</span>).forEach { row <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-entity">Row</span> {
                <span class="syntax-all syntax-entity">LegendItem</span>(row[<span class="syntax-all syntax-constant">0</span>])
                <span class="syntax-all syntax-entity">LegendItem</span>(row[<span class="syntax-all syntax-constant">1</span>])
            }
        }
    }
}</code></pre>

<p>With this in place, we now have a <code>Legend</code> composable that can be used to show the data for a provided <code>GraphData</code> collection.</p>

<figure><img src="labels-3.png"/></figure>

<hr />

<h2>Applying the Legend to the Arc Graph</h2>

<p>Now that we have our <code>Legend</code> composable, we’re going to hop on back over to the <code>ArcChart</code> composable and modify it to display the legend for a given dataset. Here we’ll simply compose the <code>Legend</code> as the last child of the <code>Column</code> container, passing in the collection of <code>GraphData</code> references that are provided to the <code>ArcChart</code> composable. We’ll also use the <code>Spacer</code> composable to create some visual space between the legend and the chart.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ArcChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ArcChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;,
    <span class="syntax-all syntax-parameter">useCenter</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">style</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span>,
    <span class="syntax-all syntax-parameter">outerMargin</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>
) {
    ...

    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
        verticalArrangement <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Arrangement</span>.<span class="syntax-all syntax-entity">SpaceEvenly</span>
    ) {
        ...
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">36</span>.dp))
        <span class="syntax-all syntax-entity">Legend</span>(chartData <span class="syntax-all syntax-keyword">=</span> chartData)
    }
}</code></pre>

<figure><img src="legend.png"/></figure>

<hr />

<h2>Composing the Doughnut Chart</h2>

<p>Now that our arc composable is complete, we can go ahead and configure this specifically for the different circular graph types that we want to create. For the preview of the composable we previously composed a doughnut graph, so we’re going to transfer this preview code into a composable that can be plugged directly into our UI. For this, we’re going to need to create a new composable function that can take the provided <code>GraphData</code> and compose the graph from it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// DoughnutChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DoughnutChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)</code></pre>

<p>We’ll then take the <code>ArcChart</code> composition that we previously used to preview the graph, composing it inside of this new <code>DoughnutChart</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// DoughnutChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">DoughnutChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-entity">ArcChart</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        chartData <span class="syntax-all syntax-keyword">=</span> chartData,
        useCenter <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
        style <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Stroke</span>(<span class="syntax-all syntax-constant">150f</span>, cap <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">StrokeCap</span>.<span class="syntax-all syntax-entity">Butt</span>),
        outerMargin <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">70f</span>
    )
}</code></pre>

<p>With this, we now have a <code>DoughnutChart</code> composable that can be used to compose a doughnut chart for a given data set.</p>

<figure><img src="legend-1.png"/></figure>

<hr />

<h2>Composing the Pie Chart</h2>

<p>While we now have the doughnut chart in place, we’re going to reuse the existing <code>ArcChart</code> composable to create a similar kind of chart - a pie chart. We’ll create a new composable function, <code>PieChart</code>, that will again take the provided <code>GraphData</code> and compose the graph from it. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PieChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PieChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)</code></pre>

<p>Within this composable, we’re then going to want to compose an <code>ArcChart</code>. Similar to the doughnut chart, we’re going to directly pass in the provided <code>modifier</code> and <code>chartData</code> arguments. When it comes to the pie chart, there are going to be a couple of key differences:</p>

<ul>
	<li><strong>useCenter</strong> - for this we’re going to pass a value of <code>true</code>, instead of <code>false</code>. This is because the segments of a pie chart fill the available space, so we’re going to want the bounds to close at the center of the canvas.</li>
	<li><strong>style</strong> - unlike the doughnut chart, the segments of the pie chart fill the available space. While the <code>useCenter</code> flag implies that we draw to the center of the canvas, we want the styling we use to fill all of that available space. For this reason we pass the <code>Fill</code> draw style to declare that the segment should be drawn filled with the specified color.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// PieChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">PieChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-entity">ArcChart</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        chartData <span class="syntax-all syntax-keyword">=</span> chartData,
        useCenter <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
        style <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Fill</span>
    )
}</code></pre>

<p>With this, we now have a <code>PieChart</code> composable that can be used to compose a doughnut chart for a given data set.</p>

<figure><img src="pie.png"/></figure>

<hr />

<h2>Line Graph</h2>

<p>Now that we’ve covered the pie and doughnut charts, we’re going to move on to a different kind of visual representation for our data - the line graph. This composable will take our data set, composing a line graph based on the data that is provided to it.</p>

<figure><img src="line.png"/></figure>

<p>We’ll start here by creating a new composable function, <code>LineChart</code>. Similar to our previously created composable functions, this is going to take a collection of <code>GraphData</code> references that will be used to compose the graph data.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LineChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)</code></pre>

<p>For the previous chart types, we composed a <code>Canvas</code> using predefined sizing - this was due to the canvas being unaware of the size of its contents (and therefore not knowing how much space to occupy). We’ll do a similar thing for our line graph, filling the maximum available width and hardcoding the occupied height.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LineChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
       
    }
}</code></pre>

<hr />

<h3>Drawing axis lines</h3>

<p>Now that we have the <code>Canvas</code> in place, we’re going to start by drawing the X and Y axis of our graph. The line graph is just one type of graph we will be drawing that uses the X and Y axis, so we’re going to place this logic inside of a reusable function that can be utilised by the other graphs that we are going to be creating. Because we are only going to be utilising this function inside of the canvas, we can scope this using <code>DrawScope</code>. This function is going to take a <code>startPadding</code> argument, that will be used to ensure the axis is drawn after the text label.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawAxis</span>(<span class="syntax-all syntax-parameter">startPadding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>) {

}</code></pre>

<p>With this scope in place, it means that we can utilise the functions that are available to the <code>Canvas</code> via this scoping. When it comes to drawing the axis, this means that we can utilise the <code>DrawScope</code> scoped <code>drawLine</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawAxis</span>(<span class="syntax-all syntax-parameter">startPadding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>) {
    drawLine(
        ...
    )
    drawLine(
        ...
    )
}</code></pre>

<p>This function takes a collection of arguments to draw a line, several of which are required.</p>

<ul>
	<li><strong>color</strong> - this required argument specifies the color to be used when drawing the line</li>
	<li><strong>start</strong> - this required argument specifies the <code>Offset</code> at which the drawing should begin</li>
	<li><strong>end</strong> - this required argument specifies the <code>Offset</code> at which the drawing should end</li>
</ul>

<p>When it comes to the color of the line, we’re simply going to be using the color black. For this argument, we’ll pass in the <code>Color.Black</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawAxis</span>(<span class="syntax-all syntax-parameter">startPadding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>) {
    drawLine(
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
		...
    )
    drawLine(
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
		...
    )
}</code></pre>

<p>Next up we’re going to define the start position for drawing the axis. This argument requires an <code>Offset</code> which defines the X and Y coordinates to be used for the drawing. For both axis, the start position is going to be identical - this is because both drawing points are going to start at the bottom left corner of the graph. For each <code>Offset</code> we’re going to provide the following values:</p>

<ul>
	<li><strong>x</strong> - for the x coordinate we’re going to want to start at the beginning of the canvas x-axis. The start of the canvas has a coordinate value of 0, but we don’t want to draw right against the edge of the canvas so that we allow for the text label to be drawn before the axis. For this, we can pass the <code>startPadding</code> value for the x-coordinate of the <code>Offset.</code></li>
	<li><strong>y</strong> - for the y coordinate we’re going to need to provide a value that starts the drawing again at the bottom left corner of the canvas, minus the previously defined padding value. For the y-axis of the canvas, the top is equal to 0 - so we’re going to take the height of the canvas and subtract the defined padding value.</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">val</span> padding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp.value

<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawAxis</span>(<span class="syntax-all syntax-parameter">startPadding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>) {
    drawLine(
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
        start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> startPadding <span class="syntax-all syntax-keyword">+</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding
        ),
		...
    )
    drawLine(
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
        start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> startPadding <span class="syntax-all syntax-keyword">+</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding
        ),
        ...
    )
}</code></pre>

<p>With the start positions in place, we can now go ahead and define the <code>end</code> <code>Offset</code> for each of the lines. For the first <code>drawLine</code> operation we are drawing the x-axis, so the end is going to need to represent a value at the end of the horizontal axis of the canvas. Because this line is horizontal along the axis, the y value is going to remain the same as what we defined for the <code>start</code> <code>Offset</code>. However, the x coordinate used for the <code>end</code> <code>Offset</code> is going to need to represent a value at the end of the horizontal axis of the canvas. This value is going to equal the width of the canvas, minus the padding that we defined for our graph.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">val</span> padding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp.value

<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawAxis</span>(<span class="syntax-all syntax-parameter">startPadding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>) {
    drawLine(
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
        start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> startPadding <span class="syntax-all syntax-keyword">+</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding
        ),
        end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">-</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding
        )
    )
    ...
}</code></pre>

<p>For the second <code>drawLine</code> operation we’re going to be drawing the line for the y-axis. For the <code>end</code> <code>Offset</code> we’re simply going to want to be drawing a vertical line up until the top left-hand corner of the canvas. For this <code>Offset</code> the x coordinate is going to be the same as the starting offset coordinate, which is the <code>padding</code> value that we previously defined. For the y-coordinate we’re going to want to draw up until the padding of the canvas top, so we will also need to use the <code>padding</code> value for the y-coordinate.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">val</span> padding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp.value

<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawAxis</span>(<span class="syntax-all syntax-parameter">startPadding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>) {
    ...
    drawLine(
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
        start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> startPadding <span class="syntax-all syntax-keyword">+</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding
        ),
        end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> padding
        )
    )
}</code></pre>

<p>At this point we have a function that will allow us to draw the axis lines onto our canvas, we’re just going to make one small change before moving forward. The <code>drawLine</code> function also allows us to provide the width to be used for the stroke of the line, so we’re going to define a custom value here to use for this. We’ll create a new variable <code>strokeThickness</code>, followed by passing this to each of the <code>drawLine</code> calls for its <code>strokeWidth</code> argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">val</span> padding <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp.value
<span class="syntax-all syntax-keyword">val</span> strokeThickness <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">2</span>.dp.value

<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawAxis</span>(<span class="syntax-all syntax-parameter">startPadding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0f</span>) {
    drawLine(
        strokeWidth <span class="syntax-all syntax-keyword">=</span> strokeThickness,
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
        start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> startPadding <span class="syntax-all syntax-keyword">+</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding
        ),
        end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">-</span> startPadding,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding
        )
    )
    drawLine(
        strokeWidth <span class="syntax-all syntax-keyword">=</span> strokeThickness,
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
        start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> startPadding <span class="syntax-all syntax-keyword">+</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding
        ),
        end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> startPadding <span class="syntax-all syntax-keyword">+</span> padding,
            y <span class="syntax-all syntax-keyword">=</span> padding
        )
    )
}</code></pre>

<p>We can now utilise this <code>drawAxis</code> operation inside of the <code>Canvas</code>. When calling this we’ll need to pass a value to be used for the <code>startPadding</code>, so we’ll need to calculate the width of the longest text label. We’ll do this by fetching the longest <code>label</code> from our <code>chartData</code> collection, followed by measuring it. We can then pass the result of this directly to the <code>drawAxis</code> call.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LineChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {

	<span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label
    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        drawAxis(labelWidth)
    }
}</code></pre>

<figure><img src="line_1-1.png"/></figure>

<hr />

<h3>Drawing y-axis labels</h3>

<p>Now that we have the axis being drawn on the canvas, we now have a frame to draw the data labels against. These labels will help to correlate the drawn lines of our graph against the data set that is being used to draw it. </p>

<figure><img src="line_2-1.png"/></figure>

<p>We’re going to start here by drawing the data labels for the y-axis, for which we’ll create a new function <code>drawValueLabelsOnYAxis</code> again scoped using <code>DrawScope</code>. We’re again placing this logic into a reusable function so that it can be reused for other graphs that we’ll be creating.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawValueLabelsOnYAxis</span>() {

}</code></pre>

<p>Here we’re going to want to draw the value for each data entry so that the points in our line graph have a corresponding value on the vertical axis. So that we know how many data labels we need to draw we’re going to need to pass in the count of the labels to be drawn (this will essentially be the count for the number of entries in the data set). With this value, we’re then going to want to draw a label on the canvas for each of these, so we’ll need to perform a loop on the provided value. We’re also going to utilise the <code>drawIntoCanvas</code> function so that we have access to text drawing capabilities for the <code>Canvas</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawValueLabelsOnYAxis</span>(
	<span class="syntax-all syntax-parameter">labelCount</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>
) {
    <span class="syntax-all syntax-keyword">for</span> (value <span class="syntax-all syntax-keyword">in</span> labelCount downTo <span class="syntax-all syntax-constant">0</span>) {
        drawIntoCanvas {
            
        }
    }
}</code></pre>

<p>When it comes to the drawing of graph values on the y-axis, we aren’t going to be drawing the values that are contained within our data set. Instead, as outlined in the screenshot from above, we’re going to be displaying evenly spaced values that the graph points will be plotted against. Using the provided label count, we’re going to calculate these values that are to be drawn for the y-axis.</p>

<p>For this calculation, we’re going to need to add another argument to our function. This value is going to represent the highest value from our graph dataset, as this will be used to know the highest point that is going to be displayed on our graph axis. Using this alongside the provided label count, we can calculate the position of the label to be drawn on the y-axis.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawValueLabelsOnYAxis</span>(
    <span class="syntax-all syntax-parameter">maximumValueToDisplay</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">labelCount</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>
) {
    <span class="syntax-all syntax-keyword">for</span> (value <span class="syntax-all syntax-keyword">in</span> labelCount downTo <span class="syntax-all syntax-constant">0</span>) {
        drawIntoCanvas {
            <span class="syntax-all syntax-keyword">val</span> valueToDraw <span class="syntax-all syntax-keyword">=</span>
                ((maximumValueToDisplay <span class="syntax-all syntax-keyword">/</span> labelCount) <span class="syntax-all syntax-keyword">*</span> 			(labelCount <span class="syntax-all syntax-keyword">-</span> value)).toString()
        }
    }
}</code></pre>

<p>Now that we have the above calculation in place, we can start to think about the drawing of the labels. For this, we’re going to need to configure a <code>Paint</code> instance, similar to how we did for the arc chart. We’re going to be using similar <code>Paint</code> references throughout our graphs, so we’ll create a new function inside of a utility file that will allow us to reuse this logic throughout our code. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtils.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">labelTextPaint</span>(<span class="syntax-all syntax-parameter">resources</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Resources</span>) <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Paint</span>().<span class="syntax-all syntax-constant">apply</span> {
    textSize <span class="syntax-all syntax-keyword">=</span> resources.getDimensionPixelSize(
		<span class="syntax-all syntax-entity">R</span>.dimen.label_size).toFloat()
    typeface <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Typeface</span>.create(<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">DEFAULT</span>, <span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">BOLD</span>)
}</code></pre>

<p>With this in place, we can also go back and update the code for our arc graph to reuse this logic. We can also now move on to the actual drawing of the label on the canvas. To do this we’re going to need to calculate a couple of different values so that we can tell the canvas where the text is to be drawn.</p>

<ul>
	<li><strong>text bounds</strong> - we’re going to need to know the space that the label is going to occupy on the canvas. This is so that we know how to space out the labels on the axis when they are being drawn.</li>
	<li><strong>y-coordinate to drawn at</strong> - once we have the bounds and the available height of the canvas, we’ll be able to calculate exactly where on the canvas the label is to be drawn</li>
</ul>

<p>Before we can move on to the actual placement of the text on the canvas, we’ll need to calculate the bounds that the text will occupy. For this, we need the <code>Resource</code> reference that will be used to obtain the text <code>Paint</code> reference, so we’ll add this as a new argument to our function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawValueLabelsOnYAxis</span>(
    <span class="syntax-all syntax-parameter">maximumValueToDisplay</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
	<span class="syntax-all syntax-parameter">labelCount</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">resources</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Resources</span>
) {
	<span class="syntax-all syntax-keyword">val</span> textPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(resources)
	...
}</code></pre>

<p>Next, we’ll use this to calculate the bounds for the label that is being drawn. For this, we can use the <code>getTextBounds</code> function to calculate the bounds for the entire label content.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawValueLabelsOnYAxis</span>(
    <span class="syntax-all syntax-parameter">maximumValueToDisplay</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
	<span class="syntax-all syntax-parameter">labelCount</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">resources</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Resources</span>
) {
	<span class="syntax-all syntax-keyword">val</span> textPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(resources)
    <span class="syntax-all syntax-keyword">for</span> (value <span class="syntax-all syntax-keyword">in</span> labelCount downTo <span class="syntax-all syntax-constant">0</span>) {
        drawIntoCanvas {
            <span class="syntax-all syntax-keyword">val</span> valueToDraw <span class="syntax-all syntax-keyword">=</span>
                ((maximumValueToDisplay <span class="syntax-all syntax-keyword">/</span> labelCount) <span class="syntax-all syntax-keyword">*</span> 			(labelCount <span class="syntax-all syntax-keyword">-</span> value)).toString()

			<span class="syntax-all syntax-keyword">val</span> bounds <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Rect</span>().<span class="syntax-all syntax-constant">also</span> { rect <span class="syntax-all syntax-keyword">-&gt;</span>
                textPaint.getTextBounds(
					valueToDraw, 
					<span class="syntax-all syntax-constant">0</span>, 				
					valueToDraw.length, 
					rect
				)
            }
        }
    }
}</code></pre>

<p>Now that we have these bounds we can use these to calculate the y coordinate for each label that is being drawn. We want the drawn labels to be evenly spaced on the y-axis, starting at the very top of the y-axis line, until we hit 0 at the bottom. For this calculation, we first need to know the height that is available for this label drawing - this is going to be the height of the y-axis line, which is equivalent to the height of the canvas, subtracting two amounts of the value for the graph padding.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> availableHeight <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)</code></pre>

<p>Using this value we can now calculate the y-coordinate on the canvas where we going to be drawing the text. Because we are drawing this value within a loop, we need to have a calculation that will use the current loop value to evenly space the text labels on the y-axis. We can calculate this value by taking the available height that was calculated, dividing it by the <code>labelCount</code> that is provided to the function (this creates evenly sized segments based on the number of labels being displayed), and then multiplying this result by the current <code>value</code> of the loop. While we are initially calculating evenly sized segments here, we are using the current value of the loop to create the drawing position for the current label.</p>

<figure><img src="gggg.png"/></figure>

<p>So that the label is drawn central to the current bounds, we’ll add half of the label height to the calculated value, as well as the value of our padding so that the padding at the top of the canvas is accounted for.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawValueLabelsOnYAxis</span>(
    <span class="syntax-all syntax-parameter">maximumValueToDisplay</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
	<span class="syntax-all syntax-parameter">labelCount</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">resources</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Resources</span>
) {
	<span class="syntax-all syntax-keyword">val</span> textPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(resources)
    <span class="syntax-all syntax-keyword">for</span> (value <span class="syntax-all syntax-keyword">in</span> labelCount downTo <span class="syntax-all syntax-constant">0</span>) {
        drawIntoCanvas {
            <span class="syntax-all syntax-keyword">val</span> valueToDraw <span class="syntax-all syntax-keyword">=</span>
                ((maximumValueToDisplay <span class="syntax-all syntax-keyword">/</span> labelCount) <span class="syntax-all syntax-keyword">*</span> 			(labelCount <span class="syntax-all syntax-keyword">-</span> value)).toString()

			<span class="syntax-all syntax-keyword">val</span> bounds <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Rect</span>().<span class="syntax-all syntax-constant">also</span> { rect <span class="syntax-all syntax-keyword">-&gt;</span>
                textPaint.getTextBounds(valueToDraw, <span class="syntax-all syntax-constant">0</span>, 				valueToDraw.length, rect)
            }
            <span class="syntax-all syntax-keyword">val</span> availableHeight <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)
            <span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> (
				(availableHeight <span class="syntax-all syntax-keyword">/</span> labelCount) <span class="syntax-all syntax-keyword">*</span> value) <span class="syntax-all syntax-keyword">+</span> padding <span class="syntax-all syntax-keyword">+</span> (bounds.height() <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
        }
    }
}</code></pre>

<p>Now that we have the y-coordinate of our label calculated, we can go ahead and draw the text label onto the canvas. So that we can do this, we’re going to need to drop into the <code>NativeCanvas</code> - text cannot be drawn directly into the <code>Canvas</code> within compose, so retrieving the <code>NativeCanvas</code> reference gives us access to the <code>drawText</code> function. For this we need to provide:</p>

<ul>
	<li><strong>text</strong> - the label that is being drawn onto the canvas</li>
	<li><strong>x</strong> - the x-coordinate of the label, this is always going to equal 0 as we are always drawing at the start of the canvas</li>
	<li><strong>y</strong> - the y-coordinate of the label, this is going to be the <code>drawAtY</code> that we just calculated</li>
	<li><strong>paint</strong> - the <code>Paint</code> reference used to draw the label, which is the <code>textPaint</code> being provided to the function</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawValueLabelsOnYAxis</span>(
    <span class="syntax-all syntax-parameter">maximumValueToDisplay</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
	<span class="syntax-all syntax-parameter">labelCount</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">resources</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Resources</span>
) {
	<span class="syntax-all syntax-keyword">val</span> textPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(resources)
    <span class="syntax-all syntax-keyword">for</span> (value <span class="syntax-all syntax-keyword">in</span> labelCount downTo <span class="syntax-all syntax-constant">0</span>) {
        drawIntoCanvas {
            <span class="syntax-all syntax-keyword">val</span> valueToDraw <span class="syntax-all syntax-keyword">=</span>
                ((maximumValueToDisplay <span class="syntax-all syntax-keyword">/</span> labelCount) <span class="syntax-all syntax-keyword">*</span> 			(labelCount <span class="syntax-all syntax-keyword">-</span> value)).toString()

			<span class="syntax-all syntax-keyword">val</span> bounds <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Rect</span>().<span class="syntax-all syntax-constant">also</span> { rect <span class="syntax-all syntax-keyword">-&gt;</span>
                textPaint.getTextBounds(valueToDraw, <span class="syntax-all syntax-constant">0</span>, 				valueToDraw.length, rect)
            }
            <span class="syntax-all syntax-keyword">val</span> availableHeight <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)
            <span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> ((availableHeight <span class="syntax-all syntax-keyword">/</span>
				heightPointsToShow) <span class="syntax-all syntax-keyword">*</span> value) <span class="syntax-all syntax-keyword">+</span> padding <span class="syntax-all syntax-keyword">+</span> (bounds.height() <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
			it.nativeCanvas.drawText(
                valueToDraw,
                <span class="syntax-all syntax-constant">0f</span>,
                drawAtY,
                textPaint
            )
        }
    }
}</code></pre>

<p>We’re almost ready to draw the labels on our canvas, we’ll just need to define the last few pieces of information so that we can call our new <code>drawValueLabelsOnYAxis</code> function. We’ll first need to calculate the highest value within the provided <code>chartData</code>, which we can do so using the kotlin <code>maxOf</code> function. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }</code></pre>

<p>Next, we need to configure the <code>Paint</code> reference that will be used for the drawing of the text label. We’ll need to define a new <code>Paint</code> reference to be remembered across the composition, followed by assigning a <code>textSize</code> using the previously defined <code>label_size</code> (that we created for the previous graphs), followed by assigning a <code>BOLD</code> typeface for the styling of the text.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> labelTextSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current.resources
	.getDimensionPixelSize(<span class="syntax-all syntax-entity">R</span>.dimen.label_size)
<span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> remember {
	<span class="syntax-all syntax-entity">Paint</span>().<span class="syntax-all syntax-constant">apply</span> {
		textSize <span class="syntax-all syntax-keyword">=</span> labelTextSize.toFloat()				
		typeface <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Typeface</span>.create(
			<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">DEFAULT</span>, <span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">BOLD</span>)
	}
}</code></pre>

<p>Along with the previously calculated <code>maximumValue</code> and data set size, this <code>Paint</code> reference can then be passed directly to the <code>drawValueLabelsOnYAxis</code> function. With this in place, we can now plug this function into our <code>Canvas</code> and see the labels drawn along the y-axis.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LineChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
		<span class="syntax-all syntax-keyword">val</span> labelTextSize <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current.resources
			.getDimensionPixelSize(<span class="syntax-all syntax-entity">R</span>.dimen.label_size)
		<span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> remember {
		    <span class="syntax-all syntax-entity">Paint</span>().<span class="syntax-all syntax-constant">apply</span> {
		        textSize <span class="syntax-all syntax-keyword">=</span> labelTextSize.toFloat()				typeface <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Typeface</span>.create(
					<span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">DEFAULT</span>, <span class="syntax-all syntax-entity">Typeface</span>.<span class="syntax-all syntax-entity">BOLD</span>)
		    }
		}
        <span class="syntax-all syntax-keyword">val</span> highestData <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }

        drawAxis(labelWidth)

        drawValueLabelsOnYAxis(
			highestData, 
			chartData.count(), 
			context.resources
		)
    }
}</code></pre>

<figure><img src="line_2-2.png"/></figure>

<hr />

<h3>Drawing x-axis labels</h3>

<p>With the labels for the y-axis in place, we’re next going to want to draw the labels for the x-axis. We’re going to again start here by creating a reusable function for drawing labels on the x-axis, as we will be able to reuse this for other graphs. When it comes to the drawing of the x-axis labels, this is going to be done at the same time as drawing the data points on the graph - this makes the drawing of the labels simpler, as it can be done at the same time as drawing the data points on the graph.</p>

<p>We’re going to start here by creating a new function, <code>drawDataLabelsOnXAxis</code>, which will take three arguments:</p>

<ul>
	<li><strong>label</strong> - the label to be drawn on the x-axis</li>
	<li><strong> widthSegment</strong> - the width of the segment being drawn in</li>
	<li><strong>index</strong> - the index of the current label being drawn</li>
	<li><strong>resources</strong> - a resources reference used for string operations</li>
	<li><strong>padding</strong> - padding to be applied to the drawing</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawDataLabelsOnXAxis</span>(
    <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">widthSegment</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>,
    <span class="syntax-all syntax-parameter">index</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">resources</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Resources</span>,
    <span class="syntax-all syntax-parameter">padding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>
) {
    

}</code></pre>

<p>With this information, we can now calculate the x-coordinate for the label to be drawn at. Because we’re drawing our information segment-by-segment, we are going to be drawing in each segment one at a time using the <code>index</code> that is provided to the <code>drawDataLabelsOnXAxis</code> function. We can calculate this by taking the provided <code>widthSegment</code> value, and multiplying it by the provided <code>index</code>. Along with any providing padding/spacing values, we will also subtract half of the <code>widthSegment</code> value so that our coordinate is in the center of the segment.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)</code></pre>

<p>For drawing the label we’re again going to use the <code>drawIntoCanvas</code> function, this is where we’ll handle the drawing of the label. When it comes to drawing, while we have the x-coordinate to be used for the label, we’re going to need to modify this value so that we can draw the label at the center of its bounds. We can calculate this by subtracting half of the label width from the calculated <code>drawAtX</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawDataLabelsOnXAxis</span>(
    <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">widthSegment</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>,
    <span class="syntax-all syntax-parameter">index</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">resources</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Resources</span>,
    <span class="syntax-all syntax-parameter">padding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>
) {	
	<span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
    drawIntoCanvas {
        <span class="syntax-all syntax-keyword">val</span> textPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(resources)
        <span class="syntax-all syntax-keyword">val</span> textWidth <span class="syntax-all syntax-keyword">=</span> textPaint.measureText(label)
        <span class="syntax-all syntax-keyword">val</span> centerX <span class="syntax-all syntax-keyword">=</span> drawAtX <span class="syntax-all syntax-keyword">-</span> (textWidth <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
    }
}</code></pre>

<p>We can then again use the <code>drawText</code> function to draw the label onto the canvas. For this we’ll need to provide several argument values:</p>

<ul>
	<li><strong>text</strong> - the label to be drawn onto the canvas</li>
	<li><strong>x</strong> - the x-coordinate the label is to be drawn at. The is the half-point value that we just calculated</li>
	<li><strong>y</strong> - the y-coordinate the label is to be drawn at. We want to draw the label at the bottom of the y-axis, so for this, we can use the height of the canvas</li>
	<li><strong>paint</strong> - the <code>Paint</code> reference used to draw the label, which is being provided to the function</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// drawingUtil.kt
</span>
<span class="syntax-all syntax-keyword">fun</span> DrawScope.<span class="syntax-all syntax-entity">drawDataLabelsOnXAxis</span>(
    <span class="syntax-all syntax-parameter">label</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">String</span>,
    <span class="syntax-all syntax-parameter">widthSegment</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>,
    <span class="syntax-all syntax-parameter">index</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Int</span>,
    <span class="syntax-all syntax-parameter">resources</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Resources</span>,
    <span class="syntax-all syntax-parameter">padding</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span>
) {
	<span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
    drawIntoCanvas {
        <span class="syntax-all syntax-keyword">val</span> textPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(resources)
        <span class="syntax-all syntax-keyword">val</span> textWidth <span class="syntax-all syntax-keyword">=</span> textPaint.measureText(label)
        <span class="syntax-all syntax-keyword">val</span> centerX <span class="syntax-all syntax-keyword">=</span> drawAtX <span class="syntax-all syntax-keyword">-</span> (textWidth <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
        it.nativeCanvas.drawText(
			label, 
			centerX, 
			size.height, 
			textPaint
		)
    }
}</code></pre>

<p>With this function now in place, we can plug this directly into our <code>LineChart</code> composable. Once the axis has been drawn, we can loop through the provided <code>GraphData</code> and draw each of the labels from the data set.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LineChart.kt
</span>
<span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    ...

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> highestData <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }

        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 
			chartData.count()

        drawAxis(labelWidth)

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            drawDataLabelsOnXAxis(
				chartData.label,
                widthSegment,
                index,
                context.resources,
                labelWidth <span class="syntax-all syntax-keyword">+</span> padding
			)
        }

        drawValueLabelsOnYAxis(
			highestData, 
			chartData.count(), 
			labelTextPaint
		)
    }
}</code></pre>

<figure><img src="line_3.png"/></figure>

<hr />

<h3>Drawing data values on the graph</h3>

<p>Now that we have the axis and corresponding labels drawn, we can start to think about drawing the dataset values onto the graph. For our line graph, each entry in the data set is going to be represented by a circle, and then these circles will be joined together using a line. We’re going to start here by tackling the drawing of the circles for the set entries.</p>

<p>When it comes to drawing the circles, we’re going to be utilising the <code>drawCircle</code> function when drawing inside the <code>Canvas</code>. For this function, we’re going to need to provide several different values to the function.</p>

<ul>
	<li><strong>color</strong> - the color to be used when drawing the circle. For this, we’ll simply pass the <code>Color</code> value from the corresponding <code>GraphData</code> reference.</li>
	<li><strong>radius</strong> - the radius to be used when drawing the circle</li>
	<li><strong>center</strong> - the center point to be used when drawing the circle</li>
</ul>

<p>For the radius and center values, we’re going to need to provide some calculated values for drawing the circle. The <code>center</code> value takes the form of the <code>Offset</code> class - this class takes both an <code>x</code> and <code>y</code> coordinate to be used for drawing. For the <code>x</code> value we can utilise the <code>drawAtX</code> value that we previously calculated for the drawing of our data labels. For the <code>y</code> coordinate, we’re going to need to calculate where on this axis our data value corresponds. We can calculate this by calculating how many equal segments there are within the height of the canvas - this can be calculated by taking the height of the canvas (minus the padding at the top of the bottom), and dividing this value by the highest value into the data set that we previously calculated. Now that we have the height of the segment, we can multiply this by the <code>value</code> within the corresponding <code>GraphData</code> reference to know how many segments the current value should occupy.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> highestData

<span class="syntax-all syntax-entity">Offset</span>(
	drawAtX,
	heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value
)</code></pre>

<p>With this calculation in place, we can now slot this into the <code>drawCircle</code> function call. The last thing we need to calculate now is the <code>radius</code> value.</p>

<pre><code class="code-highlighted code-kt">drawCircle(
	chartData.color,
	radius <span class="syntax-all syntax-keyword">=</span> ...,
	center <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
		drawAtX,
		heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value
	)
)</code></pre>

<p>For the radius, we’re going to have a statically defined circle size, which we will animate using the same transition logic that we defined earlier. We’ll start by using the <code>configureAnimation</code> function to instantiate and create a reference to the transition, followed by defining a size for the radius of the circle - we’ll again use <code>LocalDensity</code> for this to create a density specific sizing.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
    <span class="syntax-all syntax-keyword">val</span> pointRadius <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">10</span>.dp.toPx() 
	}

    ...
}</code></pre>

<p>With these in place, we can then calculate the radius by multiplying the <code>pointRadius</code> value by the current <code>value</code> of the transition.</p>

<pre><code class="code-highlighted code-kt">radius <span class="syntax-all syntax-keyword">=</span> pointRadius <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value</code></pre>

<p>We can then slot this into the <code>drawCircle</code> function call, completing the logic used to draw and animate the circle points onto the canvas.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
    <span class="syntax-all syntax-keyword">val</span> pointRadius <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">10</span>.dp.toPx() 
	}

	...

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        ...
        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 					highestData

        drawAxis(labelWidth)

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> 
				(widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)

            drawCircle(
                chartData.color,
                radius <span class="syntax-all syntax-keyword">=</span> pointRadius <span class="syntax-all syntax-keyword">*</span> 
					transitionAnimation.value,
                center <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
                    drawAtX,
                    heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value
                )
            )

            ...
        }

        ...
    }
}</code></pre>

<figure><img src="line_4.png"/></figure>

<hr />

<h3>Joining the circles</h3>

<p>Now that we have these circles being drawn on the graph, the last thing to do now is to connect the dots and draw a line on the graph. When it comes to drawing these lines, the logic is going to be quite similar to how the circles are being drawn on the canvas. To draw these lines we’re going to need a collection of <code>Offset</code> references that represent the points on the graph where the lines should be connected, these are going to be the same points that the circles are being drawn - so we’re going to start by extracting the previous <code>drawAtX</code> logic and using it to create a collection of <code>Offset</code> references.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> pointsToDraw <span class="syntax-all syntax-keyword">=</span> chartData.mapIndexed { 
	index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-entity">Offset</span>(
    	padding <span class="syntax-all syntax-keyword">+</span> labelWidth <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> 
			(widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>),
        heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value
    )
}</code></pre>

<p>We can then start by updating the <code>drawCircle</code> logic to access the <code>Offset</code> at a given index from this collection.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current

    <span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label

    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-keyword">val</span> pointRadius <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">10</span>.dp.toPx() 
	}

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> highestData <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }

        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 
			chartData.count()
        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 
			highestData

        drawAxis(labelWidth)

        <span class="syntax-all syntax-keyword">val</span> pointsToDraw <span class="syntax-all syntax-keyword">=</span> chartData.mapIndexed { 
			index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            	<span class="syntax-all syntax-entity">Offset</span>(padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> labelWidth <span class="syntax-all syntax-keyword">+</span>
					(widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> 
					(widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>),
                heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value
            )
        }

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            drawCircle(
                chartData.color,
                radius <span class="syntax-all syntax-keyword">=</span> pointRadius <span class="syntax-all syntax-keyword">*</span> 
					transitionAnimation.value,
                center <span class="syntax-all syntax-keyword">=</span> pointsToDraw[index]
            )

            drawDataLabelsOnXAxis(
				chartData.label, 
				drawAtX, 
				labelTextPaint
			)
        }

        drawValueLabelsOnYAxis(
			highestData, 
			chartData.count(), 
			labelTextPaint
		)
    }
}</code></pre>

<p>When it comes to drawing the line, we’re going to need to loop through this collection of <code>Offset</code> references and use the <code>drawLine</code> function to connect the circles within our graph. When it comes to calling this function, we need to provide a few values:</p>

<ul>
	<li><strong>color</strong> - the color to be used when drawing the line, we’re simply going to pass the <code>Color.Black</code> value here.</li>
	<li><strong>start</strong> - the starting <code>Offset</code> of the line, representing where the drawing of the line should start</li>
	<li><strong>end</strong> - the end <code>Offset</code> of the line, representing where the drawing of the line should finish</li>
</ul>

<pre><code class="code-highlighted code-kt">pointsToDraw.forEachIndexed { index, startOffset <span class="syntax-all syntax-keyword">-&gt;</span>
    drawLine(
        ...
    )
}</code></pre>

<p>From the arguments of the <code>drawLine</code> function, we can see that we need to know two of the data values - one for the start position and one for the end so that we can draw a line between the two. Using the index of the current item in the loop, we’ll increment this to retrieve the next point to draw. We’ll then use this to create the end offset by using the start/end values to calculate the coordinates for the <code>Offset</code> reference. We’ll multiple both of these values by the current value for the transition, allowing the calculation to be animated.</p>

<pre><code class="code-highlighted code-kt">pointsToDraw.forEachIndexed { index, startOffset <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> nextPoint <span class="syntax-all syntax-keyword">=</span> pointsToDraw[index <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>]
	<span class="syntax-all syntax-keyword">val</span> endOffset <span class="syntax-all syntax-keyword">=</span> nextPoint.copy(
        x <span class="syntax-all syntax-keyword">=</span> startOffset.x <span class="syntax-all syntax-keyword">+</span> 
			((nextPoint.x <span class="syntax-all syntax-keyword">-</span> startOffset.x) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value),
        y <span class="syntax-all syntax-keyword">=</span> startOffset.y <span class="syntax-all syntax-keyword">+</span> 
			((nextPoint.y <span class="syntax-all syntax-keyword">-</span> startOffset.y) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value)
    )
}</code></pre>

<p>We’ll then use this calculated <code>Offset</code> to call the <code>drawLine</code> function to draw a line between the start and end <code>Offset</code> values.</p>

<pre><code class="code-highlighted code-kt">pointsToDraw.forEachIndexed { index, startOffset <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> nextPoint <span class="syntax-all syntax-keyword">=</span> pointsToDraw[index <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>]
	<span class="syntax-all syntax-keyword">val</span> endOffset <span class="syntax-all syntax-keyword">=</span> nextPoint.copy(
        x <span class="syntax-all syntax-keyword">=</span> startOffset.x <span class="syntax-all syntax-keyword">+</span> 
			((nextPoint.x <span class="syntax-all syntax-keyword">-</span> startOffset.x) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value),
        y <span class="syntax-all syntax-keyword">=</span> startOffset.y <span class="syntax-all syntax-keyword">+</span> 
			((nextPoint.y <span class="syntax-all syntax-keyword">-</span> startOffset.y) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value)
    )
	drawLine(
        color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
        start <span class="syntax-all syntax-keyword">=</span> startOffset,
        end <span class="syntax-all syntax-keyword">=</span> nextOffset,
        strokeWidth <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8f</span>
    )
}</code></pre>

<p>As this is, we’ll see a crash when trying to run this code. This is because of the <code>index + 1</code> operation - this will result in an <code>IndexOutOfBounds</code> exception because we’ll be trying to access an index greater than the size of the list. To prevent this from happening, we’ll wrap our logic in a check to ensure that the current index is <strong>less than</strong> the index of the second to last item in the list. We don’t need to perform the operations for the last item in the list as our logic is already taking into account the <strong>next</strong> offset point.</p>

<pre><code class="code-highlighted code-kt">pointsToDraw.forEachIndexed { index, startOffset <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">&lt;</span> pointsToDraw.count() <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">1</span>) {
		<span class="syntax-all syntax-keyword">val</span> next <span class="syntax-all syntax-keyword">=</span> pointsToDraw[index <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>]
		<span class="syntax-all syntax-keyword">val</span> nextOffset <span class="syntax-all syntax-keyword">=</span> next.copy(
        	x <span class="syntax-all syntax-keyword">=</span> startOffset.x <span class="syntax-all syntax-keyword">+</span> 
				((next.x <span class="syntax-all syntax-keyword">-</span> startOffset.x) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value),
        	y <span class="syntax-all syntax-keyword">=</span> startOffset.y <span class="syntax-all syntax-keyword">+</span> 
				((next.y <span class="syntax-all syntax-keyword">-</span> startOffset.y) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value)
        )
        drawLine(
            color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
            start <span class="syntax-all syntax-keyword">=</span> startOffset,
            end <span class="syntax-all syntax-keyword">=</span> nextOffset,
            strokeWidth <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8f</span>
       	)
    }
}</code></pre>

<p>We can then slot this logic into our <code>LineChart</code> composable, resulting in our data set being drawn and animated on the canvas.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">LineChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current

    <span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label

    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-keyword">val</span> pointRadius <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">10</span>.dp.toPx() 
	}

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> highestData <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }

        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 
			chartData.count()
        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 
			highestData

        drawAxis(labelWidth)

        <span class="syntax-all syntax-keyword">val</span> pointsToDraw <span class="syntax-all syntax-keyword">=</span> chartData.mapIndexed { 
			index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            	<span class="syntax-all syntax-entity">Offset</span>(padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> labelWidth <span class="syntax-all syntax-keyword">+</span>
					(widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> 
					(widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>),
                heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value
            )
        }

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>

            drawCircle(
                chartData.color,
                radius <span class="syntax-all syntax-keyword">=</span> pointRadius <span class="syntax-all syntax-keyword">*</span> 
					transitionAnimation.value,
                center <span class="syntax-all syntax-keyword">=</span> pointsToDraw[index]
            )

            drawDataLabelsOnXAxis(
				chartData.label, 
				drawAtX, 
				labelTextPaint
			)
        }

        pointsToDraw.forEachIndexed { index, startOffset <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">&lt;</span> pointsToDraw.count() <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">1</span>) {
                <span class="syntax-all syntax-keyword">val</span> next <span class="syntax-all syntax-keyword">=</span> pointsToDraw[index <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>]
                <span class="syntax-all syntax-keyword">val</span> nextOffset <span class="syntax-all syntax-keyword">=</span> next.copy(
                    x <span class="syntax-all syntax-keyword">=</span> startOffset.x <span class="syntax-all syntax-keyword">+</span> 
						((next.x <span class="syntax-all syntax-keyword">-</span> startOffset.x) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value),
                    y <span class="syntax-all syntax-keyword">=</span> startOffset.y <span class="syntax-all syntax-keyword">+</span> 
						((next.y <span class="syntax-all syntax-keyword">-</span> startOffset.y) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value)
                )
                drawLine(
                    color <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>,
                    start <span class="syntax-all syntax-keyword">=</span> startOffset,
                    end <span class="syntax-all syntax-keyword">=</span> nextOffset,
                    strokeWidth <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">8f</span>
                )
            }
        }

        drawValueLabelsOnYAxis(
			highestData, 
			chartData.count(), 
			labelTextPaint
		)
    }
}</code></pre>

<figure><img src="line-1.png"/></figure>

<hr />

<h2>Building the Bar Chart</h2>

<p>Moving on from the Line Chat, we can start to look at bar-style graphs to present our dataset. We’ll start by exploring the bar chart - this composable will take our data set, composing a bar graph based on the data that is provided to it.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BarChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)</code></pre>

<p>Similar to the other graphs that we’ve composed, we’re going to start by setting up our drawing area in the form of a <code>Canvas</code>. This is going to fill the maximum available height while taking a hardcoded height so that the canvas knows how much space is being occupied.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BarChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
   
    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">280</span>.dp)
            .fillMaxWidth()
            .padding(
				start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, 
				end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp
			)
    ) {
    
	}
}</code></pre>

<hr />

<h3>Drawing the axis</h3>

<p>We’re going to start here by drawing the axis of the graph. For this, we’re going to reuse the <code>drawAxis</code> function that we previously created. So that we can provide the required spacing when drawing the axis, we’re going to need to calculate the width of the text that is going to be drawn for the y-axis labels. Here we’ll use our <code>labelTextPaint</code> function that we previously defined, followed by measuring the text. We can then pass this calculated value when calling the <code>drawAxis</code> function.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BarChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current	
	<span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label
	<span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">280</span>.dp)
            .fillMaxWidth()
            .padding(
				start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, 
				end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp
			)
    ) {
        drawAxis(labelWidth)
    }
}</code></pre>

<figure><img src="bar_1.png"/></figure>

<hr />

<h3>Drawing the y-axis labels</h3>

<p>Now that we have the axis in place, we can start to draw the labels along each side of the axis - we’ll start here with the labels for the y-axis. Compared to how the labels were drawn on the y-axis for the other graphs, things are going to look slightly different here. This is because for the other graphs we were drawing calculated values that represent the <code>value</code> of the data being drawn - in the case of their chart we want to draw the <code>label</code> of each entry on the y-axis, so we can’t re-use the code that we previously created. Some of the maths is going to be very similar here, so let’s break down what we need to do.</p>

<p>We’ll start by calculating the height segments that are available for us to draw within. Because we’re working with a fixed data set, we’ll want to split the height of our chart up into equal segments. This is going to equal:</p>

<pre><code class="code-highlighted code-kt">((chart height) <span class="syntax-all syntax-keyword">-</span> (padding) <span class="syntax-all syntax-keyword">-</span> (axis stroke thickness) <span class="syntax-all syntax-keyword">-</span> (spacing between each bar)) <span class="syntax-all syntax-keyword">/</span> (number of graph entries)</code></pre>

<p>This calculation will take the available drawing area of the graph and split it into a collection of equally sized segments. Using the information that we have available within our composable, we can recreate this like so:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> columnSpacing <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">6f</span>
<span class="syntax-all syntax-keyword">val</span> numberOfValues <span class="syntax-all syntax-keyword">=</span> chartData.count()
<span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> strokeThickness <span class="syntax-all syntax-keyword">-</span> 		(padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> (columnSpacing <span class="syntax-all syntax-keyword">*</span> (numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>))) <span class="syntax-all syntax-keyword">/</span> numberOfValues</code></pre>

<p>One key point here is this <code>columnSpacing</code> reference. We define this as the spacing that will be left between each bar - otherwise, our bars would be touching each other (and make the graph a bit more difficult to read). There is going to be spacing at the top of every bar, as well as at the bottom of the last one - so we need to take this value and multiply it by the number of graph entries + 1.</p>

<p>Now that we have the segment size calculated, we start writing the code to draw each label. We’ll start by defining a loop for the information in our <code>chartData</code> collection, followed by calculating the y position for each label that is going to be drawn. We can calculate this by taking the <code>padding</code> and <code>columnSpacing</code> values (as there is always going to be a final spacing at the bottom of the graph), followed by the calculating where we are at in regards to the current height segment - taking the sum of the <code>columnSpacing</code> and <code>heightSegment</code> in regards to the current <code>index</code> will give us this position.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> 
		((columnSpacing <span class="syntax-all syntax-keyword">+</span> heightSegment) <span class="syntax-all syntax-keyword">*</span> index)
}</code></pre>

<p>Now that we have this y-coordinate calculated, we can move on to the drawing of the label. While we have the y-coordinate that we can draw at, we’re going to need to tweak this so that we are drawing the label in the center of the bounds - this will allow us to align the label with the vertical centre of the bar. We can get this value by calculating the current bounds of the text, followed by using this value to modify the calculated <code>drawAtY</code> and give us a central location to draw at.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> 
		((columnSpacing <span class="syntax-all syntax-keyword">+</span> heightSegment) <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> textPadding
	drawIntoCanvas {
		<span class="syntax-all syntax-keyword">val</span> bounds <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Rect</span>().<span class="syntax-all syntax-constant">also</span> { rect <span class="syntax-all syntax-keyword">-&gt;</span>
			labelTextPaint.getTextBounds(
				chartData.label, <span class="syntax-all syntax-constant">0</span>,
				chartData.label.length, rect)
            }
        <span class="syntax-all syntax-keyword">val</span> centerY <span class="syntax-all syntax-keyword">=</span> drawAtY <span class="syntax-all syntax-keyword">+</span> (heightSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">+</span> 
			(bounds.height() <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
        it.nativeCanvas.drawText(
			chartData.label, 
			<span class="syntax-all syntax-constant">0f</span>, centerY, 
			labelTextPaint
		)
    }
}</code></pre>

<p>We can then slot this code into our composable and see our y-axis labels being drawn.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BarChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    
    ...

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">280</span>.dp)
            .fillMaxWidth()
            .padding(
				start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, 
				end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp
			)
    ) {
        <span class="syntax-all syntax-keyword">val</span> columnSpacing <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">6f</span>
        <span class="syntax-all syntax-keyword">val</span> numberOfValues <span class="syntax-all syntax-keyword">=</span> chartData.count()
        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> strokeThickness <span class="syntax-all syntax-keyword">-</span> 		(padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> 
			(columnSpacing <span class="syntax-all syntax-keyword">*</span> (numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>))) <span class="syntax-all syntax-keyword">/</span> numberOfValues

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> 
				((columnSpacing <span class="syntax-all syntax-keyword">+</span> heightSegment) <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> textPadding
            drawIntoCanvas {
                <span class="syntax-all syntax-keyword">val</span> bounds <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Rect</span>().<span class="syntax-all syntax-constant">also</span> { rect <span class="syntax-all syntax-keyword">-&gt;</span>
                	labelTextPaint.getTextBounds(
						chartData.label, <span class="syntax-all syntax-constant">0</span>,
						chartData.label.length, rect)
                }
                <span class="syntax-all syntax-keyword">val</span> centerY <span class="syntax-all syntax-keyword">=</span> drawAtY <span class="syntax-all syntax-keyword">+</span> (heightSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">+</span> 
					(bounds.height() <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
                it.nativeCanvas.drawText(
					chartData.label, 
					<span class="syntax-all syntax-constant">0f</span>, centerY, 
					labelTextPaint
				)
            }
        }

        drawAxis(labelWidth)
    }
}</code></pre>

<figure><img src="bar_2.png"/></figure>

<hr />

<h3>Drawing the x-axis labels</h3>

<p>With the y-axis labels in place, we can naturally move on to drawing the labels for the x-axis of the graph. Similar to the y-axis labels, we’re unable to re-use any code that we defined earlier - this is because we’re drawing the calculated values for the graph <code>value</code> properties to be mapped against, as opposed to labels that were drawn for the previous graph x-axis.</p>

<pre><code class="code-highlighted code-kt">repeat(numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>) { value <span class="syntax-all syntax-keyword">-&gt;</span>
	drawIntoCanvas {

	}
}</code></pre>

<p>Within this loop, we’re going to want to start by calculating the value that is going to be drawn for the label. We’ll first need to calculate the value of each segment along the x-axis. Because these are going to be of equal width, we’ll need to start by retrieving the highest value from the <code>chartData</code> collection.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> highestValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }</code></pre>

<p>We can then take this value and divide it by the number of values that are present in the <code>chartData</code> - this is going to be the distance between each width segment. Multiplying this value by the current index of the loop will give us the label to be drawn at the current point on the x-axis.</p>

<pre><code class="code-highlighted code-kt">repeat(numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>) { value <span class="syntax-all syntax-keyword">-&gt;</span>
	drawIntoCanvas {
		<span class="syntax-all syntax-keyword">val</span> points <span class="syntax-all syntax-keyword">=</span> (highestValue <span class="syntax-all syntax-keyword">/</span> numberOfValues) <span class="syntax-all syntax-keyword">*</span> value
    }
}</code></pre>

<p>We’ll next need to calculate where this is going to be drawn on the x-axis of the canvas. This value is going to be equal to:</p>

<pre><code class="code-highlighted code-kt">(the current width segment) <span class="syntax-all syntax-keyword">+</span> (half of the label width) <span class="syntax-all syntax-keyword">+</span> (graph padding)</code></pre>

<p>The point of the current width segment gives us the starting point of where the segment area begins, followed by adding on any additional padding that is being used for our graph.</p>

<pre><code class="code-highlighted code-kt">repeat(numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>) { value <span class="syntax-all syntax-keyword">-&gt;</span>
	drawIntoCanvas {
		<span class="syntax-all syntax-keyword">val</span> points <span class="syntax-all syntax-keyword">=</span> (highestValue <span class="syntax-all syntax-keyword">/</span> numberOfValues) <span class="syntax-all syntax-keyword">*</span> value
        
		<span class="syntax-all syntax-keyword">val</span> width <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> labelWidth

        <span class="syntax-all syntax-keyword">val</span> xPosition <span class="syntax-all syntax-keyword">=</span> ((width <span class="syntax-all syntax-keyword">/</span> numberOfValues) <span class="syntax-all syntax-keyword">*</span> value) <span class="syntax-all syntax-keyword">+</span> 		labelWidth <span class="syntax-all syntax-keyword">+</span> padding
    }
}</code></pre>

<p>With these values calculated, we can now make a call to the <code>drawText</code> function within our <code>Canvas</code>. Along with passing the label to be drawn, we need to provide the calculated <code>xPosition</code>, along with the <code>Paint</code> reference used to draw the label. We’ll also pass the <code>height</code> of the <code>Canvas</code> for the y-coordinate to be drawn, as we want to draw the labels at the bottom of the <code>Canvas</code>.</p>

<pre><code class="code-highlighted code-kt">repeat(numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>) { value <span class="syntax-all syntax-keyword">-&gt;</span>
	drawIntoCanvas {
		<span class="syntax-all syntax-keyword">val</span> points <span class="syntax-all syntax-keyword">=</span> (highestValue <span class="syntax-all syntax-keyword">/</span> numberOfValues) <span class="syntax-all syntax-keyword">*</span> value
        <span class="syntax-all syntax-keyword">val</span> width <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> labelWidth

        <span class="syntax-all syntax-keyword">val</span> textWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(
			points.toString())

        <span class="syntax-all syntax-keyword">val</span> xPosition <span class="syntax-all syntax-keyword">=</span> ((width <span class="syntax-all syntax-keyword">/</span> numberOfValues) <span class="syntax-all syntax-keyword">*</span> value) <span class="syntax-all syntax-keyword">+</span> 		labelWidth <span class="syntax-all syntax-keyword">+</span> labelWidth <span class="syntax-all syntax-keyword">+</span> padding <span class="syntax-all syntax-keyword">-</span> 
			(textWidth <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)
		
		it.nativeCanvas.drawText(
            points.toString(),
            xPosition,
            size.height,
            labelTextPaint
        )
    }
}</code></pre>

<p>We can then slot this code into our <code>BarChart</code> composable to see the x-axis labels being drawn.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BarChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
    <span class="syntax-all syntax-keyword">val</span> highestValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
    <span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label

    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">280</span>.dp)
            .fillMaxWidth()
            .padding(
				start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, 
				end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp
			)
    ) {
        <span class="syntax-all syntax-keyword">val</span> columnSpacing <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">6f</span>
        <span class="syntax-all syntax-keyword">val</span> numberOfValues <span class="syntax-all syntax-keyword">=</span> chartData.count()

        ...

        repeat(numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>) { value <span class="syntax-all syntax-keyword">-&gt;</span>
            drawIntoCanvas {
                <span class="syntax-all syntax-keyword">val</span> points <span class="syntax-all syntax-keyword">=</span> (highestValue <span class="syntax-all syntax-keyword">/</span> numberOfValues) <span class="syntax-all syntax-keyword">*</span> 				value
                <span class="syntax-all syntax-keyword">val</span> width <span class="syntax-all syntax-keyword">=</span> size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> 
					labelWidth

                <span class="syntax-all syntax-keyword">val</span> textWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(
					points.toString())
                <span class="syntax-all syntax-keyword">val</span> xPosition <span class="syntax-all syntax-keyword">=</span>
                    ((width <span class="syntax-all syntax-keyword">/</span> numberOfValues) <span class="syntax-all syntax-keyword">*</span> value) <span class="syntax-all syntax-keyword">+</span> 					labelWidth <span class="syntax-all syntax-keyword">+</span> labelWidth <span class="syntax-all syntax-keyword">+</span> 
					padding <span class="syntax-all syntax-keyword">-</span> (textWidth <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>)

                it.nativeCanvas.drawText(
                    points.toString(),
                    xPosition,
                    size.height,
                    labelTextPaint
                )
            }
        }
    }
}</code></pre>

<figure><img src="bar_4.png"/></figure>

<hr />

<h3>Drawing the bars</h3>

<p>Now that we have the axis labels in place, we can move on to drawing the main part of the graph - the bars that represent the value for each graph entry. To draw these bars, we’re going to need to loop through the provided <code>chartData</code> collection. When making this call we’ll need to provide three values:</p>

<ul>
	<li><strong>color</strong> - the color to be used when drawing the shape</li>
	<li><strong>topLeft</strong> - the <code>Offset</code> used to start drawing the shape from the top left-hand corner</li>
	<li><strong>size</strong> - the <code>Size</code> instance is used to define the sizing of the drawn shape</li>
</ul>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
	drawRect(
		chartData.color,
        topLeft <span class="syntax-all syntax-keyword">=</span> ...,
        size <span class="syntax-all syntax-keyword">=</span> ...
    )
}</code></pre>

<p>We’ll start by defining the <code>Size</code> of the shape. For this, the <code>height</code> is going to be equal to the previously calculated <code>heightSegment</code> value for the current <code>chartData</code> entry. When it comes to the <code>width</code>, we’re going to need to calculate this based on the current entry. This is going to be equal to the previously calculated <code>widthSegment</code> value, multiplied by the <code>value</code> for the current <code>chartData</code> entry. After adding on the stroke thickness of the axis, we’ll multiply this result by the current transition value so that the bar is animated when being drawn.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> width <span class="syntax-all syntax-keyword">=</span> ((widthSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">-</span> 
		strokeThickness) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value
	...
}</code></pre>

<p>With this value calculated, we can now provide a <code>Size</code> reference to our <code>drawRect</code> call.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>	<span class="syntax-all syntax-keyword">val</span> width <span class="syntax-all syntax-keyword">=</span> ((widthSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">-</span> 
		strokeThickness) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value
	...
	drawRect(
		chartData.color,
        topLeft <span class="syntax-all syntax-keyword">=</span> ...,
        size <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Size</span>(
			width <span class="syntax-all syntax-keyword">=</span> width, 
			height <span class="syntax-all syntax-keyword">=</span> heightSegment
		)
    )
}</code></pre>

<p>Next, we need to provide an <code>Offset</code> reference to the <code>topLeft</code> argument. We already have all of the data we need for the x-axis, we just need to calculate the value to be provided for the <code>topLeft</code> y-coordinate of our drawing operation. The y-coordinate for the top-left of our drawing operation is going to be equivalent to the number of height segments that the current <code>index</code> of the loop represents, plus any additional padding values that we have defined for our graph. Because we are drawing multiple bars in our graph, starting from the top, the index <code>0</code> through to the number of items in the <code>chartData</code> collection, allows us to draw the bars one by one.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> textPadding
		((columnSpacing <span class="syntax-all syntax-keyword">+</span> heightSegment) <span class="syntax-all syntax-keyword">*</span> index)
	<span class="syntax-all syntax-keyword">val</span> width <span class="syntax-all syntax-keyword">=</span> ((widthSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">-</span> 
		strokeThickness) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value
	...
}</code></pre>

<p>With these values in place, we can now pass this directly to the <code>topLeft</code> argument in the form of an <code>Offset</code> instance. For the x-coordinate of this, we’ll simply pass the <code>labelWidth</code> plus any defined padding values that we need to take into account - this will ensure that the drawing takes place at the start of the x-axis of our graph.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> 
		((columnSpacing <span class="syntax-all syntax-keyword">+</span> heightSegment) <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> textPadding
	<span class="syntax-all syntax-keyword">val</span> width <span class="syntax-all syntax-keyword">=</span> ((widthSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">-</span> 
		strokeThickness) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value
	...
	drawRect(
		chartData.color,
        topLeft <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> labelWidth <span class="syntax-all syntax-keyword">+</span> padding <span class="syntax-all syntax-keyword">+</span> textPadding <span class="syntax-all syntax-keyword">+</span> 					strokeThickness,
            y <span class="syntax-all syntax-keyword">=</span> drawAtY
        ),
        size <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Size</span>(
			width <span class="syntax-all syntax-keyword">=</span> width, 
			height <span class="syntax-all syntax-keyword">=</span> heightSegment
		)
    )
}</code></pre>

<p>We can then slot this code into our <code>BarChart</code> composable, finishing up the drawing of this graph type.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">BarChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
    ...

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">280</span>.dp)
            .fillMaxWidth()
            .padding(
				start <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">16</span>.dp, 
				end <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp, 
				bottom <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">36</span>.dp
			)
    ) {
        <span class="syntax-all syntax-keyword">val</span> columnSpacing <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">6f</span>
        <span class="syntax-all syntax-keyword">val</span> numberOfValues <span class="syntax-all syntax-keyword">=</span> chartData.count()
        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> 
			(size.height <span class="syntax-all syntax-keyword">-</span> strokeThickness <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span>
          	(columnSpacing <span class="syntax-all syntax-keyword">*</span> (numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>))) <span class="syntax-all syntax-keyword">/</span> 
			numberOfValues
        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 
			highestValue

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">val</span> drawAtY <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> 
				((columnSpacing <span class="syntax-all syntax-keyword">+</span> heightSegment) <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> textPadding
            <span class="syntax-all syntax-keyword">val</span> width <span class="syntax-all syntax-keyword">=</span>
                ((widthSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">-</span> 
					strokeThickness) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value
            ...
            drawRect(
                chartData.color,
                topLeft <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
                    x <span class="syntax-all syntax-keyword">=</span> labelWidth <span class="syntax-all syntax-keyword">+</span> padding <span class="syntax-all syntax-keyword">+</span> textPadding <span class="syntax-all syntax-keyword">+</span> 					strokeThickness,
                    y <span class="syntax-all syntax-keyword">=</span> drawAtY
                ),
                size <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Size</span>(
					width <span class="syntax-all syntax-keyword">=</span> width, 
					height <span class="syntax-all syntax-keyword">=</span> heightSegment
				)
            )
        }

        ...
    }
}</code></pre>

<figure><img src="bar-2.png"/></figure>

<hr />

<h2>Building the Column Chart</h2>

<figure><img src="col-1.png"/></figure>

<p>Similar to the other graphs that we’ve composed, we’re going to start by setting up our drawing area in the form of a <code>Canvas</code>. This is going to fill the maximum available height while taking a hardcoded height so that the canvas knows how much space is being occupied.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ColumnChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
  
    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxSize()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {

    }
}</code></pre>

<hr />

<h3>Drawing the axis</h3>

<p>We’re going to start here by drawing the axis of the graph. For this, we’re going to reuse the <code>drawAxis</code> function that we previously created. We’ll need to provide a value for the <code>labelWidth</code> argument, so we’ll again calculate the bounds of our text to satisfy this argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ColumnChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
	
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
    <span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label
    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)
  
    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxSize()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        drawAxis(labelWidth)
    }
}</code></pre>

<p>With the padding and height that has been applied to the <code>Canvas</code> we can see the axis being drawn with sufficient spacing around the bounds.</p>

<figure><img src="col_1.png"/></figure>

<hr />

<h3>Drawing the y-axis labels</h3>

<p>When it comes to the axis labels of our graph, we’re going to start by drawing the labels for the y-axis. For this, we’re going to be reusing the <code>drawValueLabelsOnYAxis</code> function that we previously created, but we first need some information that we can provide to the function. The function needs to know the maximum value that is going to be drawn for the y-axis labels, which is going to be the highest value in the <code>GraphData</code> collection that is provided to our <code>AreaChart</code> composable. We can calculate this value using the kotlin <code>maxOf</code> function on the provided <code>chartData</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ColumnChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }
    ...
}</code></pre>

<p>We also need to provide two other values to the function:</p>

<ul>
	<li><strong>labelCount</strong> - the number of labels to be displayed, this will be the number of items in the <code>chartData</code> collection</li>
	<li><strong>resources</strong> - this is a Resources reference that is used by the function to retrieve application resource values</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ColumnChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	...

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxSize()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {

        drawAxis(labelWidth)

        drawValueLabelsOnYAxis(
			maximumValue, chartData.count(), context.resources)
    }
}</code></pre>

<p>With this function call being made, we can now see the y-axis label being drawn onto the canvas alongside the y-axis line.</p>

<figure><img src="col_3.png"/></figure>

<hr />

<h3>Drawing the x-axis labels</h3>

<p>With the y-axis labels now in place, we can move on to drawing the labels for the x-axis. When it comes to drawing the labels and data points onto the x-axis of the graph, we’re going to need to split the width of the graph into equal segments that can be drawn into - this allows us to evenly space the pieces of information that are being drawn onto the <code>Canvas</code>. </p>

<figure><img src="width.png"/></figure>

<p>We’re going to start here by calculating the width of these segments. This is going to look a little different from the previously calculated width segments because each column in the chart is going to have spacing between one another, so we need to account for this when calculating how much width is available for each segment.</p>

<p>This calculation is going to be the width of the x-axis line, minus the width that is occupied by blank space between each of the columns (the number of separators is always going to be one more than the number of columns in the graph). We can then take this calculated value and divide it by the number of entries in our <code>chartData</code> collection - as this will give us an equal-sized segment for each entry in this collection. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> numberOfValues <span class="syntax-all syntax-keyword">=</span> chartData.count()
<span class="syntax-all syntax-keyword">val</span> occupiedSeparatorSpacing <span class="syntax-all syntax-keyword">=</span> columnSpacing <span class="syntax-all syntax-keyword">*</span> 
	(numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>)
<span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> 
	occupiedSeparatorSpacing) <span class="syntax-all syntax-keyword">/</span> numberOfValues</code></pre>

<p>Next, we’re going to want to loop through each entry within our <code>chartData</code> reference and utilise the <code>drawDataLabelsOnXAxis</code> function to draw a label on the x-axis. When calling this function we simply need to pass in this calculated <code>widthSegment</code>, the index of the current item within the loop, along with the label and resources reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ColumnChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }
	...
    
    <span class="syntax-all syntax-keyword">val</span> columnSpacing <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">4</span>.dp.toPx() 
	}

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxSize()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> numberOfValues <span class="syntax-all syntax-keyword">=</span> chartData.count()
		<span class="syntax-all syntax-keyword">val</span> occupiedSeparatorSpacing <span class="syntax-all syntax-keyword">=</span> columnSpacing <span class="syntax-all syntax-keyword">*</span> 
			(numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>)
		<span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> 
			occupiedSeparatorSpacing <span class="syntax-all syntax-keyword">-</span> labelWidth) <span class="syntax-all syntax-keyword">/</span> numberOfValues

        drawAxis(labelWidth)

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
			drawDataLabelsOnXAxis(
                chartData.label,
                widthSegment <span class="syntax-all syntax-keyword">+</span> columnSpacing,
                index,
                context.resources,
				labelWidth <span class="syntax-all syntax-keyword">+</span> padding
            )
        }

        drawValueLabelsOnYAxis(
			maximumValue, chartData.count(), context.resources)
    }
}</code></pre>

<figure><img src="col_4.png"/></figure>

<h3>Drawing the Columns</h3>

<p>Now that we have the axis labels in place, we can move on to drawing the columns that represent the data within the provided <code>GraphData</code> collection. To draw these columns we’re going to be utilising the <code>drawRect</code> within the <code>Canvas</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">drawRect</span>(
 	<span class="syntax-all syntax-parameter">color</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Color</span>,
	<span class="syntax-all syntax-parameter">topLeft</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Offset</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>.<span class="syntax-all syntax-entity">Zero</span>,
	<span class="syntax-all syntax-parameter">size</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Size</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">this</span>.size.offsetSize(topLeft),
	<span class="syntax-all syntax-keyword">/*@FloatRange</span>(<span class="syntax-all syntax-constant">from</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">0.0</span>, to <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1.0</span>)*/
    alpha<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Float</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1.0f</span>,
    style<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">DrawStyle</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Fill</span>,
    colorFilter<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">ColorFilter?</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>,
    blendMode<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">BlendMode</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">DefaultBlendMode</span>
)</code></pre>

<p>When it comes to using this to draw the columns on the graph, we’re going to be provided several values for the available arguments.</p>

<ul>
	<li><strong>color</strong> - the color to be used when drawing the rectangle</li>
	<li><strong>topLeft</strong> - the offset of the shape from the origin of 0,0</li>
	<li><strong>size</strong> - the dimensions of the rectangle being drawn</li>
</ul>

<p>We’re going to be calling this function from within the existing loop for the <code>chartData</code> collection, so for the <strong>color</strong> argument, we can simply pass the <code>color</code> reference from the current <code>GraphData</code> value in the loop.</p>

<pre><code class="code-highlighted code-kt">drawRect(
	chartData.color,
	topLeft <span class="syntax-all syntax-keyword">=</span> ...,
	size <span class="syntax-all syntax-keyword">=</span> ...
)</code></pre>

<p>Next, we’re going to define the <code>Size</code> of the rectangle that we’re drawing. We’ve already calculated the width of this in the form of the <code>widthSegment</code> variable that we previously calculated, so we just need to calculate the height. We’re going to split the height of the graph area up into equal segments so that for each data entry we can fill the corresponding height against the y-axis.</p>

<figure><img src="gggg-1.png"/></figure>

<p>This segment value can be calculated by taking the available drawing space on the canvas (the height of the canvas minus the applied padding), dividing this result by the maximum value within the graph data set. This gives us the drawing height of equally sized segments for the y-axis.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span>
	maximumValue</code></pre>

<p>Using this, we’re then going to want to calculate the height for each of the graph data entries, which is going to be equal to the calculated <code>heightSegment</code> multiplied by the current value within our <code>GraphData</code> loop.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> height <span class="syntax-all syntax-keyword">=</span> heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value</code></pre>

<p>Finally, because we want to animate the height of the columns as they are drawn onto the canvas, we’re next going to utilise the previously created <code>configureAnimation</code> to create an animated value for our <code>chartData</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)</code></pre>

<p>We can then modify the <code>height</code> value calculation so that the result of the previous calculation is multiplied by the animation value. This will take the height of the graph entry and multiply it from 0f to 1f, allowing the height of the column to be animated to its full height.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> height <span class="syntax-all syntax-keyword">=</span> (heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">*</span>
	transitionAnimation.value</code></pre>

<p>We can then slot this code into the corresponding places inside of the <code>ColumnChart</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ColumnChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    ...

    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxSize()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        ...
        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> 			occupiedSeparatorSpacing <span class="syntax-all syntax-keyword">-</span> labelWidth) <span class="syntax-all syntax-keyword">/</span> 		
			numberOfValues

        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 
			maximumValue

        drawAxis(labelWidth)

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
			<span class="syntax-all syntax-keyword">val</span> height <span class="syntax-all syntax-keyword">=</span> ((heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">-</span> strokeThickness) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value

            drawRect(
                chartData.color,
                topLeft <span class="syntax-all syntax-keyword">=</span> ...,
                size <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Size</span>(
					width <span class="syntax-all syntax-keyword">=</span> widthSegment, 
					height <span class="syntax-all syntax-keyword">=</span> height
				)
            )

            ...
        }

        ...
    }
}</code></pre>

<p>At this point, we now only need to provide a value for the <code>topLeft</code> argument of the <code>drawRect</code> function. While we have the size of the rectangle that is being drawn, this value will represent the starting point for where the rectangle is to be drawn. We’re going to start here by calculating the x-coordinate for where each of the columns is going to be drawn.</p>

<p>Taking into account all of the padding and spacing that has been defined so far, the x-coordinate drawing location is going to start from the point where the x-axis starts within the canvas, which is going to be equivalent to the defined <code>padding</code> and <code>textPadding</code> values, plus an initial <code>columnSpacing</code> value.</p>

<p>Then, we’re going to want to take the <code>columnSpacing</code> and <code>widthSegment</code> values and multiply them by the current <code>index</code> within the <code>chartData</code> loop. This will mean that as we loop through the <code>chartData</code> values, the x-coordinate that is to be drawn at will be positioned at each segment along the x-axis of the graph.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> 				
	((columnSpacing <span class="syntax-all syntax-keyword">+</span> widthSegment) <span class="syntax-all syntax-keyword">*</span> index)</code></pre>

<p>With this in place, we now need to calculate the starting y-coordinate that the rectangle is to be drawn at. This is going to be the height of the canvas, subtracting both the <code>padding</code> and <code>strokeThickness</code> values - as this will ensure that the y-coordinate for drawing is positioned at the base of the y-axis and above the line that is being drawn for the x-axis.</p>

<pre><code class="code-highlighted code-kt">size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness</code></pre>

<p>As it is, this won’t work. Because we are animating the height of the rectangle, the y position of the offset is also going to need to be animated. To achieve the desired value for the y-axis we subtract the <code>height</code> value from the result of the calculation above. This means that the y-coordinate will now be calculated based on the current animated position of the <code>height</code> value.</p>

<pre><code class="code-highlighted code-kt">size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness <span class="syntax-all syntax-keyword">-</span> height</code></pre>

<p>We can now slot this code into the <code>chartData</code> loop, meaning that the requirements for the <code>drawRect</code> function call have now been satisfied.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
	<span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> 				
		((columnSpacing <span class="syntax-all syntax-keyword">+</span> widthSegment) <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> textPadding
	<span class="syntax-all syntax-keyword">val</span> height <span class="syntax-all syntax-keyword">=</span> (heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value

	drawRect(
		chartData.color,
		topLeft <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
            x <span class="syntax-all syntax-keyword">=</span> drawAtX,
            y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness <span class="syntax-all syntax-keyword">-</span> 
				topLeft
        ),
        size <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Size</span>(
			width <span class="syntax-all syntax-keyword">=</span> widthSegment, 
			height <span class="syntax-all syntax-keyword">=</span> height
		)
    )
}</code></pre>

<p>With this in place, we now have a complete <code>ColumnChart</code> composable that is drawing the provided <code>GraphData</code> collection, animating the data set onto the <code>Canvas</code> when it is being drawn.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ColumnChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
    <span class="syntax-all syntax-keyword">val</span> columnSpacing <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">with</span>(<span class="syntax-all syntax-entity">LocalDensity</span>.current) { 
		<span class="syntax-all syntax-constant">4</span>.dp.toPx() 
	}
    <span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	<span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label
    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxSize()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> numberOfValues <span class="syntax-all syntax-keyword">=</span> chartData.count()
        <span class="syntax-all syntax-keyword">val</span> occupiedSeparatorSpacing <span class="syntax-all syntax-keyword">=</span> columnSpacing <span class="syntax-all syntax-keyword">*</span>
            (numberOfValues <span class="syntax-all syntax-keyword">+</span> <span class="syntax-all syntax-constant">1</span>)
        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>) <span class="syntax-all syntax-keyword">-</span> 
			occupiedSeparatorSpacing <span class="syntax-all syntax-keyword">-</span> labelWidth) <span class="syntax-all syntax-keyword">/</span> numberOfValues

        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 		maximumValue

        drawAxis(labelWidth)

        chartData.forEachIndexed { index, chartData <span class="syntax-all syntax-keyword">-&gt;</span>
            <span class="syntax-all syntax-keyword">val</span> drawAtX <span class="syntax-all syntax-keyword">=</span> padding <span class="syntax-all syntax-keyword">+</span> columnSpacing <span class="syntax-all syntax-keyword">+</span> 					((columnSpacing <span class="syntax-all syntax-keyword">+</span> widthSegment) <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> 				textPadding
            <span class="syntax-all syntax-keyword">val</span> height <span class="syntax-all syntax-keyword">=</span> ((heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">-</span> 			strokeThickness) <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value
            <span class="syntax-all syntax-keyword">val</span> topLeft <span class="syntax-all syntax-keyword">=</span> (heightSegment <span class="syntax-all syntax-keyword">*</span> chartData.value) <span class="syntax-all syntax-keyword">*</span> 			transitionAnimation.value

            drawRect(
                chartData.color,
                topLeft <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
                    x <span class="syntax-all syntax-keyword">=</span> drawAtX,
                    y <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness 
						<span class="syntax-all syntax-keyword">-</span> topLeft
                ),
                size <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Size</span>(
					width <span class="syntax-all syntax-keyword">=</span> widthSegment, 
					height <span class="syntax-all syntax-keyword">=</span> height
				)
            )

            drawDataLabelsOnXAxis(
                chartData.label,
                widthSegment <span class="syntax-all syntax-keyword">+</span> columnSpacing,
                index,
                context.resources,
				labelWidth <span class="syntax-all syntax-keyword">+</span> padding
            )
        }

        drawValueLabelsOnYAxis(
			maximumValue, 
			chartData.count(), 
			context.resources
		)
    }
}</code></pre>

<figure><img src="col-2.png"/></figure>

<hr />

<h2>Building the Area Chart</h2>

<p>Next up in our collection of graphs is the Area Graph - this allows us to display a graph similar to that of a line graph, but with a filled area.</p>

<figure><img src="area.png"/></figure>

<p>We’ll start here by creating a new composable function, <code>AreaChart</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AreaChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)</code></pre>

<p>Similar to the other graphs that we’ve composed, we’re going to start by setting up our drawing area in the form of a <code>Canvas</code>. This is going to fill the maximum available height while taking a hardcoded height so that the canvas knows how much space is being occupied.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AreaChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {

    }
}</code></pre>

<h3>Drawing the axis</h3>

<p>We’re going to start here by drawing the axis of the graph. For this, we’re going to reuse the <code>drawAxis</code> function that we previously created. We’ll again need to calculate the <code>labelWidth</code> value using the bounds of the longest graph label.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AreaChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {

	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
    <span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label
    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        drawAxis(labelWidth)
    }
}</code></pre>

<p>With the padding and height that has been applied to the <code>Canvas</code> we can see the axis being drawn with sufficient spacing around the bounds.</p>

<figure><img src="area_1.png"/></figure>

<hr />

<h3>Drawing the y-axis labels</h3>

<p>When it comes to the axis labels of our graph, we’re going to start by drawing the labels for the y-axis. For this, we’re going to be reusing the <code>drawValueLabelsOnYAxis</code> function that we previously created, but we first need some information that we can provide to the function. The function needs to know the maximum value that is going to be drawn for the y-axis labels, which is going to be the highest value in the <code>GraphData</code> collection that is provided to our <code>AreaChart</code> composable. We can calculate this value using the kotlin <code>maxOf</code> function on the provided <code>chartData</code> reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AreaChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
	...

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }

        ...
    }
}</code></pre>

<p>We also need to provide two other values to the function:</p>

<ul>
	<li><strong>labelCount</strong> - the number of labels to be displayed, this will be the number of items in the <code>chartData</code> collection</li>
	<li><strong>resources</strong> - this is a Resources reference that is used by the function to retrieve application resource values</li>
</ul>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AreaChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	...

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        ...

        drawValueLabelsOnYAxis(
			maximumValue, 					
			chartData.count(), 
			context.resources
		)
    }
}</code></pre>

<figure><img src="area_2.png"/></figure>

<p>With this function call being made, we can now see the y-axis label being drawn onto the canvas alongside the y-axis line.</p>

<hr />

<h3>Drawing the x-axis labels</h3>

<p>With the y-axis labels now in place, we can move on to drawing the labels for the x-axis. When it comes to drawing the labels and data points onto the x-axis of the graph, we’re going to need to split the width of the graph into equal segments that can be drawn into - this allows us to evenly space the pieces of information that are being drawn onto the <code>Canvas</code>. </p>

<figure><img src="width-1.png"/></figure>

<p>We’re going to start here by calculating the width of these segments. This calculation is going to be the width of the x-axis line, divided by the number o entries in our <code>chartData</code> collection - as this will give us an equal-sized segment for each entry in this collection. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 
	chartData.count()</code></pre>

<p>Next, we’re going to want to loop through each entry within our <code>chartData</code> reference and utilise the <code>drawDataLabelsOnXAxis</code> function to draw a label on the x-axis. When calling this function we simply need to pass in this calculated <code>widthSegment</code>, the index of the current item within the loop, along with the label and resources reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AreaChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	<span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label
    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }
        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 			chartData.count()

        drawAxis(labelWidth)

        chartData.forEachIndexed { index, current <span class="syntax-all syntax-keyword">-&gt;</span>
            drawDataLabelsOnXAxis(
				current.label, 
				widthSegment,
				index,			
				context.resources,
				labelWidth <span class="syntax-all syntax-keyword">+</span> padding
			)
        }

		...
    }
}</code></pre>

<figure><img src="area_3.png"/></figure>

<hr />

<h3>Drawing the data set</h3>

<p>Now that we have the axis and the corresponding labels in place, we can move on to drawing the data points onto the graph. Because we’re going to be drawing a continual line with a filled area, we can utilise the <code>Path</code> class to define the area and shape that we want to draw for our graph.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> pathToDraw <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Path</span>()</code></pre>

<p>We’re going to need to look through each entry within the <code>GraphData</code> list and create the shape that we want to draw using this <code>Path</code> reference. We’ll need to start by defining the start of the graph, this is where the drawing is going to be started. Using the <code>moveTo</code> function on our <code>Path</code> reference, we can define the starting point for the <code>Path</code>. The starting point of the graph is always going to be at the bottom left-hand corner of the graph, so we’ll need to define the coordinates that reflect this. For the x-coordinate, this will just be equal to any spacing/padding that has been applied to the graph. In terms of the y-coordinate, this is going to be the height of the canvas with any spacing/padding subtracted from it.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, current <span class="syntax-all syntax-keyword">-&gt;</span>
    <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">0</span>) {
        pathToDraw.moveTo(
            labelWidth <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> padding,
            size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness
        )
    }
}</code></pre>

<p>When it comes to drawing the rest of the path, the points to be drawn in the <code>Path</code> are going to consist of a collection of <code>Offset</code> references, so we’ll need to map each value in the dataset to an <code>Offset</code> value. For each offset value, we’ll need to provide values for both the <code>x</code> and <code>y</code> coordinates.</p>

<ul>
	<li><strong>x</strong> - Similar to the other graphs we’ve drawn, we’ll need to account for the previously calculated <code>labelWidth</code>, along with the defined <code>padding</code> and <code>strokeThickness</code>. We can then use the calculated <code>widthSegment</code> and <code>index</code> values to calculate what segment we are drawing in on the x-axis, along with half of the original <code>widthSegment</code> to draw the coordinate in the center of the segment.</li>
	<li><strong>y</strong> - for this position we’ll again need to split the available drawing area into equal segments, followed by using the current value in the loop to calculate the corresponding y position</li>
</ul>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, current <span class="syntax-all syntax-keyword">-&gt;</span>
	...

    <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">0</span>) {
        ...
    } <span class="syntax-all syntax-keyword">else</span> {
		<span class="syntax-all syntax-keyword">val</span> offsetToDraw <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
			padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>),
        	heightSegment <span class="syntax-all syntax-keyword">*</span> current.value
		)
    }
}</code></pre>

<p>Now that we have this <code>Offset</code> in place, we can use this to create a line within our <code>Path</code>. While we could just assign the <code>x</code> and <code>y</code> coordinates directly from this <code>Offset</code> reference, we want to keep up the theme of animated graph values, so we’re going to animate the <code>y</code> coordinate so that our graph grows into place from the bottom of the y-axis. We’ll need to start by configuring the animation at the top of our composable function, using the <code>chartData</code> reference that is provided to our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)</code></pre>

<p>Next, we’ll need to animate the value from the bottom of the y-axis to the value that was calculated and assigned in the <code>Offset</code> reference. We can calculate the bottom of the graph by using the height of the canvas, subtracting our defined <code>padding</code> and <code>strokeThickness</code> values.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> availableHeightFromBottom <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness</code></pre>

<p>We can now use this to calculate the y-coordinate that we wish to draw to, using the defined animation transition. We’ll do this by working out the distance from the bottom of the graph to the y-coordinate from the <code>Offset</code>, followed by multiplying this by the current <code>value</code> of the transition - this will allow us to animate from 0 (the bottom of the y-axis) to the y-coordinate for the corresponding entry in the graph data.</p>

<p>Once this has been calculated, we can utilise the <code>lineTo</code> function on the <code>Path</code> class to draw a line to the coordinates for this entry in the graph.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">val</span> availableHeightFromBottom <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness

chartData.forEachIndexed { index, current <span class="syntax-all syntax-keyword">-&gt;</span>
	...

    <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">0</span>) {
        pathToDraw.moveTo(
            padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> padding,
            size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness
        )
    } <span class="syntax-all syntax-keyword">else</span> {
		<span class="syntax-all syntax-keyword">val</span> offsetToDraw <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
			padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>),
        	heightSegment <span class="syntax-all syntax-keyword">*</span> current.value
		)
        <span class="syntax-all syntax-keyword">val</span> y <span class="syntax-all syntax-keyword">=</span> availableHeightFromBottom <span class="syntax-all syntax-keyword">-</span> 						((availableHeightFromBottom <span class="syntax-all syntax-keyword">-</span> offsetToDraw.y) <span class="syntax-all syntax-keyword">*</span> 
			transitionAnimation.value)
        pathToDraw.lineTo(offsetToDraw.x, y)
    }
}</code></pre>

<p>This <code>lineTo</code> operation is going to take place from index <code>1</code> up until the end of the graph being drawn. When the graph has reached the end of its drawing, we’re going to need to draw down to the bottom of the <code>Canvas</code> to finish off the area of the graph. We can do this by again using the <code>lineTo</code> operation, reusing the <code>x</code> value for the last item of the <code>chartData</code> collection, followed by using the height of the <code>Canvas</code> (minus any padding/spacing) to draw down to the bottom of the y-axis.</p>

<pre><code class="code-highlighted code-kt">chartData.forEachIndexed { index, current <span class="syntax-all syntax-keyword">-&gt;</span>
    <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">0</span>) {
        pathToDraw.moveTo(
            padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> padding,
            size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness
        )
    } <span class="syntax-all syntax-keyword">else</span> {
		<span class="syntax-all syntax-keyword">val</span> offsetToDraw <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(
			padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>),
        	heightSegment <span class="syntax-all syntax-keyword">*</span> current.value
		)
		<span class="syntax-all syntax-keyword">val</span> height <span class="syntax-all syntax-keyword">=</span> (heightSegment <span class="syntax-all syntax-keyword">*</span> current.value)  <span class="syntax-all syntax-keyword">*</span> transitionAnimation.value
        <span class="syntax-all syntax-keyword">val</span> y <span class="syntax-all syntax-keyword">=</span> availableHeightFromBottom <span class="syntax-all syntax-keyword">-</span> 						((availableHeightFromBottom <span class="syntax-all syntax-keyword">-</span> offsetToDraw.y) <span class="syntax-all syntax-keyword">*</span> 
			transitionAnimation.value)
        pathToDraw.lineTo(offsetToDraw.x, y)
        <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> chartData.count() <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">1</span>) {
            pathToDraw.lineTo(
            	offsetToDraw.x, 
                size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness
            )
        }
    }
}</code></pre>

<p>Now that we have our <code>Path</code> defined and all the instructions in place, we can utilise the <code>drawPath</code> operation to draw the contents of our <code>Path</code>. For this, we simply pass the <code>Path</code> reference, followed by the <code>Color</code> that we wish to use when drawing the path.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AreaChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	<span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label
    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }
        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 			chartData.count()
        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 		highestData.value
        <span class="syntax-all syntax-keyword">val</span> availableHeightFromBottom <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> 		strokeThickness

        drawAxis(labelWidth)

        <span class="syntax-all syntax-keyword">val</span> pathToDraw <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Path</span>()

        chartData.forEachIndexed { index, current <span class="syntax-all syntax-keyword">-&gt;</span>
            ...
        }

        drawPath(
            pathToDraw,
            <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>
        )

        ...
    }
}</code></pre>

<p>With the above in place, we can now slot the drawing logic into our composable, giving us a completed area graph to display the provided data set.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">AreaChart</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">val</span> transitionAnimation <span class="syntax-all syntax-keyword">=</span> configureAnimation(chartData)
	<span class="syntax-all syntax-keyword">val</span> context <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">LocalContext</span>.current
	<span class="syntax-all syntax-keyword">val</span> longestLabel <span class="syntax-all syntax-keyword">=</span> chartData.maxByOrNull { 
		it.label.length 
	}<span class="syntax-all syntax-keyword">!!</span>.label
    <span class="syntax-all syntax-keyword">val</span> labelTextPaint <span class="syntax-all syntax-keyword">=</span> labelTextPaint(context.resources)
    <span class="syntax-all syntax-keyword">val</span> labelWidth <span class="syntax-all syntax-keyword">=</span> labelTextPaint.measureText(longestLabel)

    <span class="syntax-all syntax-entity">Canvas</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .height(<span class="syntax-all syntax-constant">320</span>.dp)
            .fillMaxWidth()
            .padding(<span class="syntax-all syntax-constant">36</span>.dp)
    ) {
        <span class="syntax-all syntax-keyword">val</span> maximumValue <span class="syntax-all syntax-keyword">=</span> chartData.maxOf { it.value }
        <span class="syntax-all syntax-keyword">val</span> widthSegment <span class="syntax-all syntax-keyword">=</span> (size.width <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 			chartData.count()
        <span class="syntax-all syntax-keyword">val</span> heightSegment <span class="syntax-all syntax-keyword">=</span> (size.height <span class="syntax-all syntax-keyword">-</span> (padding <span class="syntax-all syntax-keyword">*</span> <span class="syntax-all syntax-constant">2</span>)) <span class="syntax-all syntax-keyword">/</span> 		highestData.value
        <span class="syntax-all syntax-keyword">val</span> availableHeightFromBottom <span class="syntax-all syntax-keyword">=</span> size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> 		strokeThickness

        drawAxis(labelWidth)

        <span class="syntax-all syntax-keyword">val</span> pathToDraw <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Path</span>()

        chartData.forEachIndexed { index, current <span class="syntax-all syntax-keyword">-&gt;</span>
            drawDataLabelsOnXAxis(
				current.label, 
				widthSegment,
				index,			
				context.resources,
				labelWidth <span class="syntax-all syntax-keyword">+</span> padding
			)

            <span class="syntax-all syntax-keyword">val</span> offsetToDraw <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Offset</span>(padding <span class="syntax-all syntax-keyword">+</span> strokeThickness 			<span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">*</span> index) <span class="syntax-all syntax-keyword">+</span> (widthSegment <span class="syntax-all syntax-keyword">/</span> <span class="syntax-all syntax-constant">2</span>),
                heightSegment <span class="syntax-all syntax-keyword">*</span> current.value)

            <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> <span class="syntax-all syntax-constant">0</span>) {
                pathToDraw.moveTo(
                    padding <span class="syntax-all syntax-keyword">+</span> strokeThickness <span class="syntax-all syntax-keyword">+</span> padding,
                    size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness
                )
            } <span class="syntax-all syntax-keyword">else</span> {
                <span class="syntax-all syntax-keyword">val</span> y <span class="syntax-all syntax-keyword">=</span> availableHeightFromBottom <span class="syntax-all syntax-keyword">-</span> 						((availableHeightFromBottom <span class="syntax-all syntax-keyword">-</span> 							offsetToDraw.y) <span class="syntax-all syntax-keyword">*</span> 										transitionAnimation.value)
                pathToDraw.lineTo(offsetToDraw.x, y)
                <span class="syntax-all syntax-keyword">if</span> (index <span class="syntax-all syntax-keyword">==</span> chartData.count() <span class="syntax-all syntax-keyword">-</span> <span class="syntax-all syntax-constant">1</span>) {
                    pathToDraw.<span class="syntax-all syntax-constant">apply</span> {
                        lineTo(size.width <span class="syntax-all syntax-keyword">-</span> padding, y)
                        lineTo(
							size.width <span class="syntax-all syntax-keyword">-</span> padding,
							size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness)
                        lineTo(
							padding <span class="syntax-all syntax-keyword">+</span> strokeThickness,
							size.height <span class="syntax-all syntax-keyword">-</span> padding <span class="syntax-all syntax-keyword">-</span> strokeThickness)
                    }
                }
            }
        }

        drawPath(
            pathToDraw,
            <span class="syntax-all syntax-entity">Color</span>.<span class="syntax-all syntax-entity">Black</span>
        )

        drawValueLabelsOnYAxis(
			maximumValue, 					
			chartData.count(), 
			context.resources
		)
    }
}</code></pre>

<figure><img src="area-1.png"/></figure>

<hr />

<h2>Composing the selected Graph</h2>

<p>Now that we have all our graphs and charts composed using individual functions, we’re going to create a composable that will be used to compose a graph based on the <code>GraphType</code> that is provided to it. Because our global state reference is holding a value that refers to the currently selected <code>GraphType</code>, this value can then be used to compose the corresponding graph. We’ll create a new composable function, <code>Graph</code>, that will take a <code>GraphType</code> along with the collection of <code>GraphData</code> that is to be used when composing a graph.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Graph</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
)</code></pre>

<p>We’ll then use a <code>when</code> block to compose a graph based on the provided <code>GraphType</code>. We’ll add a clause for each of the different <code>GraphType</code> values, passing the provided <code>modifer</code> and <code>chartData</code> values for composition.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Graph</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>,
    <span class="syntax-all syntax-parameter">chartData</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">List</span>&lt;<span class="syntax-all syntax-entity">GraphData</span>&gt;
) {
    <span class="syntax-all syntax-keyword">when</span> (chart) {
        <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">PIE</span> <span class="syntax-all syntax-keyword">-&gt;</span> 
			<span class="syntax-all syntax-entity">PieChart</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> modifier, 
				chartData <span class="syntax-all syntax-keyword">=</span> chartData
			)
        <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">LINE</span> <span class="syntax-all syntax-keyword">-&gt;</span> 
			<span class="syntax-all syntax-entity">LineChart</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> modifier, 
				chartData <span class="syntax-all syntax-keyword">=</span> chartData
			)
        <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">BAR</span> <span class="syntax-all syntax-keyword">-&gt;</span> 
			<span class="syntax-all syntax-entity">BarChart</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> modifier, 
				chartData <span class="syntax-all syntax-keyword">=</span> chartData
			)
        <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">COLUMN</span> <span class="syntax-all syntax-keyword">-&gt;</span> 
			<span class="syntax-all syntax-entity">ColumnChart</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> modifier, 
				chartData <span class="syntax-all syntax-keyword">=</span> chartData
			)
        <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">DOUGHNUT</span> <span class="syntax-all syntax-keyword">-&gt;</span> 
			<span class="syntax-all syntax-entity">DoughnutChart</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> modifier, 
				chartData <span class="syntax-all syntax-keyword">=</span> chartData
			)
        <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span> <span class="syntax-all syntax-keyword">-&gt;</span> 
			<span class="syntax-all syntax-entity">AreaChart</span>(
				modifier <span class="syntax-all syntax-keyword">=</span> modifier, 
				chartData <span class="syntax-all syntax-keyword">=</span> chartData
			)
    }
}</code></pre>

<p>With this in place, we now have a composable that can be used to compose the graph for a given <code>GraphType</code>, which will be based on the currently selected graph within our <code>GraphsState</code> reference. We’re not going to use this just yet, but it’s now ready to plug into our UI when it comes to the composition of the currently selected graph.</p>

<hr />

<h2>Building the Chart Picker</h2>

<p>Now that have a composable that can compose any given <code>GraphType</code>, we’re going to want to allow the user to select a graph from the available list of <code>GraphType</code> values. This selection will in turn update the <code>GraphsState</code>, causing the newly selected graph to be composed within our UI. We’ll start by creating a new composable function, <code>ChartPicker</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChartPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>
)</code></pre>

<p>We’re going to start by displaying the name of the currently selected chart. We’ll use a <code>Text</code> composable for this, using the <code>stringResource</code> function to retrieve the label for the provided <code>GraphType</code>. Because we are working with a range of text lengths for the <code>GraphType</code> values, we’re going to use the <code>widthIn</code> modifier to apply a minimum width to the text component - in most cases, this will stop the width of the composable constantly changing with the different text values. We’ll also apply some <code>padding</code> to increase the touch area of the composable, as we’re eventually going to make this a clickable component. Because we’re modifying the spacing of the composable, we’re going to use the <code>textAlign</code> argument to ensure that the composed text is always displayed in the center of the available space.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChartPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>
) {
	<span class="syntax-all syntax-entity">Text</span>(
	    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
            .padding(<span class="syntax-all syntax-constant">16</span>.dp)
            .widthIn(min <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">60</span>.dp),
        text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> chart.label),
        textAlign <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">TextAlign</span>.<span class="syntax-all syntax-entity">Center</span>
    )
}</code></pre>

<figure><img src="1-32.png"/></figure>

<p>Now that we have this <code>Text</code> in place, we can see the currently selected graph name. This component is going to be used to change the currently selected graph, so we need to make it clear to the user that this is possible using this component. To indicate this to the user, we’re going to add a chevron - this implies a dropdown selection is available for the current component. </p>

<p>We’ll need to start by wrapping the existing content in a <code>Row</code>, aligning the child composables of this container in the vertical center. Next, we’ll compose an <code>Icon</code>, providing the <code>ArrowDropDown</code> icon for the required image argument.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChartPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>
) {
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        ...
        <span class="syntax-all syntax-entity">Icon</span>(
            imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowDropDown</span>,
            contentDescription <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">null</span>
        )
    }
}</code></pre>

<figure><img src="2-29.png"/></figure>

<p>We’re also going to provide a content description for this <code>Icon</code>, so that screenreader can communicate the intent of the icon. We’ll start by adding a new string resource to our feature module.</p>

<pre><code class="code-highlighted code-xml">&lt;<span class="syntax-all syntax-tag">string</span> <span class="syntax-all syntax-entity">name</span>=<span class="syntax-all syntax-string">&quot;cd_select_chart&quot;</span>&gt;Select Chart Type&lt;/<span class="syntax-all syntax-tag">string</span>&gt;</code></pre>

<p>Followed by assigning the value of this reason to the <code>contentDescription</code> argument of the <code>Icon</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChartPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>
) {
    <span class="syntax-all syntax-entity">Box</span> {
        <span class="syntax-all syntax-entity">Row</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> modifier,
            verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
        ) {
            ...
            <span class="syntax-all syntax-entity">Icon</span>(
                imageVector <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Icons</span>.<span class="syntax-all syntax-entity">Default</span>.<span class="syntax-all syntax-entity">ArrowDropDown</span>,
                contentDescription <span class="syntax-all syntax-keyword">=</span> stringResource(
					id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_select_chart)
            )
        }
    }
}</code></pre>

<p>With the visuals now in place, we can go ahead and apply the <code>clickable</code> modifier to our composable. We’ll apply this to the parent <code>Row</code>, using the modifier to trigger a lambda function that we’ll add as an argument for our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChartPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>,
    <span class="syntax-all syntax-parameter">onPickerRequested</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-keyword">val</span> clickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_select_chart)
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .clickable { onPickerRequested() },
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        ...       
	}
}</code></pre>

<p>We can go one step further here to improve the accessibility of our composable, and that’s by lifting the content description of the <code>Icon</code> out and using it as the click action description for the <code>clickable</code> modifier that we just added to our <code>Row</code> composable. This means that now when the composable is focused, the action for the click event will be communicated to the user, as opposed to them needing to navigate the screen reader to the individual <code>Icon</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChartPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>,
    <span class="syntax-all syntax-parameter">onPickerRequested</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
	<span class="syntax-all syntax-keyword">val</span> clickLabel <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">R</span>.string.cd_select_chart)
    <span class="syntax-all syntax-entity">Row</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier
            .clickable(onClickLabel <span class="syntax-all syntax-keyword">=</span> clickLabel)
				{ onPickerRequested() },
        verticalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterVertically</span>
    ) {
        ...       
	}
}</code></pre>

<p>Now that we have the foreground of the selected graph in place, we’re going to implement the dropdown menu that will be used to select the graph to be displayed. For this, we’re going to use the <code>DropdownMenu</code> composable - this allows us to display a popup menu to allow selection from a set of items. For the composition of this we need to provide three required arguments:</p>

<ul>
	<li><strong>expanded</strong> - whether the dropdown menu is currently expanded, with the options visible to the user</li>
	<li><strong>onDismissRequest</strong> - lambda triggered when the dropdown is requested to be dismissed</li>
	<li><strong>content</strong> - the composable content of the dropdown menu</li>
</ul>

<p>For the first two arguments we currently have these being managed by the state of our screen, so we can simply pass these values into the composable function and use them directly within the composition of the <code>DropdownMenu</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChartPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>,
	<span class="syntax-all syntax-parameter">expanded</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">dismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onPickerRequested</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        ...
        <span class="syntax-all syntax-entity">DropdownMenu</span>(
            expanded <span class="syntax-all syntax-keyword">=</span> expanded,
            onDismissRequest <span class="syntax-all syntax-keyword">=</span> { dismiss() }
		) {
            
        }
    }
}</code></pre>

<p>Currently, we aren’t composing anything for the <code>content</code> of our <code>DropdownMenu</code>, so we’re going to use the defined values of <code>GraphType</code> to show the available options for the user. For each of these values, we’ll map to a composable in the form of a <code>DropdownMenuItem</code>. We’ll need to provide two arguments to this <code>DropdownMenuItem</code>:</p>

<ul>
	<li><strong>onClick</strong> - the lambda function to be triggered when the item is clicked</li>
	<li><strong>content</strong> - the content to be composed for the item</li>
</ul>

<p>For the <code>content</code> of each <code>DropdownMenuItem</code> we’re simply going to compose a <code>Text</code> that uses the <code>label</code> of the corresponding <code>GraphType</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">ChartPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>,
    <span class="syntax-all syntax-parameter">expanded</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">dismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onPickerRequested</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        ...
        <span class="syntax-all syntax-entity">DropdownMenu</span>(
            expanded <span class="syntax-all syntax-keyword">=</span> expanded,
            onDismissRequest <span class="syntax-all syntax-keyword">=</span> { dismiss() }
		) {
            <span class="syntax-all syntax-entity">GraphType</span>.values().map {
                <span class="syntax-all syntax-entity">DropdownMenuItem</span>(onClick <span class="syntax-all syntax-keyword">=</span> { 

				}) {
                    <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> it.label))
                }
            }
        }
    }
}</code></pre>

<figure><img src="Screenshot_20220517_144317.png"/></figure>

<p>Now that each <code>DropdownMenuItem</code> has a visual representation in the form of the graph name, we now need to let the parent composable know that a new graph type has been selected. Here we’ll define a new argument for our composable function, <code>onItemSelected</code>, in the form of a lambda that can be used to pass the selected <code>GraphType</code> up to the parent.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GraphPicker</span>(
    <span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
    <span class="syntax-all syntax-parameter">chart</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>,
    <span class="syntax-all syntax-parameter">expanded</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-constant">Boolean</span>,
    <span class="syntax-all syntax-parameter">dismiss</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onItemSelected</span><span class="syntax-all syntax-keyword">:</span> (chart<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>,
    <span class="syntax-all syntax-parameter">onPickerRequested</span><span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Box</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier) {
        ...
        <span class="syntax-all syntax-entity">DropdownMenu</span>(
            expanded <span class="syntax-all syntax-keyword">=</span> expanded,
            onDismissRequest <span class="syntax-all syntax-keyword">=</span> { dismiss() }
		) {
            <span class="syntax-all syntax-entity">GraphType</span>.values().map {
                <span class="syntax-all syntax-entity">DropdownMenuItem</span>(onClick <span class="syntax-all syntax-keyword">=</span> { 
					onItemSelected(it) 
				}) {
                    <span class="syntax-all syntax-entity">Text</span>(text <span class="syntax-all syntax-keyword">=</span> stringResource(id <span class="syntax-all syntax-keyword">=</span> it.label))
                }
            }
        }
    }
}</code></pre>

<p>With this in place, the user now has a way to change the currently selected graph.</p>

<hr />

<h2>Composing the Dashboard</h2>

<p>Now that we’ve created both the <code>Graph</code> and <code>GraphPicker</code> composables, we’re ready to slot these into our dashboard so that the graph and picker are composed in our UI. We’ll start by composing the <code>ChartPicker</code>, for which we’re going to need to provide a couple of arguments:</p>

<ul>
	<li><strong>chart</strong> - the currently selected graph, referencing the <code>selectedGraph</code> value from the <code>GraphsState</code> reference</li>
	<li><strong>expanded</strong> - whether or not the picker should be displayed as expanded, which will be provided as the <code>showGraphPicker</code> from the <code>GraphsState</code> reference</li>
	<li><strong>dismiss</strong> - callback used to receive events for when the picker is to be dismissed. We’ll need to pass this up to the parent composable so that the corresponding event can be handled in the ViewModel. We’ll add a new argument to the composable function, <code>handleEvent</code>, which can then be used to trigger the <code>DismissPicker</code> event</li>
	<li><strong>onItemSelected</strong> - callback used to receive events for when an item in the picker is selected. Also using the <code>handleEvent</code> lambda, we can use this to trigger the <code>SetChartType</code> event, passing the selected item as the argument</li>
	<li><strong>onPickerRequested</strong> - callback used to receive events for when the display of the picker is requested. Again using the <code>handleEvent</code> lambda we can trigger the <code>ShowPicker</code> event to update the state for our screen</li>
</ul>

<p>Alongside the composition of the <code>ChartPicker</code>, we’ll also compose this with a <code>Spacer</code> inside of a <code>Column</code> - we need to use a <code>Column</code> here as we’re going to be displaying multiple composables, stacked vertically.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GraphsDashboard</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsState</span>, 
	<span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
    ) {
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
        <span class="syntax-all syntax-entity">ChartPicker</span>(
            chart <span class="syntax-all syntax-keyword">=</span> state.selectedGraph,
            expanded <span class="syntax-all syntax-keyword">=</span> state.showGraphPicker,
            dismiss <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">DismissPicker</span>)
            },
            onItemSelected <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">SetChartType</span>(it))
            },
            onPickerRequested <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">ShowPicker</span>)
            }
        )
    }
}</code></pre>

<figure><img src="1-33.png"/></figure>

<p>Now that the chart picker is in place we can look at composing the currently selected chart, done so using the <code>Chart</code> composable. We’ll provide value for the three arguments of this composable:</p>

<ul>
	<li><strong>modifier</strong> - we’ll use the <code>fillMaxWidth</code> modifier to have the composable fill the available width, along with the <code>weight</code> modifier to have the composable fill the remaining space</li>
	<li><strong>chart</strong> - the chart to be composed, which will be the <strong>selectedChart</strong> from the state reference</li>
	<li><strong>chartData</strong> - the data to be used for graph composition, which is referenced from the <code>chartData</code> value of the state reference</li>
</ul>

<p>Before composing this we’ll also utilise the <code>Spacer</code> to ensure that there is sufficient spacing between the <code>ChartPicker</code> and <code>Chart</code> composables.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Composable
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">GraphsDashboard</span>(
	<span class="syntax-all syntax-parameter">modifier</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">Modifier</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>,
	<span class="syntax-all syntax-parameter">state</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsState</span>, 
	<span class="syntax-all syntax-parameter">handleEvent</span><span class="syntax-all syntax-keyword">:</span> (event<span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphsEvent</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span>
) {
    <span class="syntax-all syntax-entity">Column</span>(
        modifier <span class="syntax-all syntax-keyword">=</span> modifier,
        horizontalAlignment <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Alignment</span>.<span class="syntax-all syntax-entity">CenterHorizontally</span>,
    ) {
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
        <span class="syntax-all syntax-entity">ChartPicker</span>(
            chart <span class="syntax-all syntax-keyword">=</span> state.selectedChart,
            expanded <span class="syntax-all syntax-keyword">=</span> state.showChartPicker,
            dismiss <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">DismissPicker</span>)
            },
            onItemSelected <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">SetChartType</span>(it))
            },
            onPickerRequested <span class="syntax-all syntax-keyword">=</span> {
                handleEvent(<span class="syntax-all syntax-entity">GraphsEvent</span>.<span class="syntax-all syntax-entity">ShowPicker</span>)
            }
        )
        <span class="syntax-all syntax-entity">Spacer</span>(modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.height(<span class="syntax-all syntax-constant">16</span>.dp))
        <span class="syntax-all syntax-entity">Chart</span>(
            modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
                .fillMaxWidth()
                .weight(<span class="syntax-all syntax-constant">1f</span>),
            chart <span class="syntax-all syntax-keyword">=</span> state.selectedChart,
            chartData <span class="syntax-all syntax-keyword">=</span> state.chartData
        )
    }
}</code></pre>

<figure><img src="11-5.png"/></figure>

<p>With this in place, we can see that the picker and graph composables are now being composed, with the <code>Chart</code> representing the currently selected <code>GraphType</code> from the <code>ChartPicker</code>.</p>

<hr />

<h2>Wrapping Up</h2>

<p>Throughout this project, we’ve now fully implemented our graphs feature - allowing our users to view a provided data set in several different graph formats. We’ve explored the composition of data onto a canvas, not only learning how to draw different kinds of information onto a canvas but also animating it in the process.</p>

<figure><img src="compppp-2.png"/></figure>

<hr />

<h1>Testing the Graphs UI</h1>

<p>Now that we’ve built our Music Dashboard feature, we’re going to take a look at how we can write tests for our composables. We’re going to be writing some instrumentation tests using the compose ui-test-junit package - allowing us to verify that our composables are displayed and functioning as expected.</p>

<p>Before we can get started with our tests, we’re going to need to add a couple of test specific dependencies to our project:</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-junit4:$compose_version&quot;</span>)
debugImplementation(
	<span class="syntax-all syntax-string">&quot;androidx.compose.ui:ui-test-manifest:$compose_version&quot;</span>)</code></pre>

<p>We’re also going to need to add mocks to our test - this allows us to easily provide mock references to any listeners that are provided to our composable functions, allowing us to easily verify they are triggered whenever expected.</p>

<pre><code class="code-highlighted code-kt">androidTestImplementation(
	<span class="syntax-all syntax-string">&quot;org.mockito.kotlin:mockito-kotlin:3.2.0&quot;</span>)
androidTestImplementation(<span class="syntax-all syntax-string">&quot;org.mockito:mockito-android:3.12.4&quot;</span>)</code></pre>

<p>With these in place, we now have access to the required rules and functionality that allow us to test our composable UI. However, alongside these dependencies, we’re also going to need to add some rules to our <code>build.gradle</code> file that will fix some of the compilation errors that we’d currently see when trying to run our tests. Here we’ll add some <code>packagingOptions</code> that will exclude certain packages from the added dependencies. We won’t dive too much into this concept and it’s usually dependent on the versions of dependencies that are being used, so this may be redundant if you come to updating versions.</p>

<pre><code class="code-highlighted code-kt">android {
	packagingOptions {
		exclude <span class="syntax-all syntax-string">&quot;**/attach_hotspot_windows.dll&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/AL2.0&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/LGPL2.1&quot;</span>
		exclude <span class="syntax-all syntax-string">&quot;META-INF/licenses/ASM&quot;</span>
	}
}</code></pre>

<hr />

<h2>Testing the Graph Picker</h2>

<p>A key component in our UI is the chart picker - this allows the user to change the graph that is currently being displayed on the screen. To ensure that this component is operating as expected, we’ll start here by creating a new test class, <code>ChartPickerTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ChartPickerTest</span> {

}</code></pre>

<p>Inside of this class, we now need to define a reference to the <code>ComposeContentTestRule</code> class - this is what we’re going to use to set the composable content on screen, allowing us to perform interactions and assertions from within our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ChartPickerTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>When using this rule, we don’t need to specify any form of activity for our composables to be launched, the test rule will handle that for us. So using this rule we will set the composable content to be composed, the test will then launch a host activity which will be used to compose our provided content inside.</p>

<p>With this test class configured, we’re going to write some tests to assert that each of the expected composables is being displayed when required - which will be based on the properties that are provided to the <code>ChartPicker</code> composable. We’ll start here by asserting that the selected chart is being composed - the header should always be composed within the messaging screen, so we don’t need to worry about passing any specific state to it.</p>

<p>We’ll create a new test case, <code>Selected_Chart_Displayed</code>. Inside of this test, we’re going to need to start by setting the composable content that is to be displayed on the screen for us to perform assertions against. Here we’ll use the test rule that we previously defined, along with its <code>setContent</code> function. This function takes a composable function as an argument, allowing us to define what is to be composed on screen for our tests. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ChartPickerTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    <span class="syntax-all syntax-keyword">@Test
</span>    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Selected_Chart_Displayed</span>() {
        composeTestRule.setContent {
            <span class="syntax-all syntax-entity">ChartPicker</span>(
                chart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>,
                expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
                dismiss <span class="syntax-all syntax-keyword">=</span> { },
                onItemSelected <span class="syntax-all syntax-keyword">=</span> { },
                onPickerRequested <span class="syntax-all syntax-keyword">=</span> { }
            )
        }

    }
}</code></pre>

<p>So that we can locate the selected chart within our test, we’re going to need to add a tag to the composable that we wish to perform assertions against - this tag can then be used to locate our composable within our tests. We’ll need to start here by defining a tag reference that can be accessed from both our tests and our composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_SELECTED_CHART</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;selected_chart&quot;</span>
}</code></pre>

<p>With this tag defined, we’ll then need to add this to our <code>ChartPicker</code> composable. We’ll assign this to the <code>Text</code> composable within the function that represents the selected chart, using the <code>testTag</code> modifier to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// ChartPicker.kt
</span>
<span class="syntax-all syntax-entity">Text</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>
		...
		.testTag(<span class="syntax-all syntax-entity">TAG_SELECTED_CHART</span>),
	...
)</code></pre>

<p>Next, we’re going to locate the node within our composable hierarchy so that we can perform interactions and assertions on it. Here we’ll utilise the <code>onNodeWithTag</code> function, providing the tag that we defined above. We can then utilise the <code>assertTextEquals</code> function to assert that the composable is displaying the expected text within the <code>ChartPicker</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ChartPickerTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

    <span class="syntax-all syntax-keyword">@Test
</span>    <span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Selected_Chart_Displayed</span>() {
        composeTestRule.setContent {
            <span class="syntax-all syntax-entity">ChartPicker</span>(
                chart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>,
                expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
                dismiss <span class="syntax-all syntax-keyword">=</span> { },
                onItemSelected <span class="syntax-all syntax-keyword">=</span> { },
                onPickerRequested <span class="syntax-all syntax-keyword">=</span> { }
            )
        }

		composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SELECTED_CHART</span>)
            .assertTextEquals(
                <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
                    .targetContext.getString(
						<span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>.label)
            )
    }
}</code></pre>

<p>Now that we are asserting that the selected chart is being displayed, we’re going to assert that all available charts are being displayed within the picker. We’ll need to start here by composing the <code>ChartPicker</code>, passing in a state reference that marks the <code>expanded</code> flag as <code>true</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Chart_Types_Displayed</span>() {
    composeTestRule.setContent {
    	<span class="syntax-all syntax-entity">ChartPicker</span>(
            chart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>,
            expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            dismiss <span class="syntax-all syntax-keyword">=</span> { },
            onItemSelected <span class="syntax-all syntax-keyword">=</span> { },
            onPickerRequested <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p> When the picker is composed, the charts available for selection should now be displayed. To test this we’re going to want to loop through the available values, asserting that each of the graph type names is being displayed. Using the <code>TAG_CHART_TYPES</code> tag that we previously defined, we can use the <code>onChildAt</code> function to locate the child node at the current index within our loop. At this position, there should be corresponding text content that matches the name of the chart. We can asset this by using <code>hasText</code>, passing in the string representation of the chart <code>label</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Chart_Types_Displayed</span>() {
    composeTestRule.setContent {
    	<span class="syntax-all syntax-entity">ChartPicker</span>(
            chart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>,
            expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            dismiss <span class="syntax-all syntax-keyword">=</span> { },
            onItemSelected <span class="syntax-all syntax-keyword">=</span> { },
            onPickerRequested <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    <span class="syntax-all syntax-entity">GraphType</span>.values().forEachIndexed { index, chartType <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CHART_TYPES</span>)
            .onChildAt(index)
            .<span class="syntax-all syntax-keyword">assert</span>(hasText(
				<span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
                    .targetContext.getString(chartType.label))
			)
    }
}</code></pre>

<p>Now that we know all of the expected data is being displayed, we’re going to want to assert that the interactions with the components are being triggered - as otherwise, the user won’t be able to change the chart that is being displayed on-screen. We’ll start here by asserting that the request to display the picker is being triggered - we pass this event unto the parent composable via the <code>onPickerRequested</code> lambda argument, so we’ll want to test this in a new test case, <code>Picker_Requested_Triggered</code>. When composing the <code>ChartPicker</code> we’ll pass a mock implementation of the <code>onPickerRequested</code> lambda - this is so that we can verify this is involved when the composable is interacted with.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Picker_Requested_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onPickerRequested<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChartPicker</span>(
            chart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>,
            expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
            dismiss <span class="syntax-all syntax-keyword">=</span> { },
            onItemSelected <span class="syntax-all syntax-keyword">=</span> { },
            onPickerRequested <span class="syntax-all syntax-keyword">=</span> onPickerRequested
        )
    }
}</code></pre>

<p>We’ll then use the <code>TAG_SELECTED_CHART</code> tag to locate our <code>ChartPicker</code>, utilising the <code>performClick</code> function to invoke a click event on the located node. When this click event occurs we would expect the <code>onPickerRequested</code> lambda to be invoked - so at this point we want to verify that this is the case by utilising the mockito verify function. This allows us to assert that the lambda is triggered as expected when the node is clicked.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Picker_Requested_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> onPickerRequested<span class="syntax-all syntax-keyword">:</span> () <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChartPicker</span>(
            chart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>,
            expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">false</span>,
            dismiss <span class="syntax-all syntax-keyword">=</span> { },
            onItemSelected <span class="syntax-all syntax-keyword">=</span> { },
            onPickerRequested <span class="syntax-all syntax-keyword">=</span> onPickerRequested
        )
    }

    composeTestRule
		.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_SELECTED_CHART</span>)
		.performClick()

    verify(onPickerRequested).invoke()
}</code></pre>

<p>Alongside asserting that the <code>onPickerRequested</code> lambda is being triggered, we’re also going to want to cover the <code>onItemSelected</code> lambda. We’ll do the same here again by creating a mock to provide to the composable and composing the <code>ChartPicker</code> for our test.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Item_Selected_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> chartToSelect <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">DOUGHNUT</span>
    <span class="syntax-all syntax-keyword">val</span> onItemSelected<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">type</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChartPicker</span>(
            chart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>,
            expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            dismiss <span class="syntax-all syntax-keyword">=</span> { },
            onItemSelected <span class="syntax-all syntax-keyword">=</span> onItemSelected,
            onPickerRequested <span class="syntax-all syntax-keyword">=</span> { }
        )
    }
}</code></pre>

<p>You’ll notice here that we’ve defined a <code>chartToSelect</code> variable, assigning a <code>GraphType</code> reference to it. We do this so that we have a <code>GraphType</code> to click on within the list of graphs - which we can then use to assert that the selected function is triggered. Using the <code>onNodeWithText</code> function we’ll locate the node with the corresponding graph <code>label</code>, followed by performing a click action on this node using the <code>performClick</code> function.</p>

<p>When this click event occurs, we would expect the <code>onItemSelected</code> lambda function to be invoked with the <code>GraphType</code> that was selected by the user. In our test, we used the <code>label</code> from the <code>chartToSelect</code> reference, so we would also expect the <code>onItemSelected</code> lambda to be triggered with this reference. We’ll use the mocktio <code>verify</code> function to assert that the lambda is invoked with the expected <code>GraphType</code> value.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Item_Selected_Triggered</span>() {
    <span class="syntax-all syntax-keyword">val</span> chartToSelect <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">DOUGHNUT</span>
    <span class="syntax-all syntax-keyword">val</span> onItemSelected<span class="syntax-all syntax-keyword">:</span> (<span class="syntax-all syntax-parameter">type</span><span class="syntax-all syntax-keyword">:</span> <span class="syntax-all syntax-entity">GraphType</span>) <span class="syntax-all syntax-keyword">-&gt;</span> <span class="syntax-all syntax-constant">Unit</span> <span class="syntax-all syntax-keyword">=</span> mock()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">ChartPicker</span>(
            chart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">AREA</span>,
            expanded <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">true</span>,
            dismiss <span class="syntax-all syntax-keyword">=</span> { },
            onItemSelected <span class="syntax-all syntax-keyword">=</span> onItemSelected,
            onPickerRequested <span class="syntax-all syntax-keyword">=</span> { }
        )
    }

    composeTestRule.onNodeWithText(
        <span class="syntax-all syntax-entity">InstrumentationRegistry</span>.getInstrumentation()
            .targetContext.getString(chartToSelect.label)
    ).performClick()

    verify(onItemSelected).invoke(chartToSelect)
}</code></pre>

<hr />

<h2>Testing the Legend</h2>

<p>Now that we’ve got tests in place to cover the display of the graphs, we’re next going to add some tests to ensure that the legend is being displayed as expected. We’ll place these tests inside of a new test class, <code>LegendTest</code>.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LegendTest.kt
</span>
<span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">LegendTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>In this test, we’re going to want to assert that the labels of the legend are being composed. So that we can perform these assertions, we’re going to start by using our test rule to compose the <code>Legend</code>. </p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// LegendTest.kt
</span>
<span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Chart_Data_Labels_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> chartData <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphsDataFactory</span>.makeChartData()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Legend</span>(chartData <span class="syntax-all syntax-keyword">=</span> chartData)
    }
}</code></pre>

<p>Before we can perform assertions on this composable, we’re going to need to add a tag to the composable - this will allow us to locate the node representing the legend from within our tests.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_LEGEND</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;TAG_LEGEND&quot;</span>
}</code></pre>

<p>With this tag defined, we’ll go ahead and apply this tag to the parent composable within our <code>Legend</code>, using the <code>testTag</code> modifier to do so.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Legend.kt
</span><span class="syntax-all syntax-entity">Column</span>(modifier <span class="syntax-all syntax-keyword">=</span> modifier.testTag(<span class="syntax-all syntax-entity">TAG_LEGEND</span>))</code></pre>

<p>Now that this tag is in place, we can locate the <code>Legend</code> node within our tests. We’re going to want to assert that each of the labels is being displayed within the legend. To test this, we’ll start by looping through the <code>chartData</code> that the <code>Legend</code> is being composed with. For each item in this loop, we’ll use the current <code>index</code> of the loop to retrieve the child using the <code>onChildAt</code> function - we use the index here because we expect the chart data labels to be composed in the same order that they are in within the list. Now that we have the child node at the given index, we can use the <code>assert</code> function to check that the <code>label</code> is displayed.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Chart_Data_Labels_Displayed</span>() {
    <span class="syntax-all syntax-keyword">val</span> chartData <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphsDataFactory</span>.makeChartData()
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">Legend</span>(chartData <span class="syntax-all syntax-keyword">=</span> chartData)
    }

    chartData.forEachIndexed { index, <span class="syntax-all syntax-keyword">data</span> <span class="syntax-all syntax-keyword">-&gt;</span>
        composeTestRule
			.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_LEGEND</span>)
			.onChildAt(index)
			.<span class="syntax-all syntax-keyword">assert</span>(hasText(<span class="syntax-all syntax-keyword">data</span>.label))
    }
}</code></pre>

<hr />

<h2>Testing the Graphs Dashboard</h2>

<p>Now that we have the lower-level components being tested, we’re going to hop up to a higher level in our composable tree - the <code>GraphsDashboard</code>. We’re going to test that the expected graphs are being composed based on the current state of our composable. We’ll start here by creating a new test, <code>GraphsDashboardTest</code>, with a supporting test rule.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">GraphsDashboardTest</span> {

    <span class="syntax-all syntax-keyword">@get:Rule
</span>    <span class="syntax-all syntax-keyword">val</span> composeTestRule <span class="syntax-all syntax-keyword">=</span> createComposeRule()

}</code></pre>

<p>Within this dashboard, we allow the user to change the graph that is currently being displayed - if this component isn’t visible, then our feature becomes quite broken. We’re going to write a quick test to assert that the <code>ChartPicker</code> is being displayed on-screen as expected. In this test, we’ll simply need to compose the <code>GraphsDashboard</code> and pass a default <code>GraphsState</code> state reference.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Chart_Picker_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GraphsDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphsState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
}</code></pre>

<p>Next, we’ll need to add a new tag to our <code>Tags</code> object so that we can locate the <code>ChartPicker</code> composable.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHART_TYPE_TOGGLE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;chart_type_toggle&quot;</span>
}</code></pre>

<p>We’ll then want to apply this tag to the corresponding composable using the <code>testTag</code> modifier.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// GraphsDashboard.kt
</span>
<span class="syntax-all syntax-entity">ChartPicker</span>(
    modifier <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">Modifier</span>.testTag(<span class="syntax-all syntax-entity">TAG_CHART_TYPE_TOGGLE</span>),
    ...
)</code></pre>

<p>We can then utilise this in a test to assert that the <code>ChartPicker</code> composable is being composed. We’ll utilise the <code>onNodeWithTag</code> function to locate the corresponding node, followed by <code>assertIsDisplayed</code> to assert that the composable is being displayed as expected.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Chart_Picker_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GraphsDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphsState</span>(),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }

    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CHART_TYPE_TOGGLE</span>)
        .assertIsDisplayed()
}</code></pre>

<p>Now that we have the <code>ChartPicker</code> being tested, we’ll want to assert that each of the expected graph types is being composed. So that we can locate these graphs, we’re going to need to add tags that can be used to locate each of these. We’ll add a new tag for each of the graph types:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-comment">// Tags.kt
</span>
<span class="syntax-all syntax-keyword">object</span> Tags {
	<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHART_BAR</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;chart_bar&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHART_COLUMN</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;chart_column&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHART_PIE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;chart_pie&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHART_DOUGHNUT</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;chart_doughnut&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHART_AREA</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;chart_area&quot;</span>
    <span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-keyword">val</span> <span class="syntax-all syntax-entity">TAG_CHART_LINE</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&quot;chart_line&quot;</span>
}</code></pre>

<p>Then for each <code>Canvas</code> within the corresponding graph composables we’ll need to assign the tag using the <code>testTag</code> modifier. We won’t cover this for each graph as the code is the same, but in the case of the line graph, this will look like so:</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-entity">Canvas</span>(
	modifier <span class="syntax-all syntax-keyword">=</span> modifier
		.height(<span class="syntax-all syntax-constant">320</span>.dp)
		.fillMaxWidth()
        .padding(<span class="syntax-all syntax-constant">36</span>.dp)
        .testTag(<span class="syntax-all syntax-entity">TAG_CHART_LINE</span>)
)</code></pre>

<p>We can then write a test to assert that the expected graph is being displayed upon composition. We’ll start here by creating a new test case, <code>Line_Chart_Displayed</code>. In this we’re going to want to compose the <code>GraphsDashboard</code>, passing in a <code>GraphsState</code> that defines the <code>selectedChart</code> as the <code>GraphType.LINE</code> type. When this is the case, we would expect the line chart to be composed - so we can assert this using the <code>TAG_CHART_LINE</code> tag.</p>

<pre><code class="code-highlighted code-kt"><span class="syntax-all syntax-keyword">@Test
</span><span class="syntax-all syntax-keyword">fun</span> <span class="syntax-all syntax-entity">Line_Chart_Displayed</span>() {
    composeTestRule.setContent {
        <span class="syntax-all syntax-entity">GraphsDashboard</span>(
            state <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphsState</span>(
                selectedChart <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-entity">GraphType</span>.<span class="syntax-all syntax-entity">LINE</span>
            ),
            handleEvent <span class="syntax-all syntax-keyword">=</span> {}
        )
    }
    composeTestRule.onNodeWithTag(<span class="syntax-all syntax-entity">TAG_CHART_LINE</span>)
        .assertIsDisplayed()
}</code></pre>

<p>In the project code, you’ll find the rest of the tests for each graph type, we haven’t included them here as the code is almost identical!</p>

<hr />

</body>
</html>

